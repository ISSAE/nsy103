<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD><TITLE></TITLE>
<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.05">
</HEAD>
<BODY >
<!--HEVEA command line is: hevea -francais CHTML.tex -->
<!--FRENCH-->
<!--HTMLHEAD-->
<!--ENDHTML-->
<!--CUT DEF chapter 1 -->

<BR>
<BR>
<FONT SIZE=5>


<BR>
<BR>
 
 
 <BR>
<BR>
 </FONT>
<H1 ALIGN=center><FONT SIZE=5><FONT SIZE=5>Cours Système</FONT></FONT></H1><FONT SIZE=5>
</FONT>
<H3 ALIGN=center><FONT SIZE=5><FONT SIZE=5>D.Revuz
<img src="http://perso0.free.fr/cgi-bin/wwwcount.cgi?df=dominique.revuz.NCS.dat&amp;dd=zero&amp;ft=0">
<img src="http://perso0.free.fr/cgi-bin/wwwcount.cgi?df=dominique.revuz.HEVEA.dat&amp;dd=zero&amp;ft=0">
</FONT></FONT></H3><FONT SIZE=5>
</FONT>
<H3 ALIGN=center><FONT SIZE=5></FONT></H3><BLOCKQUOTE><FONT SIZE=5><B>Résumé&nbsp;: </B></FONT><FONT SIZE=5>
 Cours de conception de systèmes et d'utilistion d'UNIX<BR>Ce poly est a l'usage des etudiants de l'ESITCOM et du deuxième cycle
d'informatique de Marne la Vallée comme support du cours SYSTÈMES
d'EXPLOITATION.<BR>
<BR>
Cette version 2, apportte de nombreuse correction de typo et autre, je remercie
D. Lecorfec Pour sa lecture attentive, et les remarques sur le fond seront
prises en compte dans la prochaine version.<BR>
<BR>
Ce poly a une version HTML disponible sur le Web a l'adresse suivante &nbsp;:<BR></FONT>
<FONT SIZE=5><TT>http://www-igm.univ-mlv.fr/~dr/NCS/</TT></FONT><FONT SIZE=5>.<BR>
<BR>
Ce document a de nombreux défauts en particulier sont manque d'homogénéité, et
le manque d'explications sur certaines parties (explication données en général
oralement en cours).<BR>
<BR>
Au menu l'essentiel d'UNIX&nbsp;: SGF, processus, signaux, mémoire, mémoire
virtuelle, manipulation terminaux, tubes, IPC.
Quelques détours &nbsp;: micro-noyaux, sécurité.
Un chapitre important mais un peut court&nbsp;: les problèmes de programation
distribué. Peut être une petit incursion sur les pages de G. Roussel vous en
apprendrons plus, sur les threads,
les serveurs, JAVA etc .<BR></FONT><FONT SIZE=5><TT>http://massena.univ-mlv.fr/&nbsp;roussel</TT></FONT><BR>
<BR>
<FONT SIZE=5>Prérequis&nbsp;: pour la partie conceptuelle pas de prérequis.
pour la partie technique une compétance raisonable en C/C++ est nécessaire.<BR>
<BR>
Évolutions futures&nbsp;: dr@univ-mlv.fr (j'attend vos remarques), uniformisation
de la présentation, nétoyage des points obscurs, corrections orthographiques,
complement sur fcntl, ioctl, plus d'exemples, des sujets de projets . </FONT></BLOCKQUOTE><BR>
<BR>
<FONT SIZE=5>

</FONT><!--TOC chapter <FONT SIZE=5>Bibliographie</FONT>-->

<H1><FONT SIZE=5>Chapitre&nbsp;1&nbsp;&nbsp; Bibliographie</FONT></H1><!--SEC END -->
<FONT SIZE=5>J.-M. Rifflet. </FONT><FONT SIZE=5><EM>La programation sous</EM></FONT><FONT SIZE=5> UNIX. Ediscience, 1993. Le manuel de
référence.<BR>A.Tanenbaum. </FONT><FONT SIZE=5><EM>Systèmes d'exploitation, sysytèmes centralisés, systèmes
distribués.</EM></FONT><FONT SIZE=5> Inter-Editions, 1994. Cours général sur les sytèmes d'exploitation.<BR>M. Bach. </FONT><FONT SIZE=5><EM>The design of the UNIX operating system.</EM></FONT><FONT SIZE=5> 1986. Prentice-Hall, Englewood Cliffs,
 N.J. ISBN 0-13-201757-1<BR>J. Beauquier &amp; B. Bérard </FONT><FONT SIZE=5>Systèmes d'exploitation concepts et
 algorithmes</FONT><FONT SIZE=5>. 1991. McGraw-Hill. ISBN 2-7042-1221-X<BR>W.R. Stevens, </FONT><FONT SIZE=5><EM>UNIX Network Programming.</EM></FONT><FONT SIZE=5> 1990 Prentice-Hall, Englewood Cliffs,
 N.J. <BR>W.R. Stevens, </FONT><FONT SIZE=5><EM>Advanced Programming in the UNIX Environnement</EM></FONT><FONT SIZE=5>
Addison-Wesley ISBN 0-201-56317-7<BR>
<BR>

<BR>
<BR>
 
<BR>
<BR>

<BR>
<BR>
</FONT><!--TOC chapter <FONT SIZE=5>Introduction et Historique</FONT>-->

<H1><FONT SIZE=5>Chapitre&nbsp;2&nbsp;&nbsp; Introduction et Historique</FONT></H1><!--SEC END -->
<FONT SIZE=5>

</FONT><!--TOC section <FONT SIZE=5>Historique</FONT>-->

<H2><FONT SIZE=5>2.1&nbsp;&nbsp; Historique</FONT></H2><!--SEC END -->
<FONT SIZE=5>
</FONT><!--TOC subsection <FONT SIZE=5>les débuts (1945-55)</FONT>-->

<H3><FONT SIZE=5>2.1.1&nbsp;&nbsp; les débuts (1945-55)</FONT></H3><!--SEC END -->
<FONT SIZE=5> L'ENIAC</FONT><FONT SIZE=5>ENIAC</FONT><FONT SIZE=5> soit 20000 tubes à vide, fait 20 tonnes et occupe 160 </FONT><FONT SIZE=5><I>m</I></FONT><SUP><FONT SIZE=4>2</FONT></SUP><FONT SIZE=5>.<BR>Chaque Calculateur est unique et une équipe travaille à la fois à la fabrication, la programmation, la maintenance et l'utilisation.<BR>Ce sont des machines sans mémoire, exécutant un seul programme à la fois. Le chargement des programmes et des données se fait au mieux avec des cartes ou des bandes perforées.<BR>Durant cette période de nombreuses tâches sont automatisées, chargement, assemblage, édition de liens (avec des bibliothèques).<BR>Plus tard sont développés les compilateurs permettant d'utiliser des langages de plus haut niveau.<BR>
<BR>

</FONT><!--TOC subsection <FONT SIZE=5>Transistors et traitement par lots 1955-65 </FONT>-->

<H3><FONT SIZE=5>2.1.2&nbsp;&nbsp; Transistors et traitement par lots 1955-65 </FONT></H3><!--SEC END -->
<FONT SIZE=5>Invention de la mémoire </FONT><FONT SIZE=5><FONT FACE=symbol>¾®</FONT></FONT><FONT SIZE=5> Fabrication industrielle, commercialisation de machines.<BR>
<BR>
Une séance-type de programmation&nbsp;:<BR>
<BR>
</FONT><UL>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5> écriture sur cartes [programmeur]
</FONT>
<LI><FONT SIZE=5> chargement des cartes compilateur [opérateur]
</FONT>
<LI><FONT SIZE=5> chargement des cartes du programme
</FONT>
<LI><FONT SIZE=5> création du code intermédiaire (assemblage)
</FONT>
<LI><FONT SIZE=5> chargement des cartes de l'assembleur
</FONT>
<LI><FONT SIZE=5> création du code en langage machine
</FONT>
<LI><FONT SIZE=5> exécution du programme
</FONT></UL><FONT SIZE=5>
un problème&nbsp;: à chaque erreur réalisation d'un dump (listing de l'image mémoire) pour le programmeur, qui n'est pas sur place pour réaliser une correction à chaud (pas de périphériques interactifs trop coûteux).<BR>
<BR>

</FONT><FONT SIZE=5><B>Solutions&nbsp;:</B></FONT><FONT SIZE=5>
</FONT><UL>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5> le </FONT><FONT SIZE=5><EM>traitement par lots</EM></FONT><FONT SIZE=5> (batch proccessing)</FONT><FONT SIZE=5>traitement par lots</FONT><FONT SIZE=5>
 pour regrouper et exécuter par groupes les travaux similaires 
</FONT>
<LI><FONT SIZE=5> le </FONT><FONT SIZE=5><EM>moniteur résident</EM></FONT><FONT SIZE=5><EM>moniteur résident</EM></FONT><FONT SIZE=5> qui enchaîne automatiquement les travaux, un nouveau type de cartes est introduit, qui donne des instructions à réaliser par le moniteur, (charger, exécuter, etc.).
</FONT></UL><FONT SIZE=5>Ce moniteur résidant est l'ancêtre des systèmes d'exploitation, (la mémoire qui est apparue avec les transistors est découpée en deux zones&nbsp;: moniteur, utilisateur). <BR>
<BR>
La différence de vitesse entre les E/S et l'unité centrale (UC) devient flagrante&nbsp;: les périphériques sont alors dotés de circuits autonomes leur permettant de faire certains traitements sans le secours de l'UC. Ces circuits sont parfois des ordinateurs plus petits (dont le coût du temps de calcul est plus faible).<BR>
<BR>

</FONT><!--TOC subsection <FONT SIZE=5>VLSI et Multiprogrammation 1965-80</FONT>-->

<H3><FONT SIZE=5>2.1.3&nbsp;&nbsp; VLSI et Multiprogrammation 1965-80</FONT></H3><!--SEC END -->
<FONT SIZE=5>Circuits intégrés </FONT><FONT SIZE=5><FONT FACE=symbol>¾®</FONT></FONT><FONT SIZE=5> moindre coût de fabrication<BR>                   </FONT><FONT SIZE=5><FONT FACE=symbol>¾®</FONT></FONT><FONT SIZE=5> évolution rapide des modèles <BR>                   </FONT><FONT SIZE=5><FONT FACE=symbol>¾®</FONT></FONT><FONT SIZE=5> vente aux entreprises <BR>IBM lance l'idée d'un système unique adapté à plusieurs machines&nbsp;: OS/360. <BR>
<BR>

</FONT><FONT SIZE=5><EM>Arrivée des disques magnétiques.</EM></FONT><FONT SIZE=5> Apparait le principe de multiprogrammation, les entrées-sorties sur disque étant effectuées de façon asynchrone avec des calculs sur l'unité centrale (parallèlisation).<BR>
<BR>

</FONT><FONT SIZE=5><B>Multiprogrammation</B></FONT><FONT SIZE=5>&nbsp;: plusieurs programmes sont en même temps en mémoire et sur le disque, si le programme en cours d'exécution demande une opération d'entrée-sortie alors un autre programme est exécuté pendant que se déroule l'opération. 

</FONT><!--TOC subsection <FONT SIZE=5>UNIX</FONT>-->

<H3><FONT SIZE=5>2.1.4&nbsp;&nbsp; UNIX</FONT></H3><!--SEC END -->
<FONT SIZE=5>
</FONT><UL>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5>1969</FONT><FONT SIZE=5> Ken Thompson, Dennis Ritchie
</FONT>
<LI><FONT SIZE=5>1971</FONT><FONT SIZE=5> + Brian Kernighan 
</FONT>
<LI><FONT SIZE=5>1973</FONT><FONT SIZE=5> C 
</FONT>
<LI><FONT SIZE=5>1984</FONT><FONT SIZE=5> 100000 cpu /UNIX
</FONT>
<LI><FONT SIZE=5>1993</FONT><FONT SIZE=5> UNIX est le système de référence
</FONT></UL><FONT SIZE=5>
</FONT><TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=5>
Avec de nombreux</FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>standards</FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>AES, SVID2, XPG2, XPG3, XPG4, POSIX.1 OSF</FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>et des innovations comme&nbsp;:</FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>les micro-noyaux, MACH, CHORUS, MASIX</FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>Des copies &nbsp;: Windows NT par exemple ...</FONT></TD>
</TR></TABLE><FONT SIZE=5>
Le succès d'UNIX sans doute parce que&nbsp;:
</FONT><UL>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5> Ecrit dans un langage de haut niveau&nbsp;: C (C++, Objective C)&nbsp;;
</FONT>
<LI><FONT SIZE=5> une interface simple et puissante &nbsp;: les shells,
 qui fournissent des services de haut niveau&nbsp;;
</FONT>
<LI><FONT SIZE=5> Des primitives puissantes qui permettent de simplifier l'écriture des programmes&nbsp;;
</FONT>
<LI><FONT SIZE=5> Un système de fichier hiérarchique qui permet une maintenance simple
et une implémentation efficace&nbsp;;
</FONT>
<LI><FONT SIZE=5> Un format générique pour les fichiers, le flot d'octets
 qui simplifie l'écriture des programmes&nbsp;;
</FONT>
<LI><FONT SIZE=5> Il fournit une interface simple aux périphériques&nbsp;;
</FONT>
<LI><FONT SIZE=5> Il est multi-utilisateurs et multi-tâches&nbsp;;
</FONT>
<LI><FONT SIZE=5> Il cache complètement l'architecture de la machine à l'utilisateur.
</FONT></UL><FONT SIZE=5>

</FONT><!--TOC subsection <FONT SIZE=5>Des points forts </FONT>-->

<H3><FONT SIZE=5>2.1.5&nbsp;&nbsp; Des points forts </FONT></H3><!--SEC END -->
<FONT SIZE=5>
</FONT><UL>
<LI><FONT SIZE=5> Système né dans le monde de la recherche 
 intégration de concepts avancés
</FONT>
<LI><FONT SIZE=5> Diffusion ouverte 
 accès aux sources
</FONT>
<LI><FONT SIZE=5> Langage (de haut niveau )
 compilation séparée, conditionnelle, paramétrage, précompilation 
</FONT>
<LI><FONT SIZE=5> Enrichissement constant
</FONT>
<LI><FONT SIZE=5> Ouverture (paramétrabilité du poste de travail)
</FONT>
<LI><FONT SIZE=5> Souplesse des entrées/sorties
 uniformité
</FONT>
<LI><FONT SIZE=5> Facilités de communication inter-systèmes
</FONT>
<LI><FONT SIZE=5> Communautés d'utilisateurs (/etc/groups)
</FONT>
<LI><FONT SIZE=5> Langages de commandes (flexibles et puissants)
</FONT>
<LI><FONT SIZE=5> Aspect multi-utilisateurs
 connections de tout type de terminal, bibliothèques, etc
</FONT>
<LI><FONT SIZE=5> Parallélisme
 multi-tâches &nbsp;: "scheduling" par tâche
 communication entre tâches
 multiprocesseurs
</FONT>
<LI><FONT SIZE=5> Interface système/applications
 appels système, bibliothèque
</FONT>
<LI><FONT SIZE=5> le système de gestion de fichiers
 hiérarchie 
</FONT>
<LI><FONT SIZE=5> Interfaces graphiques normées&nbsp;: X11.
</FONT></UL><FONT SIZE=5>
</FONT><!--TOC subsection <FONT SIZE=5>Des points faibles</FONT>-->

<H3><FONT SIZE=5>2.1.6&nbsp;&nbsp; Des points faibles</FONT></H3><!--SEC END -->
<FONT SIZE=5>
</FONT><UL>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5> Sécurité (pire encore en réseau )
 Amélioration avec les A.C.L.
</FONT>
<LI><FONT SIZE=5> Fragilité du S.G.F.
 pertes de fichiers possible en cas de crash 
</FONT>
<LI><FONT SIZE=5> Gestion et rattrapage des interruptions
 pas de temps réel (Q.N.X.).
</FONT>
<LI><FONT SIZE=5> Mécanisme de création de processus lourd
 Amélioration avec les threads.
</FONT>
<LI><FONT SIZE=5> Une édition de liens statique 
 Amélioration avec les librairies partagées.
</FONT>
<LI><FONT SIZE=5> Rattrapage d'erreur du compilateur C standard peu aisé !
</FONT>
<LI><FONT SIZE=5> Coût en ressources
</FONT>
<LI><FONT SIZE=5> Gestion </FONT><FONT SIZE=5><FONT FACE=symbol>¾®</FONT></FONT><FONT SIZE=5> verrous sur fichiers</FONT></UL><FONT SIZE=5>
</FONT><!--TOC section <FONT SIZE=5>Structure générale des systèmes d'exploitation</FONT>-->

<H2><FONT SIZE=5>2.2&nbsp;&nbsp; Structure générale des systèmes d'exploitation</FONT></H2><!--SEC END -->
<FONT SIZE=5>
Un système d'exploitation est un programme qui sert d'interface entre un utilisateur et un ordinateur.
<BR><BR><BR>
<BR>
<BR>
Un système d'exploitation est un ensemble de procédures manuelles et automatiques qui permet à un groupe d'utilisateurs de partager efficacement un ordinateur.
 </FONT><FONT SIZE=5><EM>Brinch Hansen.</EM></FONT><FONT SIZE=5>
<BR><BR><BR>
<BR>
<BR>
Il est plus facile de définir un système d'exploitation par ce qu'il fait que par ce qu'il est.
 </FONT><FONT SIZE=5><EM>J.L. Peterson.</EM></FONT><FONT SIZE=5>
<BR><BR><BR>
<BR>
<BR>
Un système d'exploitation est un ensemble de procédures cohérentes qui a pour but de gérer la pénurie de ressources.
 </FONT><FONT SIZE=5><EM>J-l. Stehlé P. Hochard.</EM></FONT><FONT SIZE=5>
<BR><BR><BR><BR><BR><BR><BR>
<BR>
</FONT><FONT SIZE=5><B>Quelques systèmes</B></FONT><FONT SIZE=5>&nbsp;:
</FONT><DL COMPACT=compact>
<DT><FONT SIZE=5>
</FONT><FONT SIZE=5>le batch</FONT><DD><FONT SIZE=5> Le traitement par lot (disparus).
</FONT>
<DT><FONT SIZE=5>interactifs</FONT><DD><FONT SIZE=5> Pour les utilisateurs (ce cher UNIX).
</FONT>
<DT><FONT SIZE=5>temps réels</FONT><DD><FONT SIZE=5> Pour manipuler des situations physiques par des périphériques (OS9 un petit frère futé d'UNIX).
</FONT>
<DT><FONT SIZE=5>distribués</FONT><DD><FONT SIZE=5> UNIX?, les micros noyaux? l'avenir?
</FONT>
<DT><FONT SIZE=5>moniteurs transactionnels</FONT><DD><FONT SIZE=5> Ce sont des applications qui manipulent des objets à tâches multiples comme les comptes dans une banque, des réservations, etc 
</FONT>
<DT><FONT SIZE=5>SE orientés objets</FONT><DD><FONT SIZE=5> Micro Noyaux.
</FONT></DL><FONT SIZE=5>
</FONT><!--TOC subsection <FONT SIZE=5>Les couches fonctionnelles</FONT>-->

<H3><FONT SIZE=5>2.2.1&nbsp;&nbsp; Les couches fonctionnelles</FONT></H3><!--SEC END -->
<FONT SIZE=5>
</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML001.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 2.1&nbsp;: Vue générale du système</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="vue.general"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>
Couches fonctionnelles&nbsp;:
</FONT><UL>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5> Programmes utilisateurs 
</FONT>
<LI><FONT SIZE=5> Programmes d'application 
 </FONT><FONT SIZE=3>éditeurs/tableurs/BD/CAO </FONT><FONT SIZE=5>
</FONT>
<LI><FONT SIZE=5> Programmes système
 </FONT><FONT SIZE=3>assembleurs/compilateurs/éditeurs de liens/chargeurs </FONT><FONT SIZE=5>
</FONT>
<LI><FONT SIZE=5> système d'exploitation 
</FONT>
<LI><FONT SIZE=5> langage machine 
</FONT>
<LI><FONT SIZE=5> microprogramme
</FONT>
<LI><FONT SIZE=5> machines physiques 
</FONT></UL><FONT SIZE=5>
</FONT><!--TOC subsection <FONT SIZE=5>L'architecture du système </FONT>-->

<H3><FONT SIZE=5>2.2.2&nbsp;&nbsp; L'architecture du système </FONT></H3><!--SEC END -->
<FONT SIZE=5>

</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML002.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 2.2&nbsp;: Point de vue utilisateur</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="vue.utilisateur"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>
L'architecture globale d'UNIX est une architecture par couches
(coquilles) successsives comme le montre la figure
</FONT><A HREF="#vue.utilisateur"><FONT SIZE=5>2.2</FONT></A><FONT SIZE=5>. Les utilisateure communiquent avec la couche la
plus évoluée celle des applications. Le programmeur lui va
pouvoir en fonction de ces besoins utiliser des couches de plus en
plus profondes.<BR>Chaque couche est construite pour pouvoir être
utilisée sans connaitre les couches inférieures (ni leur
fonctionnement, ni leur interface). <BR>Cette hiérarchie
d'encapsulation permet d'écrire des applications plus portables si
elles sont écrites dans les couches hautes. Pour des applications
où le temps de calcul prime devant la portabilité, les couches
basses seront utilisées.<BR>
<BR>

<BR>
<BR>
</FONT><!--TOC subsection <FONT SIZE=5>L'architecture du noyau</FONT>-->

<H3><FONT SIZE=5>2.2.3&nbsp;&nbsp; L'architecture du noyau</FONT></H3><!--SEC END -->
<FONT SIZE=5>

</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML003.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 2.3&nbsp;: Architecture du noyau</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="architecture.noyau"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>
 L'autre approche architecturale est l'architecture interne du Noyau (kernel).</FONT><FONT SIZE=5>noyau</FONT><FONT SIZE=5>
C'est à dire l'architecture du programme qui va nous interfacer avec le
matériel. Le but ici est de simplifier la compréhension et la fabrication du
système. Nous cherchons donc ici à décomposer le noyau en parties disjointes
(qui sont concevables et programmables de façons disjointes). La Figure
</FONT><A HREF="#architecture.noyau"><FONT SIZE=5>2.3</FONT></A><FONT SIZE=5> donne une idée de ce que peut être l'architecture
interne d'un noyau UNIX. Noter bien la position extérieure des bibliothèques </FONT><FONT SIZE=5>bibliothèques</FONT><FONT SIZE=5>.<BR>
<BR>


</FONT><!--TOC chapter <FONT SIZE=5>Système de Gestion de Fichiers</FONT>-->

<H1><FONT SIZE=5>Chapitre&nbsp;3&nbsp;&nbsp; Système de Gestion de Fichiers</FONT></H1><!--SEC END -->
<FONT SIZE=5>Système de Gestion de Fichiers</FONT><FONT SIZE=5>
<BR>
<BR>
Le système de gestion de fichiers est un outil de manipulation des fichiers et de la structure d'arborescence des fichiers sur disque et a aussi le rôle sous UNIX de conserver toutes les informations dont la pérennité est importante pour le système. Ainsi tous les objets importants du système sont référencés dans le système de fichiers (mémoire, terminaux, périphériques variés, etc).<BR>Il permet de plus une utilisation facile des fichiers et gère de façon transparente les différents problèmes d'accès aux supports de masse (partage, débit, droits, etc).<BR>
</FONT><!--TOC section <FONT SIZE=5>Le concept de fichier</FONT>-->

<H2><FONT SIZE=5>3.1&nbsp;&nbsp; Le concept de fichier</FONT></H2><!--SEC END -->
<FONT SIZE=5>fichier</FONT><FONT SIZE=5>
L'unité logique de base du S.G.F. </FONT><FONT SIZE=5><B>le fichier</B></FONT><FONT SIZE=5>. <BR>Le contenu est entièrement défini par le créateur.<BR>Sur Unix les fichiers ne sont pas typés.<BR></FONT><FONT SIZE=5><B>Un fichier Unix est une suite finie de bytes (octets).<BR>
<BR>
 Matérialisé par une inode et des blocs du disque.</B></FONT><FONT SIZE=5><BR>L'inode définit le fichier, soit principalement les informations&nbsp;:
</FONT><UL>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5> le propriétaire et le groupe propriétaire, </FONT><FONT SIZE=5>propriétaire</FONT><FONT SIZE=5> </FONT><FONT SIZE=5>groupe</FONT><FONT SIZE=5>
</FONT>
<LI><FONT SIZE=5> les droits d'accès des différents utilisateurs,</FONT><FONT SIZE=5>droits</FONT><FONT SIZE=5>
</FONT>
<LI><FONT SIZE=5> la taille, 
</FONT>
<LI><FONT SIZE=5> la date de création,
</FONT>
<LI><FONT SIZE=5> la localisation sur disque.
</FONT></UL><FONT SIZE=5>
on trouvera sur d'autre systèmes d'autres structures d'information
pour décrire les fichiers.<BR>
<BR>
</FONT><FONT SIZE=5><EM>Un nom est lié à un fichier (une référence indique un fichier)
mais un fichier n'est pas lié à une référence, un fichier peut exister sans avoir de nom dans l'arborescence.</EM></FONT><FONT SIZE=5>référence</FONT><BR>
<BR>
<FONT SIZE=5>
</FONT><!--TOC section <FONT SIZE=5> Fichiers ordinaires / Fichiers spéciaux.</FONT>-->

<H2><FONT SIZE=5>3.2&nbsp;&nbsp;  Fichiers ordinaires / Fichiers spéciaux.</FONT></H2><!--SEC END -->
<FONT SIZE=5>
</FONT><FONT SIZE=5>fichier!ordinaires</FONT><FONT SIZE=5>fichier!spéciaux</FONT><FONT SIZE=5>
On a deux grands types de fichiers sous Unix &nbsp;:
</FONT><DL COMPACT=compact>
<DT><FONT SIZE=5>
</FONT><FONT SIZE=5>les fichiers standards</FONT><DD><FONT SIZE=5> que sont par exemple les fichiers texte, les exécutables, etc. C'est-à-dire tout ce qui est manipulé par les utilisateurs.</FONT><BR>
<BR>

<DT><FONT SIZE=5>Les fichiers spéciaux</FONT><DD><FONT SIZE=5> périphériques, mémoire etc,
 qui ne sont manipulables que par l'intermédiaire du système.
</FONT></DL><FONT SIZE=5>
</FONT><FONT SIZE=5><EM>Les catalogues</EM></FONT><FONT SIZE=5> sont des fichiers spéciaux, il faut en effet
pour les manipuler physiquement faire appel au système </FONT><A NAME="text1" HREF="#note1"><SUP><FONT SIZE=2>1</FONT></SUP></A><FONT SIZE=5>.<BR>Les fichiers physiques dans le répertoire /dev <BR></FONT><FONT SIZE=5>fichier!physiques</FONT><FONT SIZE=5>
</FONT><UL>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5> Character devices 
 les terminaux (claviers, écrans)
 les imprimantes
 etc
</FONT>
<LI><FONT SIZE=5> Block devices 
 la mémoire 
 les disques 
 les bandes magnétiques 
 etc 
</FONT></UL><FONT SIZE=5>

Les fichiers à usages logiques et non physiques <BR></FONT><UL>
<LI><FONT SIZE=5>
 </FONT><FONT SIZE=5> liens symboliques
 </FONT>
<LI><FONT SIZE=5> pseudo-terminaux
 </FONT>
<LI><FONT SIZE=5> sockets 
 </FONT>
<LI><FONT SIZE=5> tubes nommés 
 Ce dernier type de fichiers spéciaux est
 utilisé pour servir d'interface entre disques, entre
 machines et simuler&nbsp;: des terminaux, des lignes de communication, etc.
</FONT></UL><FONT SIZE=5>

</FONT><!--TOC subsection <FONT SIZE=5>Les catalogues (historique)</FONT>-->

<H3><FONT SIZE=5>3.2.1&nbsp;&nbsp; Les catalogues (historique)</FONT></H3><!--SEC END -->
<FONT SIZE=5>Les arborescences de fichiers et de catalogues, organisées comme un
graphe acyclique </FONT><A NAME="text2" HREF="#note2"><SUP><FONT SIZE=2>2</FONT></SUP></A><FONT SIZE=5>, apparaissent avec le projet MULTICS.
Cette organisation logique du disque a les avantages suivants&nbsp;:<BR>
</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML004.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 3.1&nbsp;: l'arborescence MULTICS</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="chapitre2.arbo1"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>

</FONT><BLOCKQUOTE><FONT SIZE=5>
Une racine, un accès absolu aisé.<BR>Une structure dynamique.<BR>Une grande puissance d'expression.<BR>Un graphe acyclique.<BR></FONT></BLOCKQUOTE><FONT SIZE=5>

L'organisation est arborescente avec quelques connections
supplémentaires (liens multiples sur un même fichier) qui en
font un graphe. Mais ce graphe doit rester acyclique, pour les raisons suivantes&nbsp;:<BR>L'ensemble des algorithmes simples utilisables sur des graphe acycliques comme le parcours, la vérification des fichiers libres, etc. deviennent beaucoup plus difficiles à écrire pour des graphes admettant des cycles.<BR>Des algorithmes de ramasse-miettes doivent être utilisés pour savoir si certains objets sont utilisés on non et pour récuperer les inodes ou blocs perdus après un crash.<BR>Tous les algorithmes de détection dans un graphe quelconque ont une complexité beaucoup plus grande que ceux qui peuvent profiter de l'acyclicité du graphe.<BR>Sous Unix nous sommes assurés que le graphe est acyclique car il est interdit d'avoir plusieurs références pour un même catalogue (sauf la référence spéciale "</FONT><FONT SIZE=5><TT>..</TT></FONT><FONT SIZE=5>" ).<BR></FONT><FONT SIZE=5><B>Sous UNIX c'est un graphe acyclique !</B></FONT><FONT SIZE=5>

<BR>
<BR>
</FONT><!--TOC section <FONT SIZE=5>Les inodes</FONT>-->

<H2><FONT SIZE=5>3.3&nbsp;&nbsp; Les inodes</FONT></H2><!--SEC END -->
<FONT SIZE=5>
</FONT><FONT SIZE=5>inodes</FONT><FONT SIZE=5>fichiers!inodes</FONT><FONT SIZE=5>
L'inode est le centre de tous les échanges entre le disque et la mémoire.
L'inode est la structure qui contient toutes les informations sur un fichier donné à l'exception de sa référence, dans l'arborescence.<BR>Les informations stockées dans une inode disque sont&nbsp;:
</FONT><UL>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5> utilisateur propriétaire </FONT><FONT SIZE=5>propriétaire</FONT><FONT SIZE=5>
</FONT>
<LI><FONT SIZE=5> groupe propriétaire</FONT><FONT SIZE=5>groupe</FONT><FONT SIZE=5>
</FONT>
<LI><FONT SIZE=5> type de fichier
</FONT>
<LI><FONT SIZE=5> droits d'accès
</FONT>
<LI><FONT SIZE=5> date de dernier accès
</FONT>
<LI><FONT SIZE=5> date de dernière modification
</FONT>
<LI><FONT SIZE=5> date de dernière modification de l'inode
</FONT>
<LI><FONT SIZE=5> taille du fichier
</FONT>
<LI><FONT SIZE=5> adresses des blocs-disque contenant le fichier.
</FONT></UL><FONT SIZE=5>
Dans une inode en mémoire (fichier en cours d'utilisation par un processus) on trouve d'autres informations supplémentaires&nbsp;:<BR>le statut de l'inode 
</FONT><BLOCKQUOTE><FONT SIZE=5> { locked,<BR>waiting P<BR>inode à écrire,<BR>fichier à écrire,<BR>le fichier est un point de montage<BR>}
</FONT></BLOCKQUOTE><FONT SIZE=5>
Et deux valeurs qui permettent de localiser l'inode sur un des disques logiques&nbsp;:
</FONT><BLOCKQUOTE><FONT SIZE=5>
 Numéro du disque logique<BR>Numéro de l'inode dans le disque
</FONT></BLOCKQUOTE><FONT SIZE=5>
cette information est inutile sur le disque (on a une bijection entre la position de l'inode sur disque et le numéro d'inode).<BR>On trouve aussi d'autres types d'informations comme l'accès à la
table des verrous ou bien des informations sur les disques à
distance dans les points de montage.

</FONT><!--TOC section <FONT SIZE=5>Organisation des disques System V</FONT>-->

<H2><FONT SIZE=5>3.4&nbsp;&nbsp; Organisation des disques System V</FONT></H2><!--SEC END -->
<FONT SIZE=5>
L'organisation disque décrite sur la figure </FONT><A HREF="#sdf.DisqueDur"><FONT SIZE=5>3.2</FONT></A><FONT SIZE=5> est la plus simple que l'on peut trouver de nos jours sous UNIX, il en existe d'autres (cf. section </FONT><A HREF="#ffs"><FONT SIZE=5>3.8</FONT></A><FONT SIZE=5>) où l'on peut en particulier placer un même disque logique sur plusieurs disques physiques (dangereux), certaines où les blocs sont fragmentables, etc.<BR>
</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML005.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 3.2&nbsp;: Organisation des blocs et des inodes (SYS V)</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="sdf.DisqueDur"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>

</FONT><DL COMPACT=compact>
<DT><FONT SIZE=5>
</FONT><FONT SIZE=5>Boot bloc</FONT><DD><FONT SIZE=5> utilisé au chargement du système.</FONT><FONT SIZE=5>boot bloc</FONT><FONT SIZE=5>
</FONT>
<DT><FONT SIZE=5>Super Bloc</FONT><DD><FONT SIZE=5> il contient toutes les informations générales sur le disque
 logique.</FONT><FONT SIZE=5>super bloc</FONT><FONT SIZE=5>
</FONT>
<DT><FONT SIZE=5>Inode list</FONT><DD><FONT SIZE=5> Table des inodes.
</FONT>
<DT><FONT SIZE=5>blocs</FONT><DD><FONT SIZE=5> les blocs de données chainés à la création du disque (</FONT><FONT SIZE=5><TT>mkfs</TT></FONT><FONT SIZE=5>).
</FONT></DL><FONT SIZE=5>
Les blocs de données ne sont pas fragmentables sous Système V.

</FONT><!--TOC section <FONT SIZE=5>Adressage des blocs dans les inodes</FONT>-->

<H2><FONT SIZE=5>3.5&nbsp;&nbsp; Adressage des blocs dans les inodes</FONT></H2><!--SEC END -->
<FONT SIZE=5>
Le système d'adressage des blocs dans les inodes (système V) consiste en 13 adresses de blocs. Les dix premières adresses sont des adresses qui pointent directement sur les blocs de données du fichier. Les autres sont des adresses indirectes vers des blocs de données contenant des adresses. La figure </FONT><A HREF="#inodes"><FONT SIZE=5>3.3</FONT></A><FONT SIZE=5> nous montre les trois niveaux d'indirection. L'intérêt de cette représentation est d'économiser sur la taille des inodes tout en permettant un accès rapide au petits fichiers (la majorité des fichiers sont petits). Mais en laissant la possibilité de créer de très gros fichiers&nbsp;:<BR></FONT><DIV ALIGN=center><FONT SIZE=5>10+256+(256 × 256 )+( 256 × 256 × 256)</FONT></DIV><FONT SIZE=5>
blocs disques.

</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML006.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 3.3&nbsp;: Adressage direct et indirect des inode UNIX</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="inodes"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>
</FONT><FONT SIZE=5>inodes</FONT><FONT SIZE=5>

</FONT><!--TOC section <FONT SIZE=5>Allocation des inodes d'un disque</FONT>-->

<H2><FONT SIZE=5>3.6&nbsp;&nbsp; Allocation des inodes d'un disque</FONT></H2><!--SEC END -->
<FONT SIZE=5>
</FONT><FONT SIZE=5>inodes</FONT><FONT SIZE=5>
 L'allocation des inodes est réalisée en recherchant dans la zone des inodes du disque une inode libre. Pour accélérer cette recherche : un tampon d'inodes libres est géré dans le SuperBloc, de plus l'indice de la première inode libre est gardé en référence dans le SuperBloc afin de redémarrer la recherche qu'à partir de la première inode réellement libre. <BR>
<BR>

</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML007.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 3.4&nbsp;: Inodes libres dans le SuperBloc.</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="ialloc1"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>


</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML008.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 3.5&nbsp;: Allocation d'une inode.</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="ialloc2"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>


</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML009.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 3.6&nbsp;: Si le SuperBloc est vide. </FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="ialloc3"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>


</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML010.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 3.7&nbsp;: Libération d'une inode avec le SuperBloc plein.</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="ialloc4"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>


</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML011.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 3.8&nbsp;: Le numéro d'inode inférieur au numéro de référence.</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="ialloc5"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>


</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML012.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 3.9&nbsp;: Le numéro d'inode supérieur au numéro de référence.</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="ialloc6"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>


</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML013.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 3.10&nbsp;: Faille de l'algorithme d'allocation.</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="faille"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>
Mais ce système a une faille qu'il faut prévoir dans l'écriture dans l'algorithme ialloc d'allocation d'inode, cette faille est décrite dans la Figure&nbsp;</FONT><A HREF="#faille"><FONT SIZE=5>3.10</FONT></A><FONT SIZE=5>

</FONT><!--TOC section <FONT SIZE=5>Allocation des blocs-disque</FONT>-->

<H2><FONT SIZE=5>3.7&nbsp;&nbsp; Allocation des blocs-disque</FONT></H2><!--SEC END -->
<FONT SIZE=5>
 L'algorithme utilisé pour gérer l'allocation des inodes s'appuie sur le fait que l'on peut tester si une inode est libre ou non en regardant son contenu. Ceci n'est plus vrai pour les blocs. La solution est de chaîner les blocs. Ce chaînage est réalisé par blocs d'adresses pour accélérer les accès et profiter au maximum du buffer cache. Il existe donc un bloc d'adresses dans le super bloc qui sert de zone de travail pour l'allocateur de blocs. L'utilisation de ce bloc et le mécanisme d'allocation sont décrits dans les Figures </FONT><A HREF="#balloc1"><FONT SIZE=5>3.11</FONT></A><FONT SIZE=5> à </FONT><A HREF="#balloc6"><FONT SIZE=5>3.16</FONT></A><BR>
<BR>
<FONT SIZE=5>
</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML014.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 3.11&nbsp;: Liste chainée de blocs.</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="balloc1"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>


</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML015.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 3.12&nbsp;: Etat initial du SuperBloc.</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="balloc2"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>


</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML016.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 3.13&nbsp;: Libération du bloc 978.</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="balloc3"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>


</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML017.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 3.14&nbsp;: Allocation du bloc 978.</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="balloc4"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>


</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML018.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 3.15&nbsp;: Allocation du bloc 109.</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="balloc5"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>


</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML019.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 3.16&nbsp;: Libération du bloc 612.</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="balloc6"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>

</FONT><!--TOC section <FONT SIZE=5>Les systèmes de fichiers ffs/ufs de BSD</FONT>-->

<H2><FONT SIZE=5>3.8&nbsp;&nbsp; Les systèmes de fichiers ffs/ufs de BSD</FONT></H2><!--SEC END -->
<A NAME="ffs"></A><FONT SIZE=5>
</FONT><FONT SIZE=5>ffs</FONT><FONT SIZE=5>
Les disques sous BSD sont organisés par groupes de cylindres et chacun de ces groupes a la même organisation que les disques logiques System V, avec en plus une table de groupes de cylindres qui permet d'organiser l'allocation des blocs de façon à réduire le déplacement des têtes de lecture (ce qui augmente le débit).<BR>
<BR>
Quelques différences :<BR>
<BR>
Les blocs de données sont plus grands (4K ou 8K) mais fragmentables.<BR>
<BR>
Une inode contient 12 adresses directes, une adresse indirecte et 2 adresses indirectes doubles.<BR>
<BR>
Enfin, les répertoires sont composés d'enregistrements de tailles variables (le nom des liens est en effet limité à 14 en System V, et à 255 en BSD, c.f. entrées-sorties sur répertoires), la norme POSIX fixe la taille maximum des liens à 255 (MAXNAMLEN).<BR>
<BR>

</FONT><!--BEGIN NOTES chapter-->
<HR WIDTH="50%" SIZE=1><DL>
<DT><A NAME="note1" HREF="#text1"><FONT SIZE=5><FONT SIZE=5>1</FONT></FONT></A><DD><FONT SIZE=5> 
les répertoires restent accessibles en lecture comme des fichiers
ordinaires (essayez de faire <TT>cat "."</TT>), mais l'accès en écriture est
contraint, pour assurer la structure arborescente.
</FONT>
<DT><A NAME="note2" HREF="#text2"><FONT SIZE=5><FONT SIZE=5>2</FONT></FONT></A><DD><FONT SIZE=5> Ce n'est pas un arbre car un fichier peut
avoir plusieurs références
</FONT></DL>
<!--END NOTES-->
<!--TOC chapter <FONT SIZE=5>Le Buffer Cache</FONT>-->

<H1><FONT SIZE=5>Chapitre&nbsp;4&nbsp;&nbsp; Le Buffer Cache</FONT></H1><!--SEC END -->
<FONT SIZE=5>
</FONT><!--TOC section <FONT SIZE=5>Introduction au buffer cache</FONT>-->

<H2><FONT SIZE=5>4.1&nbsp;&nbsp; Introduction au buffer cache</FONT></H2><!--SEC END -->
<FONT SIZE=5>
</FONT><FONT SIZE=5>buffer cache</FONT><FONT SIZE=5>
Le buffer cache est un ensemble de structures de données et d'algorithmes qui permettent de minimiser le nombre des accès disque.<BR>Ce qui est très important car les disques sont très lents relativement au CPU et un noyau qui se chargerait de toutes les entrées/sorties serait d'une grande lenteur et l'unité de traitement ne serait effectivement utilisée qu'à un faible pourcentage (voir Historique). <BR>Deux idées pour réduire le nombre des accès disques&nbsp;:
 </FONT><OL type=1>
<LI><FONT SIZE=5>
 </FONT><FONT SIZE=5> bufferiser les différentes commandes d'écriture et de lecture de façon à faire un accès disque uniquement pour une quantité de données de taille raisonnable (un bloc disque).</FONT><FONT SIZE=5>bufferiser</FONT><BR>
<BR>
<FONT SIZE=5> </FONT>
<LI><FONT SIZE=5> Eviter des écritures inutiles quand les données peuvent encore être changées (écriture différées).<BR>
<BR>
 </FONT></OL><!--TOC subsection <FONT SIZE=5>Avantages et désavantages du buffer cache</FONT>-->

<H3><FONT SIZE=5>4.1.1&nbsp;&nbsp; Avantages et désavantages du buffer cache</FONT></H3><!--SEC END -->
<FONT SIZE=5>
</FONT><UL>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5> Un accès uniforme au disque.
Le noyau n'a pas à connaître la raison de l'entrée-sortie. Il copie les données depuis et vers des tampons (que ce soient des données, des inodes ou le superbloc). Ce mécanisme est modulaire et s'intègre facilement à l'ensemble du système qu'il rend plus facile à écrire.</FONT><BR>
<BR>

<LI><FONT SIZE=5> Rend l'utilisation des entrées-sorties plus simple pour l'utilisateur qui n'a pas à se soucier des problèmes d'alignement, il rend les programmes portables sur d'autres UNIX </FONT><A NAME="text3" HREF="#note3"><SUP><FONT SIZE=2>1</FONT></SUP></A><FONT SIZE=5>.</FONT><BR>
<BR>

<LI><FONT SIZE=5> Il réduit le trafic disque et de ce fait augmente la capacité du système.
 Attention&nbsp;: le nombre de tampons ne doit pas trop réduire la mémoire centrale utilisable.</FONT><BR>
<BR>

<LI><FONT SIZE=5> L'implémentation du buffer cache protège contre certaines écritures "concurrentes" </FONT><BR>
<BR>

<LI><FONT SIZE=5> L'écriture différée pose un problème dans le cas d'un crash du système. En effet si votre machine s'arrête (coupure de courant) et que un (ou plusieurs) blocs sont marqués "à écrire" ils n'ont donc pas étés sauvegardés physiquement. L'intégrité des données n'est donc pas assurée en cas de crash.</FONT><BR>
<BR>

<LI><FONT SIZE=5> Le buffer cache nécessite que l'on effectue une recopie (interne à la mémoire, de la zone utilisateur au cache ou inversement) pour toute entrée-sortie. Dans le cas de transferts nombreux ceci ralentit les entrées-sorties .
</FONT></UL><FONT SIZE=5>

</FONT><!--TOC section <FONT SIZE=5>Le buffer cache, structures de données.</FONT>-->

<H2><FONT SIZE=5>4.2&nbsp;&nbsp; Le buffer cache, structures de données.</FONT></H2><!--SEC END -->
<FONT SIZE=5>

</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML020.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 4.1&nbsp;: Structure des entêtes de Bloc du Buffer Cache</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="buffercache.header"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>

Le statut d'un bloc cache est une combinaison des états suivants&nbsp;:
</FONT><DL COMPACT=compact>
<DT><FONT SIZE=5>
</FONT><FONT SIZE=5>verrouillé</FONT><DD><FONT SIZE=5> l'accès est reservé à un processus.
</FONT>
<DT><FONT SIZE=5>valide</FONT><DD><FONT SIZE=5> (les données contenues dans le bloc sont valides).
</FONT>
<DT><FONT SIZE=5>"à écrire"</FONT><DD><FONT SIZE=5> les données du bloc doivent être écrites sur disque avant de réallouer le bloc ( c'est de l'écriture retardée).
</FONT>
<DT><FONT SIZE=5>actif</FONT><DD><FONT SIZE=5> le noyau est en train d'écrire/lire le bloc sur le disque.
</FONT>
<DT><FONT SIZE=5>attendu</FONT><DD><FONT SIZE=5> un processus attend la libération du bloc.
</FONT></DL><FONT SIZE=5>

</FONT><!--TOC subsection <FONT SIZE=5>La liste doublement chaînée des blocs libres</FONT>-->

<H3><FONT SIZE=5>4.2.1&nbsp;&nbsp; La liste doublement chaînée des blocs libres</FONT></H3><!--SEC END -->
<FONT SIZE=5>
Les tampons libres appartiennent simultanément à deux listes doublement chaînées&nbsp;: la liste des blocs libres et la hash-liste correspondant au dernier bloc ayant été contenu dans ce tampon.


</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML021.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 4.2&nbsp;: La liste des tampons libres.</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="buffercache.listes"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>

L'insertion dans la liste des tampons libres se fait en fin de liste,
la suppression (allocation du tampon à un bloc donné) se fait en
début de liste, ainsi le tampon alloué est le plus vieux
tampon libéré</FONT><A NAME="text4" HREF="#note4"><SUP><FONT SIZE=2>2</FONT></SUP></A><FONT SIZE=5>.
Ceci permet une réponse immédiate si le bloc correspondant est réutilisé avant que le tampon ne soit alloué à un autre bloc.<BR>
<BR>

</FONT><!--TOC section <FONT SIZE=5>L'algorithme de la primitive </FONT><FONT SIZE=5><TT>getblk</TT></FONT>-->

<H2><FONT SIZE=5>4.3&nbsp;&nbsp; L'algorithme de la primitive </FONT><FONT SIZE=5><TT>getblk</TT></FONT></H2><!--SEC END -->
<FONT SIZE=5>
</FONT><FONT SIZE=5>
</FONT><PRE><FONT SIZE=5>
Algorithme getblk (allocation d'un tampon)
entree : # disque logique , # de block
sortie : un tampon verrouille utilisable pour manipuler bloc
{
    while (tampon non trouve)
    {
        if (tampon dans sa hash liste)
        {
                if (tampon actif )  
                { 
       [5]          sleep attente de la liberation du tampon
                    continuer
                }
       [1]      verrouiller le tampon      
                retirer le tampon de la liste des tampons libres
                retourner le tampon
        }
        else  /* n'est pas dans la hash liste */
        {
                if (aucun tampon libre ) 
                {
        [4]         sleep attente de la liberation d'un tampon 
                    continuer
                }
                retirer le tampon de la liste libre
        [3]     if (le tampon est a ecrire)  
                {
                    lancer la sauvegarde sur disque
                    continuer
                }
        [2]     retirer le buffer de son ancienne liste 
                 de hashage, le placer sur la nouvelle
                retourner le tampon
        }
    }
}
</FONT></PRE><FONT SIZE=5>


</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML022.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 4.3&nbsp;: Etat du buffer cache avant les scénarios 1, 2 et 3.</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="getblk1"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>




</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML023.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 4.4&nbsp;: Scénario 1- Demande d'un tampon pour le bloc-disque 4.</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="getblk1b"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>




</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML024.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 4.5&nbsp;: Scénario 2- Demande d'un tampon pour le bloc-disque 41.</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="getblk2b"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>




</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML025.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 4.6&nbsp;: Scénario 3- Demande pour le bloc 18 (3 &amp; 5 marqués à écrire).</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="getblk3b"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>




</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML026.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 4.7&nbsp;: Scénario 4- Plus de blocs libres.</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="getblk4"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>




</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML027.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 4.8&nbsp;: Scénario 5- Demande pour le bloc 17 qui est déjà utilisé.</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="getblk5"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>


</FONT><!--BEGIN NOTES chapter-->
<HR WIDTH="50%" SIZE=1><DL>
<DT><A NAME="note3" HREF="#text3"><FONT SIZE=5><FONT SIZE=5>1</FONT></FONT></A><DD><FONT SIZE=5> Les problèmes d'alignement existent toujours quand on transfère des données, cf. protocoles XDR,RPC
</FONT>
<DT><A NAME="note4" HREF="#text4"><FONT SIZE=5><FONT SIZE=5>2</FONT></FONT></A><DD><FONT SIZE=5> ordre fifo&nbsp;: first in first out
</FONT></DL>
<!--END NOTES-->
<!--TOC chapter <FONT SIZE=5>La bibliothèque standard</FONT>-->

<H1><FONT SIZE=5>Chapitre&nbsp;5&nbsp;&nbsp; La bibliothèque standard</FONT></H1><!--SEC END -->
<FONT SIZE=5>
</FONT><!--TOC section <FONT SIZE=5>Les descripteurs de fichiers.</FONT>-->

<H2><FONT SIZE=5>5.1&nbsp;&nbsp; Les descripteurs de fichiers.</FONT></H2><!--SEC END -->
<FONT SIZE=5>Le fichier d'inclusion </FONT><CODE><FONT SIZE=5><TT>&lt;stdio.h&gt;</TT></FONT></CODE><FONT SIZE=5> contient la définition du type
</FONT><FONT SIZE=5><TT>FILE</TT></FONT><FONT SIZE=5>. 
</FONT><FONT SIZE=5>stdio.h@</FONT><FONT SIZE=5><TT>stdio.h</TT></FONT><FONT SIZE=5>

Ce type est une structure contenant les informations nécessaires au système pour la manipulation d'un fichier ouvert. Le contenu exact de cette structure peut varier d'un système à l'autre (UNIX, VMS, autre).<BR>
<BR>
Toutes les fonctions d'E/S utilisent en premier argument un pointeur sur une
telle structure&nbsp;: </FONT><FONT SIZE=5><TT>FILE *</TT></FONT><FONT SIZE=5>. </FONT><FONT SIZE=5>FILE@</FONT><FONT SIZE=5><TT>FILE</TT></FONT><FONT SIZE=5>
Le rôle de cet argument est d'indiquer le fichier sur lequel on doit effectuer l'opération d'écriture ou de lecture.<BR>
<BR>
Pour pouvoir utiliser une fonction d'entrée-sortie il faut donc avoir une valeur pour ce premier argument, c'est le rôle de la fonction </FONT><FONT SIZE=5><TT>fopen</TT></FONT><FONT SIZE=5> de nous fournir ce pointeur en "ouvrant" le fichier.
</FONT><FONT SIZE=5>stdlib!printf@</FONT><FONT SIZE=5><TT>printf</TT></FONT><FONT SIZE=5> </FONT><FONT SIZE=5>stdlib!scanf@</FONT><FONT SIZE=5><TT>scanf</TT></FONT><FONT SIZE=5>
Les deux fonctions </FONT><FONT SIZE=5><TT>printf</TT></FONT><FONT SIZE=5> et </FONT><FONT SIZE=5><TT>scanf</TT></FONT><FONT SIZE=5> sont des synonymes de <BR></FONT><DIV ALIGN=center><FONT SIZE=5><TT>fprintf(stdout, format, ...)</TT></FONT></DIV><FONT SIZE=5><BR>et<BR></FONT><DIV ALIGN=center><FONT SIZE=5><TT>fscanf(stdin, format, ...)</TT></FONT></DIV><FONT SIZE=5><BR>où </FONT><FONT SIZE=5><TT>stdout</TT></FONT><FONT SIZE=5> et </FONT><FONT SIZE=5><TT>stdin</TT></FONT><FONT SIZE=5> sont des expressions de type </FONT><FONT SIZE=5><TT>FILE *</TT></FONT><FONT SIZE=5> définies sous forme de macro-définitions dans le fichier
</FONT><CODE><FONT SIZE=5><TT>&lt;stdio.h&gt;</TT></FONT></CODE><BR>
<BR>
<FONT SIZE=5>. Avec POSIX ce sont effectivement des fonctions.<BR>
<BR>
Sous UNIX les fichiers ouverts par un processus le restent dans ses fils. Par exemple le shell a en général trois fichiers ouverts&nbsp;:
</FONT><DL COMPACT=compact>
<DT><FONT SIZE=5>
</FONT><FONT SIZE=5><TT>stdin</TT></FONT><DD><FONT SIZE=5> le terminal ouvert en lecture.
</FONT><FONT SIZE=5>stdlib!stdin@</FONT><FONT SIZE=5><TT>stdin</TT></FONT><FONT SIZE=5>

</FONT>
<DT><FONT SIZE=5><TT>stdout</TT></FONT><DD><FONT SIZE=5> le terminal ouvert en écriture.
</FONT><FONT SIZE=5>stdlib!stdout@</FONT><FONT SIZE=5><TT>stdout</TT></FONT><FONT SIZE=5>

</FONT>
<DT><FONT SIZE=5><TT>stderr</TT></FONT><DD><FONT SIZE=5> le terminal ouvert en écriture, et en mode non bufferisé.
</FONT><FONT SIZE=5>stdlib!stderr@</FONT><FONT SIZE=5><TT>stderr</TT></FONT><FONT SIZE=5>

</FONT></DL><FONT SIZE=5>
ainsi si l'exécution d'un programme C est réalisée à partir du shell le programme C a déjà ces trois descripteurs de fichiers utilisables. 

C'est pourquoi il est en général possible d'utiliser </FONT><FONT SIZE=5><TT>printf</TT></FONT><FONT SIZE=5> et </FONT><FONT SIZE=5><TT>scanf</TT></FONT><FONT SIZE=5> sans ouvrir préalablement de fichiers.
Mais si l'entrée standard n'est pas ouverte, </FONT><FONT SIZE=5><TT>scanf</TT></FONT><FONT SIZE=5> échoue&nbsp;:
</FONT><PRE><FONT SIZE=5><TT><B>
#include &lt;stdio.h&gt;
main()
{
    int i;

    if (scanf("%d", &amp;i) == EOF)
    {
        printf("l\'entree standard est fermee\n");
    }
    else
    {
        printf("l\'entree standard est ouverte\n");
    }
}
</B></TT></FONT></PRE><FONT SIZE=5>
Compilé,(</FONT><FONT SIZE=5><TT>a.out</TT></FONT><FONT SIZE=5>), cela donne les deux sorties suivantes&nbsp;:
</FONT><PRE><FONT SIZE=5><TT><B>
$ a.out 
l'entree standard est ouverte
$ a.out &lt;&amp;- # fermeture de l'entree standard en ksh
l'entree standard est fermee
</B></TT></FONT></PRE><FONT SIZE=5>
De même </FONT><FONT SIZE=5><TT>printf</TT></FONT><FONT SIZE=5> échoue si la sortie standard est fermée.

</FONT><!--TOC subsection <FONT SIZE=5>Ouverture d'un fichier</FONT>-->

<H3><FONT SIZE=5>5.1.1&nbsp;&nbsp; Ouverture d'un fichier</FONT></H3><!--SEC END -->
<FONT SIZE=5>
La fonction de la bibliothèque standard </FONT><FONT SIZE=5><TT>fopen</TT></FONT><FONT SIZE=5> permet d'ouvrir un fichier ou de le créer.
</FONT><PRE><FONT SIZE=5><TT><B>
#include &lt;stdio.h&gt;
FILE  *fopen(const char *filename,
             const char *type);
</B></TT></FONT></PRE><FONT SIZE=5>
</FONT><FONT SIZE=5>stdlib!fopen@</FONT><FONT SIZE=5><TT>fopen</TT></FONT><FONT SIZE=5>

</FONT><FONT SIZE=5><TT><B>filename</B></TT></FONT><FONT SIZE=5> est une référence absolue ou relative du fichier à ouvrir; si le fichier n'existe pas alors il est créé </FONT><FONT SIZE=5><I><FONT COLOR=maroon>si et seulement si</FONT></I></FONT><FONT SIZE=5> l'utilisateur du processus a l'autorisation d'écrire dans le répertoire.<BR></FONT><FONT SIZE=5><TT><B>type</B></TT></FONT><FONT SIZE=5> est une des chaînes suivantes&nbsp;:
</FONT><DL COMPACT=compact>
<DT><FONT SIZE=5>
</FONT><FONT SIZE=5>"r"</FONT><DD><FONT SIZE=5> ouverture en lecture au début du fichier
</FONT>
<DT><FONT SIZE=5>"w"</FONT><DD><FONT SIZE=5> ouverture en écriture au début du fichier avec écrasement du fichier si il existe (le fichier est vidé de son contenu à l'ouverture).
</FONT>
<DT><FONT SIZE=5>"a"</FONT><DD><FONT SIZE=5> ouverture en écriture à la fin du fichier (mode append).
</FONT>
<DT><FONT SIZE=5>"r+","w+","a+"</FONT><DD><FONT SIZE=5> ouverture en lecture écriture respectivement au début du fichier, au début du fichier avec écrasement, à la fin du fichier.
</FONT></DL><PRE><FONT SIZE=5><TT><B>
FILE *f;
...
if ((f = fopen("toto", "r")) == NULL)
{
    fprintf(stderr, "impossible d'ouvrir toto\n");
    exit(1);
}
...
</B></TT></FONT></PRE><FONT SIZE=5>La fonction retourne un pointeur sur un descripteur du fichier ouvert ou </FONT><FONT SIZE=5><TT>NULL</TT></FONT><FONT SIZE=5> en cas d'échec, (accès interdit, création impossible, etc).<BR>
<BR>

</FONT><!--TOC subsection <FONT SIZE=5>Redirection d'un descripteur&nbsp;: </FONT><FONT SIZE=5><TT>freopen </TT></FONT>-->

<H3><FONT SIZE=5>5.1.2&nbsp;&nbsp; Redirection d'un descripteur&nbsp;: </FONT><FONT SIZE=5><TT>freopen </TT></FONT></H3><!--SEC END -->
<FONT SIZE=5>redirection</FONT><FONT SIZE=5>
</FONT><FONT SIZE=5>stdlib!freopen@</FONT><FONT SIZE=5><TT>freopen</TT></FONT><FONT SIZE=5>

Permet d'associer un descripteur déjà utilisé à une autre ouverture de fichier. Ceci permet de réaliser facilement les redirections du shell. 
</FONT><PRE><FONT SIZE=5><TT><B>
FILE *freopen(const char *ref,
              const char *mode,
              FILE *f)
</B></TT></FONT></PRE><FONT SIZE=5>
Par exemple les redirections de la ligne shell&nbsp;:
</FONT><PRE><FONT SIZE=5>
com &lt;ref1 &gt;&gt;ref2
</FONT></PRE><FONT SIZE=5>peuvent être réalisées avec 
</FONT><PRE><FONT SIZE=5>
if (!freopen("ref1", "r", stdin) || !freopen("ref2", "a", stdout))
{
    fprintf(stderr, "erreur sur une redirection\n");
    exit(1);
}
execl("./com", "com", NULL);
</FONT></PRE><!--TOC subsection <FONT SIZE=5>Création de fichiers temporaires</FONT>-->

<H3><FONT SIZE=5>5.1.3&nbsp;&nbsp; Création de fichiers temporaires</FONT></H3><!--SEC END -->
<FONT SIZE=5>
La fonction 
</FONT><FONT SIZE=5>stdlib!tmpfile@</FONT><FONT SIZE=5><TT>tmpfile</TT></FONT><FONT SIZE=5>

</FONT><PRE><FONT SIZE=5><TT><B>
#include &lt;stdio.h&gt;
FILE *tmpfile(void);
</B></TT></FONT></PRE><FONT SIZE=5>
crée et ouvre en écriture un nouveau fichier temporaire, qui sera détruit (un </FONT><FONT SIZE=5><TT>unlink</TT></FONT><FONT SIZE=5> est réalisé immédiatement) à la fin de l'exécution du processus, attention le descripteur est hérité par les fils. Cette fonction utilise la fonction 
</FONT><PRE><FONT SIZE=5><TT><B>
char *tmpnam(char *ptr);
</B></TT></FONT></PRE><FONT SIZE=5>
</FONT><FONT SIZE=5>stdlib!tmpnam@</FONT><FONT SIZE=5><TT>tmpnam</TT></FONT><FONT SIZE=5>

Cette fonction génère un nouveau nom de fichier et place celui-ci dans la zone pointée par ptr si ptr </FONT><FONT SIZE=5><FONT FACE=symbol>¹</FONT></FONT><FONT SIZE=5> NULL, la zone réservée doit être d'au moins </FONT><FONT SIZE=5><TT>L_tmpnam</TT></FONT><FONT SIZE=5> octets. Si ptr = </FONT><FONT SIZE=5><TT>NULL</TT></FONT><FONT SIZE=5> une zone statique est utilisée.

</FONT><!--TOC subsection <FONT SIZE=5>Ecriture non formatée</FONT>-->

<H3><FONT SIZE=5>5.1.4&nbsp;&nbsp; Ecriture non formatée</FONT></H3><!--SEC END -->
<FONT SIZE=5>
Les deux fonctions suivantes permettent d'écrire et de lire des zones mémoire, le contenu de la mémoire est directement écrit sur disque sans transformation, et réciproquement le contenu du disque est placé tel quel en mémoire. L'intérêt de ces fonctions est d'obtenir des entrées sorties plus rapides et des sauvegardes disque plus compactes mais malheureusement illisibles (binaire).
</FONT><PRE><FONT SIZE=5><TT><B>
#include &lt;stdio.h&gt;
int fwrite(void *add, size_t ta, size_t nbobjets, FILE *f);
</B></TT></FONT></PRE><FONT SIZE=5>
</FONT><FONT SIZE=5>stdlib!fwrite@</FONT><FONT SIZE=5><TT>fwrite</TT></FONT><FONT SIZE=5>

Ecrit </FONT><FONT SIZE=5><TT>nbobjets</TT></FONT><FONT SIZE=5> de taille </FONT><FONT SIZE=5><TT>ta</TT></FONT><FONT SIZE=5> qui se trouvent à l'adresse </FONT><FONT SIZE=5><TT>add</TT></FONT><FONT SIZE=5> dans le fichier de descripteur </FONT><FONT SIZE=5><TT>f</TT></FONT><FONT SIZE=5>.
</FONT><PRE><FONT SIZE=5><TT><B>
#include &lt;stdio.h&gt;
int fread(void *add, size_t ta, size_t nbobjets, FILE *f);
</B></TT></FONT></PRE><FONT SIZE=5>
</FONT><FONT SIZE=5>stdlib!fread@</FONT><FONT SIZE=5><TT>fread</TT></FONT><FONT SIZE=5>

Lit </FONT><FONT SIZE=5><TT>nbobjets</TT></FONT><FONT SIZE=5> de taille </FONT><FONT SIZE=5><TT>ta</TT></FONT><FONT SIZE=5> dans le fichier de descripteur </FONT><FONT SIZE=5><TT>f</TT></FONT><FONT SIZE=5> et les place à partir de l'adresse </FONT><FONT SIZE=5><TT>add</TT></FONT><FONT SIZE=5> en mémoire.<BR>
<BR>
Attention&nbsp;: La fonction </FONT><FONT SIZE=5><TT>fread</TT></FONT><FONT SIZE=5> retourne 0 si l'on essaye de lire
au delà du fichier. Pour écrire une boucle de lecture propre on utilise la fonction </FONT><FONT SIZE=5><TT>feof(FILE *)</TT></FONT><FONT SIZE=5>&nbsp;:
</FONT><PRE><FONT SIZE=5><TT><B>
int n[2];

while (fread(n, sizeof(int), 2, f), !feof(f))
      printf("%d %d \n", n[0], n[1]);
</B></TT></FONT></PRE><FONT SIZE=5>
</FONT><FONT SIZE=5>stdlib!feof@</FONT><FONT SIZE=5><TT>feof</TT></FONT><FONT SIZE=5>


</FONT><!--TOC subsection <FONT SIZE=5>Accès séquentiel</FONT>-->

<H3><FONT SIZE=5>5.1.5&nbsp;&nbsp; Accès séquentiel</FONT></H3><!--SEC END -->
<FONT SIZE=5>On distingue deux techniques d'accès aux supports magnétiques&nbsp;:
</FONT><UL>
<LI><FONT SIZE=5>accès séquentiel</FONT><FONT SIZE=5>
</FONT><FONT SIZE=5> L'accès séquentiel qui consiste à traiter les
 informations dans l'ordre où elle apparaissent sur le support
 (bandes). Le lecteur physique avance avec la lecture, et se
 positionne sur le début de l'enregistrement suivant.</FONT><BR>
<BR>

<LI><FONT SIZE=5> L'accès direct qui consiste à se placer directement sur l'information sans parcourir celles qui la précèdent (disques). Le lecteur physique reste sur le même enregistrement après une lecture.</FONT><FONT SIZE=5>accès direct</FONT><FONT SIZE=5>
</FONT></UL><FONT SIZE=5>
En langage C l'accès est séquentiel mais il est possible de
déplacer le "pointeur de fichier" c'est à dire
sélectionner l'indice du prochain octet à lire ou écrire.</FONT><FONT SIZE=5>pointeur de fichier</FONT><BR>
<BR>
<FONT SIZE=5>Comme nous venons de le voir dans les modes d'ouverture, le pointeur de fichier peut être initialement placé en début ou fin de fichier.<BR>
<BR>
Les quatre fonctions d'entrée-sortie (</FONT><FONT SIZE=5><TT>fgetc, fputc, fscanf, fprintf</TT></FONT><FONT SIZE=5>) travaillent séquentiellement à partir de cette origine fixée par </FONT><FONT SIZE=5><TT>fopen</TT></FONT><FONT SIZE=5>.<BR>
<BR>
</FONT><!--TOC subsection <FONT SIZE=5>Manipulation du pointeur de fichier</FONT>-->

<H3><FONT SIZE=5>5.1.6&nbsp;&nbsp; Manipulation du pointeur de fichier</FONT></H3><!--SEC END -->
<FONT SIZE=5>Le pointeur de fichier est un entier </FONT><FONT SIZE=5><TT>long</TT></FONT><FONT SIZE=5> qui indique à partir de quel octet du fichier la prochaine fonction d'entrée-sortie doit s'effectuer.<BR>
<BR>
En début de fichier cet entier est nul.<BR>
<BR>
</FONT><PRE><FONT SIZE=5><TT><B>
#include &lt;stdio.h&gt;
int fseek(FILE *f, long pos, int direction);
</B></TT></FONT></PRE><FONT SIZE=5>
</FONT><FONT SIZE=5>stdlib!fseek@</FONT><FONT SIZE=5><TT>fseek</TT></FONT><FONT SIZE=5>

</FONT><FONT SIZE=5><TT>f</TT></FONT><FONT SIZE=5> le descripteur du fichier dans lequel ont déplace le pointeur.<BR>
<BR>
direction est une des trois constantes entières suivantes&nbsp;:
</FONT><DL COMPACT=compact>
<DT><FONT SIZE=5>
</FONT><FONT SIZE=5>SEEK_SET</FONT><DD><FONT SIZE=5> positionnement sur l'octet pos du fichier
</FONT>
<DT><FONT SIZE=5>SEEK_CUR</FONT><DD><FONT SIZE=5> positionnement sur le </FONT><FONT SIZE=5><TT>pos</TT></FONT><FONT SIZE=5>-ième octet après la position courante du pointeur de fichier. (équivalent à SEEK_SET courant+pos).
</FONT>
<DT><FONT SIZE=5>SEEK_END</FONT><DD><FONT SIZE=5> positionnement sur le </FONT><FONT SIZE=5><TT>pos</TT></FONT><FONT SIZE=5>-ième octet après la fin du fichier.
</FONT></DL><FONT SIZE=5>
Remarquer que </FONT><FONT SIZE=5><TT>pos</TT></FONT><FONT SIZE=5> est un entier signé &nbsp;: il est possible se placer sur le 4ième octet avant la fin du fichier&nbsp;:
</FONT><PRE><FONT SIZE=5><TT><B>
fseek(f, -4L, SEEK_END);
</B></TT></FONT></PRE><!--TOC subsection <FONT SIZE=5>Un exemple d'accès direct sur un fichier d'entiers.</FONT>-->

<H3><FONT SIZE=5>5.1.7&nbsp;&nbsp; Un exemple d'accès direct sur un fichier d'entiers.</FONT></H3><!--SEC END -->
<FONT SIZE=5>
La fonction suivante lit le n-ième entier d'un fichier d'entiers
préalablement écrit grâce à </FONT><FONT SIZE=5><TT>fwrite</TT></FONT><FONT SIZE=5>&nbsp;:
</FONT><BLOCKQUOTE><FONT SIZE=5>
</FONT><PRE><FONT SIZE=5><TT>
int lirenieme(int n, FILE *f)
{
    int buf;

    fseek(f, sizeof(int)*(n-1), SEEK_SET);
    fread(&amp;buf, sizeof(int), 1, f);
    return buf;
}  \istd{fseek}\istd{fread}
</TT></FONT></PRE><FONT SIZE=5>
</FONT></BLOCKQUOTE><!--TOC subsection <FONT SIZE=5>Les autres fonctions de déplacement du pointeur de fichier.</FONT>-->

<H3><FONT SIZE=5>5.1.8&nbsp;&nbsp; Les autres fonctions de déplacement du pointeur de fichier.</FONT></H3><!--SEC END -->
<FONT SIZE=5>La fonction </FONT><FONT SIZE=5><TT>ftell</TT></FONT><FONT SIZE=5>
 </FONT><PRE><FONT SIZE=5><TT>
    long int ftell(FILE *);
 </TT></FONT></PRE><FONT SIZE=5>
</FONT><FONT SIZE=5>stdlib!ftell@</FONT><FONT SIZE=5><TT>ftell</TT></FONT><FONT SIZE=5>

retourne la position courante du pointeur.<BR>La fonction </FONT><FONT SIZE=5><TT>rewind</TT></FONT><FONT SIZE=5>
</FONT><PRE><FONT SIZE=5><TT><B>
    void rewind(FILE *f);
 </B></TT></FONT></PRE><FONT SIZE=5>
</FONT><FONT SIZE=5>stdlib!rewind@</FONT><FONT SIZE=5><TT>rewind</TT></FONT><FONT SIZE=5>

équivalent à&nbsp;: </FONT><FONT SIZE=5><TT>(void) fseek (f, 0L, 0)</TT></FONT><FONT SIZE=5>

<BR>
<BR>
</FONT><!--TOC section <FONT SIZE=5>Les tampons de fichiers de stdlib.</FONT>-->

<H2><FONT SIZE=5>5.2&nbsp;&nbsp; Les tampons de fichiers de stdlib.</FONT></H2><!--SEC END -->
<FONT SIZE=5>La bibliothèque standard utilise des tampons pour minimiser le
nombre d'appels système. Il est possible de tester l'efficacité de
cette bufferisation en comparant la vitesse de recopie d'un même
fichier avec un tampon de taille 1 octet et un tampon adapté à la machine, la différence devient vite très importante.
Une façon simple de le percevoir est d'écrire un programme </FONT><FONT SIZE=5><TT>com</TT></FONT><FONT SIZE=5> qui réalise des écritures sur la sortie standard ligne
par ligne, de regarder sa vitesse puis de comparer avec la commande suivantes&nbsp;:</FONT><FONT SIZE=5><TT>com | cat</TT></FONT><FONT SIZE=5> la bibliothèque standard utilisant des buffer différents dans les deux cas une différence de vitese d'exécution est perceptible (sur une machine lente la différence de vitesse est évidente, mais elle existe aussi sur une rapide...).<BR>
<BR>
</FONT><!--TOC subsection <FONT SIZE=5>Les modes de bufferisation par défaut.</FONT>-->

<H3><FONT SIZE=5>5.2.1&nbsp;&nbsp; Les modes de bufferisation par défaut.</FONT></H3><!--SEC END -->
<FONT SIZE=5>Le mode de bufferisation des fichiers ouverts par la bibliothèque standard dépend du type de périphérique.<BR></FONT><UL>
<LI><FONT SIZE=5>bufferisation</FONT><FONT SIZE=5>
</FONT><FONT SIZE=5> Si le fichier est un </FONT><FONT SIZE=5><B>terminal</B></FONT><FONT SIZE=5> la bufferisation est faite ligne à ligne.
En </FONT><FONT SIZE=5><EM>écriture </EM></FONT><FONT SIZE=5> le tampon est vidé à chaque écriture d'un </FONT><CODE><FONT SIZE=5>'\n'</FONT></CODE><FONT SIZE=5> , ou quand il est plein (première des deux occurences).
En </FONT><FONT SIZE=5><EM>lecture </EM></FONT><FONT SIZE=5> le tampon est rempli après chaque
validation (RC), si l'on tape trop de caractères le terminal
proteste (beep) le buffer clavier étant plein.
</FONT>
<LI><FONT SIZE=5> Si le fichier est sur un </FONT><FONT SIZE=5><B>disque magnétique</B></FONT><FONT SIZE=5>
En </FONT><FONT SIZE=5><EM>écriture </EM></FONT><FONT SIZE=5> le tampon est vidé avant de déborder.
En </FONT><FONT SIZE=5><EM>lecture </EM></FONT><FONT SIZE=5> le tampon est rempli quand il est vide.
</FONT></UL><FONT SIZE=5>Le shell de login change le mode de bufferisation de </FONT><FONT SIZE=5><B>stderr</B></FONT><FONT SIZE=5> qui est un fichier terminal à non bufferisé.<BR>Nous avons donc à notre disposition trois modes de bufferisation standards&nbsp;:
</FONT><UL>
<LI><FONT SIZE=5> 
 </FONT><FONT SIZE=5> Non bufferisé (sortie erreur standard),
 </FONT>
<LI><FONT SIZE=5> Bufferisé par ligne (lecture/écriture sur terminal),
 </FONT>
<LI><FONT SIZE=5> Bufferisé par blocs (taille des tampons du buffer cache).
 </FONT></UL><FONT SIZE=5>
Les terminaux acceptent d'autres modes de bufferisation plus complexes en entrée que nous étudierons avec les particularités de ces périphériques (chapître </FONT><A HREF="#terminaux"><FONT SIZE=5>12</FONT></A><FONT SIZE=5>).<BR>Un exemple de réouverture de la sortie standard, avec perte du
mode de bufferisation&nbsp;:
</FONT><BLOCKQUOTE><FONT SIZE=5>
</FONT><PRE><FONT SIZE=5>
#include &lt;stdio.h&gt;
main()
{
    freopen("/dev/tty", "w", stderr);
    fprintf(stderr, "texte non termine par un newline ");
    sleep(12);
    exit(0); /* realise fclose(stderr) qui realise fflush(stderr) */
}
</FONT></PRE></BLOCKQUOTE><FONT SIZE=5>
</FONT><FONT SIZE=5>stdlib!freopen@</FONT><FONT SIZE=5><TT>freopen</TT></FONT><FONT SIZE=5>
<BR>
<BR>
Il faut attendre 12 secondes l'affichage.<BR>
<BR>

</FONT><!--TOC subsection <FONT SIZE=5>Manipulation des tampons de la bibliothèque standard.</FONT>-->

<H3><FONT SIZE=5>5.2.2&nbsp;&nbsp; Manipulation des tampons de la bibliothèque standard.</FONT></H3><!--SEC END -->
<FONT SIZE=5>Un tampon alloué automatiquement (malloc) est associé à chaque ouverture de fichier par </FONT><FONT SIZE=5><TT>fopen</TT></FONT><FONT SIZE=5> au moment de la première entrée-sortie sur le fichier.<BR> <BR>La manipulation des tampons de la bibliothèque standard comporte deux aspects&nbsp;:
</FONT><OL type=1>
<LI><FONT SIZE=5> 
 </FONT><FONT SIZE=5> Manipulation de la bufferisation de façon ponctuelle (vidange).
 </FONT>
<LI><FONT SIZE=5> Positionnement du mode de bufferisation.
</FONT></OL><!--TOC subsubsection <FONT SIZE=5>Manipulations ponctuelles</FONT>-->

<H4><FONT SIZE=5> Manipulations ponctuelles</FONT></H4><!--SEC END -->
<FONT SIZE=5>
La fonction suivante permet de vider le tampon associé au FILE * f&nbsp;:
</FONT><PRE><FONT SIZE=5>
#include &lt;stdio.h&gt;
fflush(FILE *f);
</FONT></PRE><FONT SIZE=5>
</FONT><FONT SIZE=5>stdlib!fflush@</FONT><FONT SIZE=5><TT>fflush</TT></FONT><FONT SIZE=5>

En écriture force la copie du tampon associé à la structure f dans le tampon système (ne garantit pas l'écriture en cas d'interruption du système!).<BR>En lecture détruit le contenu du tampon, si l'on est en mode ligne uniquement jusqu'au premier caractère </FONT><CODE><FONT SIZE=5>'\n'</FONT></CODE><FONT SIZE=5>.<BR>La fonction fclose() réalise un fflush() avant de fermer le fichier.<BR>La fonction exit() appel fclose() sur tous les fichiers ouvert par
fopen (freopen,tmpfile,...) avant de terminer le processus.<BR>
</FONT><FONT SIZE=5>stdlib!fclose@</FONT><FONT SIZE=5><TT>fclose</TT></FONT><FONT SIZE=5>


</FONT><!--TOC subsubsection <FONT SIZE=5> Manipulations du mode de bufferisation et de la taille du tampon.</FONT>-->

<H4><FONT SIZE=5>  Manipulations du mode de bufferisation et de la taille du tampon.</FONT></H4><!--SEC END -->
<FONT SIZE=5>La primitive&nbsp;
</FONT><PRE><FONT SIZE=5><TT>
  int setvbuf(FILE *f,
        char *adresse,
        int mode,
        size_t taille); 
 </TT></FONT></PRE><FONT SIZE=5>
</FONT><FONT SIZE=5>stdlib!setvbuf@</FONT><FONT SIZE=5><TT>setvbuf</TT></FONT><FONT SIZE=5>

permet un changement du mode de bufferisation du fichier </FONT><FONT SIZE=5><EM>f </EM></FONT><FONT SIZE=5> avec un tampon de taille </FONT><FONT SIZE=5><EM>taille</EM></FONT><FONT SIZE=5> fourni par l'utilisateur à l'adresse </FONT><FONT SIZE=5><EM>adresse</EM></FONT><FONT SIZE=5> si elle est non nulle, avec le </FONT><FONT SIZE=5><EM>mode</EM></FONT><FONT SIZE=5> défini par les macro-définitions suivantes (</FONT><CODE><FONT SIZE=5><TT>&lt;stdio.h&gt;</TT></FONT></CODE><FONT SIZE=5>)&nbsp;:
</FONT><PRE><FONT SIZE=5><TT>
_IOFBF        bufferise 
_IONBF        Non bufferise 
_IOMYBUF      Mon buffer
_IOLBF        bufferise par ligne (ex: les terminaux)
 </TT></FONT></PRE><FONT SIZE=5>
Attention&nbsp;: Il ne faut pas appeler cette fonction après l'allocation automatique réalisée par la bibliothèque standard après le premier appel à une fonction d'entrée-sortie sur le fichier.<BR>Il est fortement conseillé que la zone mémoire pointée par </FONT><FONT SIZE=5><EM>adresse</EM></FONT><FONT SIZE=5> soit au moins d'une taille égale à </FONT><FONT SIZE=5><EM>taille</EM></FONT><FONT SIZE=5>.<BR>
<BR>
Seul un passage au mode bufferisé en ligne ou non bufferisé peut
être réalisé après l'allocation automatique du tampon, au
risque de perdre ce tampon (absence d&nbsp;'appel de </FONT><FONT SIZE=5><TT>free</TT></FONT><FONT SIZE=5>). Ce qui permet par exemple de changer le mode de bufferisation de la sortie standard après un </FONT><FONT SIZE=5><TT>fork</TT></FONT><FONT SIZE=5>. Attention ce peut être dangereux, pour le contenu courant du tampon comme le montre l'exemple suivant.<BR>Avant cette fonction de norme POSIX on utilisait trois fonctions&nbsp;:
</FONT><BLOCKQUOTE><FONT SIZE=5>
</FONT><PRE><FONT SIZE=5><TT>
void setbuf(FILE *f, char *buf);
void setbuffer(FILE *f,char *adresse,size_t t);
void setlignebuf(FILE *f);
 </TT></FONT></PRE><FONT SIZE=5>
</FONT><FONT SIZE=5>stdlib!setbuf@</FONT><FONT SIZE=5><TT>setbuf</TT></FONT><FONT SIZE=5>

</FONT><FONT SIZE=5>stdlib!setbuffer@</FONT><FONT SIZE=5><TT>setbuffer</TT></FONT><FONT SIZE=5>

</FONT><FONT SIZE=5>stdlib!setlignebuf@</FONT><FONT SIZE=5><TT>setlignebuf</TT></FONT><FONT SIZE=5>
<BR>
<BR>

<BR>
<BR>
</FONT><PRE><FONT SIZE=5><TT>
#include &lt;stdio.h&gt;
main()
{
  printf("BonJour ");
  switch(fork())
  {
    case -1 :
       exit(1);
    case  0 :
       printf("je suis le fils");
/* version 1 sans la ligne suivante version 2 avec  */
       setbuffer(stdout, NULL, 0); 
       sleep(1);
       printf("Encore le fils");
       break;
    default :
       printf("je suis le pere");
       sleep(2);
  }
  printf("\n");
}
version 1
fork_stdlib
BonJour je suis le fils Encore le fils
BonJour je suis le pere
version 2
Encore le fils
BonJour je suis le pere
</TT></FONT></PRE><FONT SIZE=5> </FONT></BLOCKQUOTE><FONT SIZE=5>

</FONT><!--TOC section <FONT SIZE=5>Manipulation des liens d'un fichier</FONT>-->

<H2><FONT SIZE=5>5.3&nbsp;&nbsp; Manipulation des liens d'un fichier</FONT></H2><!--SEC END -->
<FONT SIZE=5>
Changer le nom d'un fichier &nbsp;:<BR></FONT><PRE><FONT SIZE=5><TT>
int rename(const char *de,const char *vers);
</TT></FONT></PRE><FONT SIZE=5>
</FONT><FONT SIZE=5>stdlib!rename@</FONT><FONT SIZE=5><TT>rename</TT></FONT><FONT SIZE=5>

permet de renommer un fichier (ou un répertoire). Il faut que les
deux références soient de même type (fichier ou
répertoire) dans le même système de
fichiers.<BR>Rappel &nbsp;: ceci n'a d'effet que sur l'arborescence de fichiers.<BR>Détruire une référence &nbsp;:
</FONT><PRE><FONT SIZE=5><TT>
int remove(const char *filename);
</TT></FONT></PRE><FONT SIZE=5> 
</FONT><FONT SIZE=5>stdlib!remove@</FONT><FONT SIZE=5><TT>remove</TT></FONT><FONT SIZE=5>
<BR>
<BR>
Détruit le lien donné en argument, le système récupère l'inode et les blocs associés au fichier si c'était le dernier lien.<BR></FONT><!--TOC section <FONT SIZE=5>Lancement d'une commande shell</FONT>-->

<H2><FONT SIZE=5>5.4&nbsp;&nbsp; Lancement d'une commande shell</FONT></H2><!--SEC END -->
<FONT SIZE=5>
</FONT><PRE><FONT SIZE=5><TT>
#include &lt;stdlib.h&gt;
int system(const char *chaine_de_commande);
</TT></FONT></PRE><FONT SIZE=5> 
</FONT><FONT SIZE=5>stdlib!system@</FONT><FONT SIZE=5><TT>system</TT></FONT><FONT SIZE=5>

Crée un processus ``/bin/posix/sh'' qui exécute la commande&nbsp;;
il y a attente de la fin du shell, (la commande peut elle être
lancée en mode détaché ce qui fait que le shell retourne
immédiatement sans faire un </FONT><FONT SIZE=5><TT>wait</TT></FONT><FONT SIZE=5>). Ce mécanisme est très
coûteux. Attention la commande </FONT><FONT SIZE=5><TT>system</TT></FONT><FONT SIZE=5> bloque les signaux
SIGINT et SIGQUIT, il faut analyser la valeur de retour de </FONT><FONT SIZE=5><TT>system</TT></FONT><FONT SIZE=5>
de la même façons que celle de </FONT><FONT SIZE=5><TT>wait</TT></FONT><FONT SIZE=5>. Il est conseillé de
bloquer ces deux signaux avant l'appel de </FONT><FONT SIZE=5><TT>system </TT></FONT><FONT SIZE=5>.<BR>
<BR>

</FONT><!--TOC section <FONT SIZE=5>Terminaison d'un processus</FONT>-->

<H2><FONT SIZE=5>5.5&nbsp;&nbsp; Terminaison d'un processus</FONT></H2><!--SEC END -->
<FONT SIZE=5>
</FONT><!--TOC paragraph <FONT SIZE=5>_exit</FONT>-->

<H5><FONT SIZE=5> _exit</FONT></H5><!--SEC END -->
<FONT SIZE=5>
La primitive de terminaison de processus de bas niveau&nbsp;:
</FONT><PRE><FONT SIZE=5><TT>
    #include &lt;stdlib.h&gt;
    void _exit(int valeur);
</TT></FONT></PRE><FONT SIZE=5> 
</FONT><FONT SIZE=5>appels systèmes!_exit@</FONT><FONT SIZE=5><TT>_exit</TT></FONT><FONT SIZE=5>
<BR>
<BR>
La primitive </FONT><FONT SIZE=5><TT>_exit</TT></FONT><FONT SIZE=5> est la fonction de terminaison "bas niveau"
</FONT><UL>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5> elle ferme les descripteurs ouverts par </FONT><FONT SIZE=5><EM>open, opendir</EM></FONT><FONT SIZE=5> ou hérités du processus père.
</FONT>
<LI><FONT SIZE=5> la </FONT><FONT SIZE=5><TT>valeur</TT></FONT><FONT SIZE=5> est fournie au processus père qui la récupère par l'appel système </FONT><FONT SIZE=5><EM>wait</EM></FONT><FONT SIZE=5>. Cette valeur est le code de retour de processus en shell.
</FONT></UL><FONT SIZE=5>Cette primitive est automatiquement appelée à la fin de la fonction </FONT><FONT SIZE=5><TT>main</TT></FONT><FONT SIZE=5> (sauf en cas d'appels récursifs de </FONT><FONT SIZE=5><TT>main</TT></FONT><FONT SIZE=5>).<BR>
<BR>
</FONT><!--TOC paragraph <FONT SIZE=5>exit</FONT>-->

<H5><FONT SIZE=5> exit</FONT></H5><!--SEC END -->
<FONT SIZE=5> La fonction de terminaison de processus de stdlib&nbsp;:
</FONT><PRE><FONT SIZE=5><TT>
#include &lt;stdlib.h&gt;
void exit(int valeur);
</TT></FONT></PRE><FONT SIZE=5> 
</FONT><FONT SIZE=5>stdlib!exit@</FONT><FONT SIZE=5><TT>exit</TT></FONT><FONT SIZE=5>

la fonction </FONT><FONT SIZE=5><EM>exit</EM></FONT><FONT SIZE=5>&nbsp;:
</FONT><UL>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5> lance les fonctions définies par </FONT><FONT SIZE=5><EM>atexit</EM></FONT><FONT SIZE=5>.
</FONT>
<LI><FONT SIZE=5> ferme l'ensemble des descripteurs ouverts grâce à la bibliothèque standard (</FONT><FONT SIZE=5><EM>fopen</EM></FONT><FONT SIZE=5>).
</FONT>
<LI><FONT SIZE=5> détruit les fichiers fabriqués par la primitive </FONT><FONT SIZE=5><EM>tmpfile</EM></FONT><FONT SIZE=5>
</FONT>
<LI><FONT SIZE=5> appelle </FONT><FONT SIZE=5><EM>_exit </EM></FONT><FONT SIZE=5> avec </FONT><FONT SIZE=5><TT>valeur</TT></FONT><FONT SIZE=5>.
</FONT></UL><FONT SIZE=5>
</FONT><!--TOC paragraph <FONT SIZE=5>atexit</FONT>-->

<H5><FONT SIZE=5> atexit</FONT></H5><!--SEC END -->
<FONT SIZE=5>
La primitive </FONT><FONT SIZE=5><TT>atexit</TT></FONT><FONT SIZE=5> permet de spécifier des fonctions à appeler en fin d'exécution, elle sont lancées par </FONT><FONT SIZE=5><TT>exit</TT></FONT><FONT SIZE=5> dans l'ordre inverse de leur positionnement par </FONT><FONT SIZE=5><TT>atexit</TT></FONT><FONT SIZE=5>.
</FONT><PRE><FONT SIZE=5><TT>
#include &lt;stdlib.h&gt;
int atexit(void (*fonction) (void ));
</TT></FONT></PRE><FONT SIZE=5> 
</FONT><FONT SIZE=5>stdlib!atexit@</FONT><FONT SIZE=5><TT>atexit</TT></FONT><FONT SIZE=5>

Exemple&nbsp;:
</FONT><BLOCKQUOTE><FONT SIZE=5>
</FONT><PRE><FONT SIZE=5><TT>
void bob(void) {printf("coucou\n");}
void bib(void) {printf("cuicui ");}

main(int argc)
{
  atexit(bob);
  atexit(bib);
  if (argc - 1)
    exit(0);
  else
    _exit(0);
}
$ make atexit
cc   atexit.c  -o atexit
$ atexit
$ atexit unargument
cuicui coucou
$
</TT></FONT></PRE><FONT SIZE=5> </FONT></BLOCKQUOTE><FONT SIZE=5>
</FONT><!--TOC section <FONT SIZE=5>Gestion des erreurs</FONT>-->

<H2><FONT SIZE=5>5.6&nbsp;&nbsp; Gestion des erreurs</FONT></H2><!--SEC END -->
<FONT SIZE=5>
Les fonctions de la bibliothèque standard positionnent deux indicateurs d'erreur, la fonction suivante les repositionne&nbsp;:
</FONT><PRE><FONT SIZE=5><TT>
 void clearerr(FILE *);
</TT></FONT></PRE><FONT SIZE=5> 
</FONT><FONT SIZE=5>stdlib!clearerr@</FONT><FONT SIZE=5><TT>clearerr</TT></FONT><FONT SIZE=5>

</FONT><FONT SIZE=5>stdlib!feof@</FONT><FONT SIZE=5><TT>feof</TT></FONT><FONT SIZE=5>

La fonction </FONT><FONT SIZE=5><TT>int feof(FILE *)</TT></FONT><FONT SIZE=5> est vraie si la fin de fichier est atteinte sur ce canal, </FONT><FONT SIZE=5><TT>int ferror(FILE *)</TT></FONT><FONT SIZE=5> est vraie si une erreur a eu lieu pendant la dernière tentative de lecture ou d'écriture sur ce canal.<BR>Une description en langue naturelle de la dernière erreur peut être obtenue grace à
</FONT><BLOCKQUOTE><FONT SIZE=5>
</FONT><FONT SIZE=5> </FONT><PRE><FONT SIZE=5><TT>
void perror(const char *message);
</TT></FONT></PRE><FONT SIZE=5> 
</FONT><FONT SIZE=5>stdlib!perror@</FONT><FONT SIZE=5><TT>perror</TT></FONT><FONT SIZE=5>

</FONT></BLOCKQUOTE><FONT SIZE=5>
l'affichage se fait sur la sortie erreur standard (</FONT><FONT SIZE=5><TT>stderr</TT></FONT><FONT SIZE=5>).<BR>
<BR>
</FONT><!--TOC section <FONT SIZE=5>Création et destruction de répertoires</FONT>-->

<H2><FONT SIZE=5>5.7&nbsp;&nbsp; Création et destruction de répertoires</FONT></H2><!--SEC END -->
<FONT SIZE=5>Création d'un répertoire vide (même syntaxe que </FONT><FONT SIZE=5><TT>creat</TT></FONT><FONT SIZE=5>) &nbsp;:
</FONT><PRE><FONT SIZE=5><TT>
#include &lt;unistd.h&gt;
int mkdir(char *ref, mode_t  mode);
</TT></FONT></PRE><FONT SIZE=5> 
</FONT><FONT SIZE=5>stdlib!mkdir@</FONT><FONT SIZE=5><TT>mkdir</TT></FONT><FONT SIZE=5>
<BR>
<BR>
Destruction &nbsp;:
</FONT><PRE><FONT SIZE=5><TT>
int rmdir(char *ref);
</TT></FONT></PRE><FONT SIZE=5> 
</FONT><FONT SIZE=5>stdlib!rmdir@</FONT><FONT SIZE=5><TT>rmdir</TT></FONT><FONT SIZE=5>

avec les mêmes restrictions que pour les shells sur le contenu du
répertoire (impossible de détruire un répertoire non vide).

</FONT><!--TOC chapter <FONT SIZE=5>Appels système du Système de Gestion de Fichier</FONT>-->

<H1><FONT SIZE=5>Chapitre&nbsp;6&nbsp;&nbsp; Appels système du Système de Gestion de Fichier</FONT></H1><!--SEC END -->
<FONT SIZE=5>Les appels système d'entrées-sorties ou entrées-sorties de bas niveau sont rudimentaires mais polymorphes, en effet c'est eux qui permettent d'écrire des programmes indépendamment des supports physiques sur lesquels se font les entrées/sorties et de pouvoir facilement changer les supports physiques associés a une entrée-sortie.<BR>Les appels système du système de gestion de fichier sont&nbsp;:
</FONT><DL COMPACT=compact>
<DT><FONT SIZE=5> 
</FONT><FONT SIZE=5>appels systèmes!introduction@</FONT><FONT SIZE=5><TT>introduction</TT></FONT><FONT SIZE=5>

</FONT><FONT SIZE=5><TT>open/creat</TT></FONT><DD><FONT SIZE=5> ouverture/création d'un fichier
</FONT>
<DT><FONT SIZE=5><TT>read/write</TT></FONT><DD><FONT SIZE=5> lecture/ecriture sur un fichier ouvert
</FONT>
<DT><FONT SIZE=5><TT>lseek</TT></FONT><DD><FONT SIZE=5> déplacement du pointeur de fichier
</FONT>
<DT><FONT SIZE=5><TT>dup,dup2</TT></FONT><DD><FONT SIZE=5> copie d'ouverture de fichier
</FONT>
<DT><FONT SIZE=5><TT>close</TT></FONT><DD><FONT SIZE=5> fermeture d'un fichier
</FONT>
<DT><FONT SIZE=5><TT>mount</TT></FONT><DD><FONT SIZE=5> chargement d'un disque
</FONT>
<DT><FONT SIZE=5><TT>mknode</TT></FONT><DD><FONT SIZE=5> création d'un inode de fichier spécial
</FONT>
<DT><FONT SIZE=5><TT>pipe</TT></FONT><DD><FONT SIZE=5> création d'un tube
</FONT>
<DT><FONT SIZE=5><TT>fcntl</TT></FONT><DD><FONT SIZE=5> manipulation des caractéristiques des ouvertures de fichiers
</FONT></DL><FONT SIZE=5>
 Les appels système sont réalisés par le noyau et retournent -1 en cas d'erreur.<BR>
</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML028.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 6.1&nbsp;: Tables du système de fichiers.</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="Tablesouverturesfichiers"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>
</FONT><!--TOC section <FONT SIZE=5><TT>open</TT></FONT>-->

<H2><FONT SIZE=5>6.1&nbsp;&nbsp; </FONT><FONT SIZE=5><TT>open</TT></FONT></H2><!--SEC END -->
<A NAME="open"></A><FONT SIZE=5>
</FONT><PRE><FONT SIZE=5><TT>
#include &lt;fcntl.h&gt;
int open(char *ref, int mode, int perm);
</TT></FONT></PRE><FONT SIZE=5> 
</FONT><FONT SIZE=5>appels systèmes!open@</FONT><FONT SIZE=5><TT>open</TT></FONT><FONT SIZE=5>

Ouverture du fichier de référence (absolue ou relative à ".") </FONT><FONT SIZE=5><EM>ref</EM></FONT><FONT SIZE=5>.<BR>Le </FONT><FONT SIZE=5><EM>mode</EM></FONT><FONT SIZE=5> d'ouverture est une conjonction des masques suivants&nbsp;:
</FONT><PRE><FONT SIZE=5><TT>
O_RDONLY  /* open for reading */
O_WRONLY  /* open for writing */
O_RDWR    /* open for read &amp; write */
O_NDELAY  /* non-blocking open */
O_APPEND  /* append on each write */
O_CREAT   /* open with file create */
O_TRUNC   /* open with truncation */
O_EXCL    /* error on create if file exists*/
</TT></FONT></PRE><FONT SIZE=5> Le paramètre </FONT><FONT SIZE=5><EM>perm</EM></FONT><FONT SIZE=5>ission n'a de sens qu'à la création du
fichier, il permet de positionner les valeurs du champ </FONT><FONT SIZE=5><TT>mode</TT></FONT><FONT SIZE=5> de
l'inode. Les droits effectivement positionnés dépendent de la
valeur de </FONT><FONT SIZE=5><EM>umask</EM></FONT><FONT SIZE=5>, grace à la formule </FONT><FONT SIZE=5><TT>droits = perm &amp;
</TT></FONT><CODE><FONT SIZE=5><TT>~ umask</TT></FONT></CODE><FONT SIZE=5>. La valeur par défaut de </FONT><FONT SIZE=5><TT>umask</TT></FONT><FONT SIZE=5> est 066 (valeur octale).<BR>La valeur de retour de </FONT><FONT SIZE=5><TT>open</TT></FONT><FONT SIZE=5> est le numéro dans la table de
descripteurs du processus qui a été utilisé par </FONT><FONT SIZE=5><TT>open</TT></FONT><FONT SIZE=5>. Ce numéro est appelé descripteur de l'ouverture. Ce descripteur est utilisé dans les autres appels système pour spécifier l'ouverture de fichier sur laquelle on veut travailler</FONT><A NAME="text5" HREF="#note5"><SUP><FONT SIZE=2>1</FONT></SUP></A><FONT SIZE=5>, et -1 en cas d'échec de l'ouverture.<BR>
<BR>
</FONT><!--TOC subsection <FONT SIZE=5>Déroulement interne d'un appel de </FONT><FONT SIZE=5><TT>open</TT></FONT>-->

<H3><FONT SIZE=5>6.1.1&nbsp;&nbsp; Déroulement interne d'un appel de </FONT><FONT SIZE=5><TT>open</TT></FONT></H3><!--SEC END -->
<OL type=1>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5> Le système détermine l'inode du fichier
 référence (</FONT><FONT SIZE=5><EM>namei</EM></FONT><FONT SIZE=5>).
</FONT>
<LI><FONT SIZE=5> </FONT><UL>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5> Soit l'inode est dans la table des inodes en mémoire.
</FONT>
<LI><FONT SIZE=5> Soit il alloue une entrée et recopie l'inode du disque (</FONT><FONT SIZE=5><EM>iget</EM></FONT><FONT SIZE=5>).
</FONT></UL><FONT SIZE=5> 
</FONT>
<LI><FONT SIZE=5> Le système vérifie les droits d'accès dans le mode demandé.
</FONT>
<LI><FONT SIZE=5> Il alloue une entrée dans la table des fichiers ouverts du système, et positionne le curseur de lecture écriture dans le fichier (offset = 0, sauf dans le cas du mode </FONT><FONT SIZE=5><TT>O_APPEND</TT></FONT><FONT SIZE=5> offset=taille du fichier).
</FONT>
<LI><FONT SIZE=5> Le système alloue une place dans la table des descripteurs </FONT><FONT SIZE=5><TT>_iob</TT></FONT><FONT SIZE=5> du fichier.
</FONT>
<LI><FONT SIZE=5> Il renvoie au processus le numéro de descripteur, c'est à dire le numéro de l'entrée qu'il vient d'allouer dans le tableau </FONT><FONT SIZE=5><TT>_iob</TT></FONT><FONT SIZE=5>.
</FONT></OL><FONT SIZE=5>
Si l'opération a échoué dans une des étapes le système renvoie </FONT><FONT SIZE=5><TT>-1</TT></FONT><FONT SIZE=5>.

</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML029.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 6.2&nbsp;: Avant l'ouverture, descripteurs standard ouverts, puis après l'ouverture de ''toto''.</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="ouvertureaa"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>

</FONT><!--TOC section <FONT SIZE=5><TT>creat</TT></FONT>-->

<H2><FONT SIZE=5>6.2&nbsp;&nbsp; </FONT><FONT SIZE=5><TT>creat</TT></FONT></H2><!--SEC END -->
<FONT SIZE=5>
Création d'un fichier et ouverture en écriture.
</FONT><PRE><FONT SIZE=5><TT>
int creat(char *reference, int permissions);
</TT></FONT></PRE><FONT SIZE=5> 
</FONT><FONT SIZE=5>appels systèmes!creat@</FONT><FONT SIZE=5><TT>creat</TT></FONT><FONT SIZE=5>

</FONT><OL type=1>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5> Le système détermine l'inode du catalogue où l'on demande la création du fichier.
</FONT><OL type=a>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5> Si il existe déjà une inode pour le fichier 
</FONT><UL>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5> Le noyau lit l'inode en question (allocation dans la table des
 inodes en mémoire), vérifie que c'est un fichier
 ordinaire autorisé en écriture par le propriétaire
 effectif du processus, sinon échec.
</FONT>
<LI><FONT SIZE=5> Le système libère les blocs de données et réduit la taille du fichier à zéro, il ne modifie pas les droits qu'avait le fichier antérieurement.
</FONT></UL><FONT SIZE=5>
</FONT>
<LI><FONT SIZE=5> Si n'existait pas d'inode pour le fichier
</FONT><UL>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5> Le système teste les droits en écriture sur le catalogue
</FONT>
<LI><FONT SIZE=5> Il alloue une nouvelle inode (</FONT><FONT SIZE=5><EM>ialloc</EM></FONT><FONT SIZE=5>)
</FONT>
<LI><FONT SIZE=5> Il alloue une nouvelle entrée dans la table des inodes en mémoire.
</FONT></UL><FONT SIZE=5>
</FONT></OL><FONT SIZE=5>
</FONT></OL><FONT SIZE=5>
Même suite que pour </FONT><FONT SIZE=5><TT>open</TT></FONT><FONT SIZE=5>.

<BR>
<BR>
</FONT><!--TOC section <FONT SIZE=5><TT>read</TT></FONT>-->

<H2><FONT SIZE=5>6.3&nbsp;&nbsp; </FONT><FONT SIZE=5><TT>read</TT></FONT></H2><!--SEC END -->
<FONT SIZE=5>
</FONT><PRE><FONT SIZE=5><TT>
int nbcharlus = read(int d, char *tampon, int nbalire)
</TT></FONT></PRE><FONT SIZE=5> 
</FONT><FONT SIZE=5>appels systèmes!read@</FONT><FONT SIZE=5><TT>read</TT></FONT><FONT SIZE=5>

</FONT><DL COMPACT=compact>
<DT><BR>
<BR>
<FONT SIZE=5> </FONT><FONT SIZE=5><EM>d</EM></FONT><FONT SIZE=5>escripteur</FONT><DD><FONT SIZE=5> entrée de la table des descripteurs correspondante au fichier dans lequel doit être effectuée la lecture (fourni par </FONT><FONT SIZE=5><TT>open</TT></FONT><FONT SIZE=5>).<BR>
<BR>
 </FONT>
<DT><FONT SIZE=5><EM>nbalire</EM></FONT><DD><FONT SIZE=5> nombre de caractères à lire dans le fichier.
 </FONT>
<DT><FONT SIZE=5><EM>tampon</EM></FONT><DD><FONT SIZE=5> un tableau de caractères alloué par l'utilisateur.
 Les caractères lus sont placés dans ce tampon.<BR>
<BR>
 </FONT>
<DT><FONT SIZE=5><EM>nbcharlus</EM></FONT><DD><FONT SIZE=5> nombre de caractères effectivement lus, ou
 -1 en cas d'échec de l'appel système, (droits, ...), la
 fin de fichier est atteinte quand le nombre de caractères
 lus est inférieur au nombre de caractères demandés.
</FONT></DL><FONT SIZE=5>
Déroulement&nbsp;:<BR>
<BR>
</FONT><OL type=1>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5> Vérification du descripteur </FONT><FONT SIZE=5><FONT FACE=symbol>¾®</FONT></FONT><FONT SIZE=5> accès aux tables système.
</FONT>
<LI><FONT SIZE=5> Droits (mode adéquat)
</FONT>
<LI><FONT SIZE=5> Grâce à l'inode le système obtient les adresses du (des) bloc(s) contenant les données à lire. Le système effectue la lecture de ces blocs.
</FONT>
<LI><FONT SIZE=5> Le système recopie les données du buffer cache vers le tampon de l'utilisateur.
</FONT>
<LI><FONT SIZE=5> Le curseur dans le fichier est remit à jour dans l'entrée de la table des fichiers ouverts.
</FONT>
<LI><FONT SIZE=5> Le système renvoie le nombre de caractères effectivement lus.
</FONT></OL><!--TOC section <FONT SIZE=5><TT>write</TT></FONT>-->

<H2><FONT SIZE=5>6.4&nbsp;&nbsp; </FONT><FONT SIZE=5><TT>write</TT></FONT></H2><!--SEC END -->
<FONT SIZE=5>
</FONT><PRE><FONT SIZE=5><TT>
int nbcecrits = write(int desc, char *tampon, int nbaecrire);
</TT></FONT></PRE><FONT SIZE=5> 
</FONT><FONT SIZE=5>appels systèmes!write@</FONT><FONT SIZE=5><TT>write</TT></FONT><FONT SIZE=5>

Même déroulement que </FONT><FONT SIZE=5><TT>read</TT></FONT><FONT SIZE=5> mais avec une allocation éventuelle de bloc-disque dans le cas d'un ajout au-delà de la fin du fichier.<BR>Dans le cas où l'appel concerne un périphérique en mode caractère&nbsp;:
le système active la fonction </FONT><FONT SIZE=5><TT>write</TT></FONT><FONT SIZE=5> (réciproquement </FONT><FONT SIZE=5><TT>read</TT></FONT><FONT SIZE=5> pour une lecture) du périphérique qui utilise directement l'adresse du tampon utilisateur.<BR>Remarquons ici encore le polymorphisme de ces deux appels système
qui permet de lire et d'écrire sur une grande variété de
périphériques en utilisant une seule syntaxe. Le code C
utilisant l'appel système marchera donc indifféremment sur tous les types de périphériques qui sont définis dans le système de fichier. Par exemple, il existe deux périphériques "logiques" qui sont /dev/null et /dev/zéro (que l'on ne trouve pas sur toutes les machines).
Le premier est toujours vide en lecture et les écritures n'ont aucun effet (il est donc possible de déverser n'importe quoi sur ce périphérique). Le deuxième fournit en lecture une infinité de zéro et n'accepte pas l'écriture.<BR>
</FONT><!--TOC section <FONT SIZE=5><TT>lseek</TT></FONT>-->

<H2><FONT SIZE=5>6.5&nbsp;&nbsp; </FONT><FONT SIZE=5><TT>lseek</TT></FONT></H2><!--SEC END -->
<FONT SIZE=5>
</FONT><PRE><FONT SIZE=5><TT>
#include &lt;fcntl.h&gt;  
off_t  lseek(int d, off_t offset, int direction)
</TT></FONT></PRE><FONT SIZE=5> </FONT><FONT SIZE=5><TT>lseek</TT></FONT><FONT SIZE=5> permet de déplacer le curseur de fichier dans la </FONT><FONT SIZE=5><B>table des fichiers ouverts</B></FONT><FONT SIZE=5> du système.
</FONT><FONT SIZE=5><EM>offset</EM></FONT><FONT SIZE=5> un déplacement en octets.<BR></FONT><FONT SIZE=5><EM>d </EM></FONT><FONT SIZE=5> le descripteur.<BR></FONT><FONT SIZE=5><EM>direction </EM></FONT><FONT SIZE=5> une des trois macros L_SET, L_INCR, L_XTND.<BR></FONT><DL COMPACT=compact>
<DT><FONT SIZE=5>
</FONT><FONT SIZE=5>L_SET</FONT><DD><FONT SIZE=5> la nouvelle position est </FONT><FONT SIZE=5><EM>offset</EM></FONT><FONT SIZE=5> sauf si </FONT><FONT SIZE=5><EM>offset</EM></FONT><FONT SIZE=5> est
 supérieur à la taille du fichier, auquel cas la position
 est égale à la taille du fichier. Si l'offset est négatif,
 alors la position est zéro.</FONT><BR>
<BR>

<DT><FONT SIZE=5>L_INCR</FONT><DD><FONT SIZE=5> la position courante est incrémentée de
 </FONT><FONT SIZE=5><EM>offset</EM></FONT><FONT SIZE=5> place (même contrainte sur la position maximum et la
 position minimum).</FONT><BR>
<BR>

<DT><FONT SIZE=5>L_XTND</FONT><DD><FONT SIZE=5> Déplacement par rapport à la fin du fichier, cette
 option permet d'augmenter la taille du fichier (ne pas créer
 de fichiers virtuellement gros avec ce mécanisme, ils posent des
 problèmes de sauvegarde).
</FONT></DL><FONT SIZE=5>La valeur de retour de lseek est la nouvelle position du curseur dans le fichier ou -1 si l'appel a échoué.<BR>
</FONT><!--TOC section <FONT SIZE=5><TT>dup</TT></FONT><FONT SIZE=5> et </FONT><FONT SIZE=5><TT>dup2</TT></FONT>-->

<H2><FONT SIZE=5>6.6&nbsp;&nbsp; </FONT><FONT SIZE=5><TT>dup</TT></FONT><FONT SIZE=5> et </FONT><FONT SIZE=5><TT>dup2</TT></FONT></H2><!--SEC END -->
<FONT SIZE=5>
Les appels dup et dup2 permettent de dupliquer des entrées de la table des descripteurs du processus.<BR></FONT><PRE><FONT SIZE=5><TT>
int  descripteur2 = dup(int descripteur1);
</TT></FONT></PRE><FONT SIZE=5>
</FONT><FONT SIZE=5>appels systèmes!dup@</FONT><FONT SIZE=5><TT>dup</TT></FONT><FONT SIZE=5>

</FONT><OL type=1>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5> vérification que descripteur est le numéro d'une entrée non nulle.
</FONT>
<LI><FONT SIZE=5> recopie dans la </FONT><FONT SIZE=5><B>première entrée</B></FONT><FONT SIZE=5> libre du tableau des descripteurs l'entrée correspondant à descripteur1.
</FONT>
<LI><FONT SIZE=5> le compteur de descripteurs de l'entrée associée à
 descripteur1 dans la table des ouvertures de fichiers est incrémenté.
</FONT>
<LI><FONT SIZE=5> renvoi de l'indice dans la table des descripteurs de l'entrée nouvellement allouée.
</FONT></OL><FONT SIZE=5>Redirection temporaire de la sortie standard dans un fichier&nbsp;:
</FONT><PRE><FONT SIZE=5><TT>
tempout = open("sortie_temporaire",1);
oldout = dup(1);
close(1);
newout = dup(tempout); /* renvoie 1  */
write(1,"xxxx",4); /* ecriture dans le fichier temporaire */
close(tempout);
close(1);
newout = dup(oldout);
close(oldout);
</TT></FONT></PRE><FONT SIZE=5>Il est aussi possible de choisir le descripteur cible avec
</FONT><PRE><FONT SIZE=5><TT>
int ok = dup2(int source, int destination);
</TT></FONT></PRE><FONT SIZE=5>
</FONT><FONT SIZE=5>appels systèmes!dup2@</FONT><FONT SIZE=5><TT>dup2</TT></FONT><FONT SIZE=5>

Recopie du descripteur </FONT><FONT SIZE=5><TT>source</TT></FONT><FONT SIZE=5> dans l'entrée </FONT><FONT SIZE=5><TT>destination</TT></FONT><FONT SIZE=5> de la
table des descripteurs.
Si </FONT><FONT SIZE=5><TT>destination</TT></FONT><FONT SIZE=5> désigne le descripteur d'un fichier ouvert,
celui-ci est préalablement fermé avant duplication. Si </FONT><FONT SIZE=5><TT>destination</TT></FONT><FONT SIZE=5> n'est pas un
numéro de descripteur valide, il y a une erreur, retour -1.<BR>
<BR>

</FONT><!--TOC section <FONT SIZE=5><TT>close</TT></FONT>-->

<H2><FONT SIZE=5>6.7&nbsp;&nbsp; </FONT><FONT SIZE=5><TT>close</TT></FONT></H2><!--SEC END -->
<FONT SIZE=5>Fermeture d'un fichier.
</FONT><PRE><FONT SIZE=5><TT>
int ok = close(descripteur);
</TT></FONT></PRE><FONT SIZE=5>
</FONT><FONT SIZE=5>appels systèmes!close@</FONT><FONT SIZE=5><TT>close</TT></FONT><FONT SIZE=5>

</FONT><OL type=1>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5> si </FONT><FONT SIZE=5><EM>descripteur </EM></FONT><FONT SIZE=5> n'est pas un descripteur valide retour -1
</FONT>
<LI><FONT SIZE=5> l'entrée d'indice </FONT><FONT SIZE=5><TT>descripteur</TT></FONT><FONT SIZE=5> de la table est libérée.
</FONT>
<LI><FONT SIZE=5> Le compteur de l'entrée de la table des fichiers ouvert associé à </FONT><FONT SIZE=5><TT>descripteur</TT></FONT><FONT SIZE=5> est décrémenté.<BR><BR></FONT><FONT SIZE=5><EM>Si il passe à Zéro alors</EM></FONT><FONT SIZE=5>
</FONT>
<LI><FONT SIZE=5> l'entrée de la table des fichiers ouverts est libérée et
le compteur des ouvertures de l'inode en mémoire est décrémenté.<BR><BR></FONT><FONT SIZE=5><EM>Si il passe à Zéro alors</EM></FONT><FONT SIZE=5>
</FONT>
<LI><FONT SIZE=5> l'entrée dans la table des inodes en mémoire est libérée.<BR><BR></FONT><FONT SIZE=5><EM>Si de plus le compteur de liens de l'inode est à 0 alors</EM></FONT><FONT SIZE=5>
</FONT>
<LI><FONT SIZE=5> le fichier est libéré&nbsp;: récupération de l'inode et des blocs.
</FONT></OL><FONT SIZE=5>Dans le cas d'une ouverture en écriture &nbsp;: le dernier bloc du buffer
cache dans lequel on a écrit est marqué ``a écrire''.<BR>
<BR>


</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML030.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 6.3&nbsp;: Redirection de la sortie standard sur ''toto''.</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="dupclose"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>


</FONT><!--BEGIN NOTES chapter-->
<HR WIDTH="50%" SIZE=1><DL>
<DT><A NAME="note5" HREF="#text5"><FONT SIZE=5><FONT SIZE=5>1</FONT></FONT></A><DD><FONT SIZE=5> Un même fichier peut être ouvert plusieurs fois.
</FONT></DL>
<!--END NOTES-->
<!--TOC chapter <FONT SIZE=5>Les processus</FONT>-->

<H1><FONT SIZE=5>Chapitre&nbsp;7&nbsp;&nbsp; Les processus</FONT></H1><!--SEC END -->
<FONT SIZE=5>
</FONT><A NAME="cha:processus"></A><FONT SIZE=5>
</FONT><!--TOC section <FONT SIZE=5>Introduction aux processus</FONT>-->

<H2><FONT SIZE=5>7.1&nbsp;&nbsp; Introduction aux processus</FONT></H2><!--SEC END -->
<FONT SIZE=5>
</FONT><FONT SIZE=5>processus</FONT><FONT SIZE=5>
Un processus est un ensemble d'octets (en langage machine) en cours d'exécution, en d'autres termes, c'est l'exécution d'un programme.<BR>Un processus UNIX se décompose en&nbsp;:
</FONT><OL type=1>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5>processus!decomposition</FONT><FONT SIZE=5>

 </FONT><FONT SIZE=5> un espace d'adressage (visible par l'utilisateur/programmeur)
 </FONT>
<LI><FONT SIZE=5> Le bloc de contrôle du processus (BCP) lui-même décomposé en&nbsp;:
 </FONT><UL>
<LI><FONT SIZE=5>
 </FONT><FONT SIZE=5> une entrée dans la table des processus du noyau </FONT><FONT SIZE=5><TT>struct proc</TT></FONT><FONT SIZE=5><BR>définie dans </FONT><CODE><FONT SIZE=5><TT>&lt;sys/proc.h&gt;</TT></FONT></CODE><FONT SIZE=5>.
 
</FONT><FONT SIZE=5>processus!proc@</FONT><FONT SIZE=5><TT>struct proc</TT></FONT><FONT SIZE=5>

 </FONT>
<LI><FONT SIZE=5> une structure </FONT><FONT SIZE=5><TT>struct user</TT></FONT><FONT SIZE=5> appelée </FONT><FONT SIZE=5><TT>zone u</TT></FONT><FONT SIZE=5> définie dans </FONT><CODE><FONT SIZE=5>&lt;sys/user.h&gt;</FONT></CODE><FONT SIZE=5>
</FONT></UL><FONT SIZE=5> 
</FONT><FONT SIZE=5>processus!user@</FONT><FONT SIZE=5><TT>struct user</TT></FONT><FONT SIZE=5>

</FONT></OL><FONT SIZE=5>Les processus sous Unix apportent&nbsp;:<BR></FONT><UL>
<LI><FONT SIZE=5>
 </FONT><FONT SIZE=5> La multiplicité des exécutions<BR>Plusieurs processus peuvent être l'exécution d'un même
programme.<BR></FONT>
<LI><FONT SIZE=5> La protection des exécutions<BR>Un processus ne peut exécuter que ses instructions propres et ce
de façon séquentielle; il ne peut pas exécuter des
instructions appartenant à un autre processus.<BR>Les processus sous UNIX communiquent entre eux et avec le reste du monde grâce aux appels système.
</FONT></UL><FONT SIZE=5>
</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML031.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 7.1&nbsp;: La table des processus est interne au noyau.</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="tabledesprocessus"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>


</FONT><!--TOC subsection <FONT SIZE=5>Création d'un processus - </FONT><FONT SIZE=5><TT>fork()</TT></FONT><FONT SIZE=5> </FONT>-->

<H3><FONT SIZE=5>7.1.1&nbsp;&nbsp; Création d'un processus - </FONT><FONT SIZE=5><TT>fork()</TT></FONT><FONT SIZE=5> </FONT></H3><!--SEC END -->
<FONT SIZE=5> 

</FONT><FONT SIZE=5>processus!création</FONT><FONT SIZE=5>
<BR>
<BR>
Sous UNIX la création de processus est réalisée par l'appel système&nbsp;:
</FONT><PRE><FONT SIZE=5><TT>
           int fork(void);
</TT></FONT></PRE><FONT SIZE=5>
</FONT><FONT SIZE=5>appels systèmes!fork@</FONT><FONT SIZE=5><TT>fork</TT></FONT><FONT SIZE=5>
<BR>
<BR>
Tous les processus sauf le processus d'identification 0, sont
créés par un appel à </FONT><FONT SIZE=5><EM>fork</EM></FONT><FONT SIZE=5>.<BR>Le processus qui appelle le fork est appelé processus </FONT><FONT SIZE=5><EM>père</EM></FONT><FONT SIZE=5>.<BR>Le nouveau processus est appelé processus </FONT><FONT SIZE=5><EM>fils</EM></FONT><FONT SIZE=5>.<BR>Tout processus a un seul processus père.<BR>Tout processus peut avoir zéro ou plusieurs processus fils.<BR>Chaque processus est identifié par un numéro unique, son </FONT><FONT SIZE=5><B>PID</B></FONT><FONT SIZE=5>.<BR>Le processus de PID=0 est créé "manuellement" au démarrage
de la machine, ce processus a toujours un rôle
spécial</FONT><A NAME="text6" HREF="#note6"><SUP><FONT SIZE=2>1</FONT></SUP></A><FONT SIZE=5> pour le
système, de plus pour le bon fonctionement des programmes utilisant
</FONT><FONT SIZE=5><TT>fork()</TT></FONT><FONT SIZE=5> il faut que le PID zéro reste toujours utilisé. Le processus
zéro crée, grâce à un appel de fork, le processus init de PID=1.<BR>Le processus de PID=1 de nom </FONT><FONT SIZE=5><I>init</I></FONT><FONT SIZE=5> est l'ancêtre de tous les
autres processus (le processus 0 ne réalisant plus de </FONT><FONT SIZE=5><TT>fork()</TT></FONT><FONT SIZE=5>),
c'est lui qui accueille tous les processus orphelins de père (ceci
a fin de collecter les information à la mort de chaque processus).<BR></FONT><!--TOC section <FONT SIZE=5>Format d'un fichier exécutable</FONT>-->

<H2><FONT SIZE=5>7.2&nbsp;&nbsp; Format d'un fichier exécutable</FONT></H2><!--SEC END -->
<FONT SIZE=5>

</FONT><FONT SIZE=5>processus!format de fichier</FONT><FONT SIZE=5>

Les compilateurs nous permettent de créer des fichiers exécutables. Ces fichiers ont le format suivant qui permet au noyau de les transformer en processus&nbsp;:
</FONT><UL>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5> Une en-tête qui décrit l'ensemble du fichier, ses attributs et sa carte des sections.
</FONT>
<LI><FONT SIZE=5> La taille à allouer pour les variables non initialisées.
</FONT>
<LI><FONT SIZE=5> Une section TEXT qui contient le code (en langage machine) 
</FONT><FONT SIZE=5>processus!$TEXT$</FONT><FONT SIZE=5>

</FONT>
<LI><FONT SIZE=5> Une section données (DATA) codée en langage machine qui contient les données initialisées.
</FONT><FONT SIZE=5>processus!$DATA$</FONT><FONT SIZE=5>

</FONT>
<LI><FONT SIZE=5> Eventuellement d'autres sections&nbsp;: Table des symboles pour le débugeur, Images, ICONS, Table des chaînes, etc.
</FONT></UL><FONT SIZE=5>Pour plus d'informations se reporter au manuel a.out.h sur la machine.<BR>
<BR>
</FONT><!--TOC section <FONT SIZE=5>Chargement/changement d'un exécutable</FONT>-->

<H2><FONT SIZE=5>7.3&nbsp;&nbsp; Chargement/changement d'un exécutable</FONT></H2><!--SEC END -->
<FONT SIZE=5>
L'appel système </FONT><FONT SIZE=5><TT>execve</TT></FONT><FONT SIZE=5> change l'exécutable du processus courant en chargeant un nouvel exécutable. Les régions associée au processus sont préalablement libérées&nbsp;:
</FONT><PRE><FONT SIZE=5><TT>
int execve(/* plusieurs formats */);
</TT></FONT></PRE><FONT SIZE=5> 
</FONT><FONT SIZE=5>appels systèmes!execve@</FONT><FONT SIZE=5><TT>execve</TT></FONT><FONT SIZE=5>
 
</FONT><FONT SIZE=5>processus!recouvrement</FONT><FONT SIZE=5>
<BR>
<BR>
Pour chaque section de l'exécutable une région en mémoire est allouée.<BR>Soit au moins les régions&nbsp;:
</FONT><UL>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5> le </FONT><FONT SIZE=5> <B>code</B></FONT><FONT SIZE=5> 
</FONT>
<LI><FONT SIZE=5> les </FONT><FONT SIZE=5><B>données</B></FONT><FONT SIZE=5> initialisées
</FONT></UL><FONT SIZE=5>Mais aussi les régions&nbsp;:
</FONT><UL>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5> des </FONT><FONT SIZE=5><B>piles</B></FONT><FONT SIZE=5>
</FONT>
<LI><FONT SIZE=5> du </FONT><FONT SIZE=5><B>tas</B></FONT><FONT SIZE=5>
</FONT></UL><FONT SIZE=5> </FONT><FONT SIZE=5>pile</FONT><FONT SIZE=5>tas</FONT><BR>
<BR>
<FONT SIZE=5>La région de la </FONT><FONT SIZE=5><B>pile</B></FONT><FONT SIZE=5>&nbsp;:<BR>C'est une pile de structures de pile qui sont empilées et dépilées lors de l'appel ou le retour de fonction. Le pointeur de pile, un des registres de l'unité centrale, indique la profondeur courante de la pile.<BR>Le code du programme gère les extensions de pile (appel ou retour de fonction), c'est le noyau qui alloue l'espace nécessaire à ces extensions. Sur certains systèmes on trouve une fonction </FONT><FONT SIZE=5><TT>alloca()</TT></FONT><FONT SIZE=5> qui permet de faire des demandes de mémoire sur la pile.<BR>Un processus UNIX pouvant s'exécuter en deux modes (noyau, utilisateur), une pile privée sera utilisée dans chaque mode.<BR>La pile noyau sera vide quand le processus est en mode utilisateur.<BR>Le </FONT><FONT SIZE=5><B>tas</B></FONT><FONT SIZE=5> est une zone où est réalisée l'allocation dynamique avec les
fonctions </FONT><FONT SIZE=5><TT>Xalloc()</TT></FONT><FONT SIZE=5>.
</FONT><FONT SIZE=5>stdlib!Xalloc@</FONT><FONT SIZE=5><TT>Xalloc</TT></FONT><FONT SIZE=5>
 <BR>
</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML032.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 7.2&nbsp;: La structure interne des processus.</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="structureprocessus"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>
</FONT><!--TOC section <FONT SIZE=5>zone u et table des processus</FONT>-->

<H2><FONT SIZE=5>7.4&nbsp;&nbsp; zone u et table des processus</FONT></H2><!--SEC END -->
<FONT SIZE=5>Tous les processus sont associés à une entrée dans la </FONT><FONT SIZE=5><EM>table des processus</EM></FONT><FONT SIZE=5>
qui est interne au noyau. De plus, le noyau alloue pour chaque processus une
structure appelée </FONT><FONT SIZE=5><EM>zone u</EM></FONT><FONT SIZE=5> , qui contient des données privées du processus,
uniquement manipulables par le noyau. 
</FONT><FONT SIZE=5>processus!zone u</FONT><FONT SIZE=5>


</FONT><FONT SIZE=5>processus!table des processus</FONT><FONT SIZE=5>


</FONT><FONT SIZE=5>processus!table des régions par processus</FONT><FONT SIZE=5>

La </FONT><FONT SIZE=5><EM>table des processus</EM></FONT><FONT SIZE=5> nous permet d'accéder à la </FONT><FONT SIZE=5><EM>table des régions par processus</EM></FONT><FONT SIZE=5> qui permet d'accéder à la
</FONT><FONT SIZE=5><EM>table des régions</EM></FONT><FONT SIZE=5>. Ce double niveau d'indirection permet de
faire partager des régions.<BR>Dans l'organisation avec une mémoire virtuelle, la table des
 régions est matérialisée logiquement dans la table de pages.<BR>Les </FONT><FONT SIZE=5><EM>structures de régions</EM></FONT><FONT SIZE=5> de la table des régions contiennent des informations sur le type, les droits d'accès et la localisation (adresses en mémoire ou adresses sur disque) de la région.<BR>
<BR>
Seule la </FONT><FONT SIZE=5><B>zone u</B></FONT><FONT SIZE=5> du processus courant est manipulable par le noyau, les autres sont </FONT><FONT SIZE=5><B>inaccessibles.</B></FONT><FONT SIZE=5> L'adresse de la zone u est placée dans le mot d'état du processus.<BR>
</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML033.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 7.3&nbsp;: Table des régions, table des régions par processus</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="tabledesregions"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>
</FONT><!--TOC section <FONT SIZE=5><TT>fork</TT></FONT><FONT SIZE=5> et </FONT><FONT SIZE=5><TT>exec</TT></FONT><FONT SIZE=5> (revisités)</FONT>-->

<H2><FONT SIZE=5>7.5&nbsp;&nbsp; </FONT><FONT SIZE=5><TT>fork</TT></FONT><FONT SIZE=5> et </FONT><FONT SIZE=5><TT>exec</TT></FONT><FONT SIZE=5> (revisités)</FONT></H2><!--SEC END -->
<FONT SIZE=5>
Quand un processus réalise un </FONT><FONT SIZE=5><TT>fork</TT></FONT><FONT SIZE=5>, le contenu de l'entrée de la table des régions est dupliqué, chaque région est ensuite, en fonction de son type, partagée ou copiée.

</FONT><FONT SIZE=5>appels systèmes!fork@</FONT><FONT SIZE=5><TT>fork</TT></FONT><FONT SIZE=5>

</FONT><FONT SIZE=5>appels systèmes!exec@</FONT><FONT SIZE=5><TT>exec</TT></FONT><FONT SIZE=5>


</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML034.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 7.4&nbsp;: Changement de régions au cours d'un </FONT><FONT SIZE=5><TT>fork</TT></FONT><FONT SIZE=5>.</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="tabledesregionsfork"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>
Quand un processus réalise un </FONT><FONT SIZE=5><TT>exec</TT></FONT><FONT SIZE=5>, il y a libération des régions et réallocation de nouvelles régions en fonction des valeurs définies dans le nouvel exécutable.<BR>
<BR>

</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML035.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 7.5&nbsp;: Changement de régions au cours d'un </FONT><FONT SIZE=5><TT>exec</TT></FONT><FONT SIZE=5>.</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="tabledesregionsexec"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>
</FONT><!--TOC section <FONT SIZE=5>Le contexte d'un processus</FONT>-->

<H2><FONT SIZE=5>7.6&nbsp;&nbsp; Le contexte d'un processus</FONT></H2><!--SEC END -->
<FONT SIZE=5>Le contexte d'un processus est l'ensemble des données qui permettent de reprendre l'exécution d'un processus qui a été interrompu.<BR>
<BR>
Le contexte d'un processus est l'ensemble de
</FONT><OL type=1>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5> son état 
</FONT>
<LI><FONT SIZE=5> son mot d'état&nbsp;: en particulier 
</FONT><FONT SIZE=5>processus!mot d'état</FONT><FONT SIZE=5>

 </FONT><UL>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5> La valeur des registres actifs
</FONT>
<LI><FONT SIZE=5> Le compteur ordinal
</FONT></UL><FONT SIZE=5>
</FONT>
<LI><FONT SIZE=5> les valeurs des variables globales statiques ou dynamiques
</FONT>
<LI><FONT SIZE=5> son entrée dans la table des processus
</FONT>
<LI><FONT SIZE=5> sa zone u
</FONT>
<LI><FONT SIZE=5> Les piles user et system
</FONT>
<LI><FONT SIZE=5> les zones de code et de données.
</FONT></OL><FONT SIZE=5>Le noyau et ses variables ne font partie du contexte d'aucun processus! <BR>
<BR>
L'exécution d'un processus se fait dans son contexte.<BR>
<BR>
Quand il y a changement de processus courant, il y a réalisation d'une </FONT><FONT SIZE=5><B>commutation de mot d'état</B></FONT><FONT SIZE=5> et d'un </FONT><FONT SIZE=5><B>changement de contexte</B></FONT><FONT SIZE=5>.

</FONT><FONT SIZE=5>processus!commutation de mot d'état</FONT><FONT SIZE=5>
 
</FONT><FONT SIZE=5>processus!changement de contexte</FONT><FONT SIZE=5>

Le noyau s'exécute alors dans le nouveau contexte.<BR>
<BR>
</FONT><!--TOC section <FONT SIZE=5>Commutation de mot d'état et interruptions.</FONT>-->

<H2><FONT SIZE=5>7.7&nbsp;&nbsp; Commutation de mot d'état et interruptions.</FONT></H2><!--SEC END -->
<FONT SIZE=5>Ces fonctions de très bas niveau sont fondamentales pour pouvoir programmer un système d'exploitation. <BR>
<BR>
Pour être exécuté et donner naissance à un processus, un programme et ses
données doivent être chargés en mémoire centrale.
Les instructions du programme sont transférées une à une de la mémoire centrale sur l'unité centrale où elles sont exécutées.<BR>
<BR>
L'unité centrale&nbsp;:<BR>Elle comprend des circuits logiques et arithmétiques qui effectuent les instructions mais aussi des mémoires appelées registres.<BR>
<BR>
Certains de ces registres sont spécialisés directement par les constructeurs de l'unité centrale, d'autres le sont par le programmeur du noyau. 
Quelques registres spécialisés&nbsp;:
</FONT><DL COMPACT=compact>
<DT><FONT SIZE=5>
</FONT><FONT SIZE=5>L'accumulateur</FONT><DD><FONT SIZE=5> qui reçoit le résultat d'une instruction; sur les machines à registres multiples, le jeu d'instructions permet souvent d'utiliser n'importe lequel des registres comme accumulateur. 
</FONT><FONT SIZE=5>processus!accumulateur</FONT><FONT SIZE=5>

</FONT>
<DT><FONT SIZE=5>le registre d'instruction</FONT><DD><FONT SIZE=5> (qui contient l'instruction en cours)
</FONT>
<DT><FONT SIZE=5>le compteur ordinal</FONT><DD><FONT SIZE=5> (adresse de l'instruction en mémoire)
 
</FONT><FONT SIZE=5>processus!compteur ordinal</FONT><FONT SIZE=5>

Ce compteur change au cours de la réalisation d'une instruction pour pointer sur la prochaine instruction à exécuter, la majorité des instructions ne font qu'incrémenter ce compteur, les instructions de branchement réalisent des opérations plus complexes sur ce compteur: affectation, incrémentation ou décrémentation plus importantes. 
</FONT>
<DT><FONT SIZE=5>le registre d'adresse</FONT><DD><FONT SIZE=5>
</FONT>
<DT><FONT SIZE=5>les registres de données</FONT><DD><FONT SIZE=5> qui sont utilisés pour lire ou écrire une donnée à une adresse spécifiée en mémoire.
</FONT>
<DT><FONT SIZE=5>les registres d'état</FONT><DD><FONT SIZE=5> du processeur&nbsp;: (actif, mode (user/system), retenue, vecteur d'interruptions, etc)
</FONT>
<DT><FONT SIZE=5>les registres d'état du processus</FONT><DD><FONT SIZE=5> droits, adresses, priorités, etc
</FONT></DL><FONT SIZE=5>
Ces registres forment le contexte </FONT><FONT SIZE=5><B>d'unité centrale d'un processus</B></FONT><FONT SIZE=5>.

</FONT><FONT SIZE=5>processus!context</FONT><FONT SIZE=5>

A tout moment, un processus est caractérisé par ces deux
contextes&nbsp;: le contexte d'unité centrale qui est composé des
mêmes données pour tous les processus et le contexte qui
dépend du code du programme exécuté. Pour pouvoir
exécuter un nouveau processus, il faut pouvoir </FONT><FONT SIZE=5><B>sauvegarder</B></FONT><FONT SIZE=5>
le contexte d'unité centrale du processus courant (mot
d'état), puis charger le nouveau mot d'état du processus à
exécuter. Cette opération délicate réalisée de
façon matérielle est appelée </FONT><FONT SIZE=5><B>commutation de mot
d'état.</B></FONT><FONT SIZE=5> Elle doit se faire de façon non interruptible&nbsp;!

</FONT><FONT SIZE=5>processus!commutation de mot d'état</FONT><FONT SIZE=5>

Cette "Super instruction" utilise 2 adresses qui sont respectivement&nbsp;:<BR>l'adresse de sauvegarde du mot d'état <BR>l'adresse de lecture du nouveau mot d'état<BR>Le compteur ordinal faisant partie du mot d'état, ce changement
provoque l'exécution dans le nouveau processus. <BR>
<BR>
C'est le nouveau processus qui devra réaliser la sauvegarde du
contexte global. En général c'est le noyau qui réalise cette sauvegarde,
le noyau n'ayant pas un contexte du même type.<BR>
<BR>
Le processus interrompu pourra ainsi reprendre exactement où il avait abandonné.<BR>
<BR>
Les fonctions </FONT><FONT SIZE=5><TT>setjmp</TT></FONT><FONT SIZE=5>/</FONT><FONT SIZE=5><TT>longjmp</TT></FONT><FONT SIZE=5> permettent de sauvegarder et de réinitialiser le contexte d'unité central du processus courant, en particulier le pointeur de pile.<BR>
<BR>
</FONT><!--TOC section <FONT SIZE=5>Les interruptions</FONT>-->

<H2><FONT SIZE=5>7.8&nbsp;&nbsp; Les interruptions</FONT></H2><!--SEC END -->
<FONT SIZE=5><EM>Une interruption est une commutation de mot d'état
provoquée par un signal produit par le matériel.</EM></FONT><FONT SIZE=5><BR>Ce signal étant la conséquence d'un événement extérieur ou intérieur, il modifie l'état d'un indicateur qui est régulièrement testé par l'unité centrale.<BR>Une fois que le signal est détecté, il faut déterminer la cause de l'interruption. Pour cela on utilise un indicateur, pour les différentes causes, On parle alors du </FONT><FONT SIZE=5><B>vecteur d'interruptions</B></FONT><FONT SIZE=5>.<BR></FONT><FONT SIZE=5>interruption</FONT><FONT SIZE=5>
Trois grands types d'interruptions&nbsp;:
</FONT><UL>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5> </FONT><FONT SIZE=5> <B>externes</B></FONT><FONT SIZE=5> (indépendantes du processus) interventions de l'opérateur, pannes,etc
</FONT>
<LI><FONT SIZE=5> </FONT><FONT SIZE=5> <B>déroutements</B></FONT><FONT SIZE=5> erreur interne du processeur,
 débordement, division par zéro, page fault etc (causes
 qui entraine la réalisation d'une sauvegarde sur disque de
 l'image mémoire "core dumped" en général)
</FONT>
<LI><FONT SIZE=5> </FONT><FONT SIZE=5> <B>appels systèmes</B></FONT><FONT SIZE=5> demande d'entrée-sortie par exemple.
</FONT></UL><FONT SIZE=5>Suivant les machines et les systèmes un nombre variable de niveaux d'interruption est utilisé.<BR>
<BR>

</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML036.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 7.6&nbsp;: Sous UNIX, on trouvera en général 6 niveaux d'interruption</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="niveauinterruptions"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>


</FONT><FONT SIZE=5>processus!niveau d'interruption</FONT><FONT SIZE=5>
 
Ces différentes interruptions ne réalisent pas nécessairement un changement de contexte complet du processus courant.<BR>
<BR>

</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML037.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 7.7&nbsp;: Le traitement d'une interruption.</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="traitementinterruption"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>

Il est possible que plusieurs niveaux d'interruption soient positionnés quand le système les consulte. C'est le niveau des différentes interruptions qui va permettre au système de sélectionner l'interruption à traiter en priorité.<BR>
<BR>
L'horloge est l'interruption la plus prioritaire sur un système Unix.<BR>
<BR>
</FONT><!--TOC section <FONT SIZE=5>Le problème des cascades d'interruptions</FONT>-->

<H2><FONT SIZE=5>7.9&nbsp;&nbsp; Le problème des cascades d'interruptions</FONT></H2><!--SEC END -->
<FONT SIZE=5>Si pendant le traitement d'une interruption, une autre interruption se produit, et que ceci se répète pendant le traitement de la nouvelle interruption, le système ne fait plus progresser les processus ni les interruptions en cours de traitement ...<BR>
<BR>
Il est donc nécessaire de pouvoir retarder ou annuler la prise en compte d'un ou plusieurs signaux d'interruptions.
C'est le rôle des deux mécanismes de </FONT><FONT SIZE=5> <B>masquage</B></FONT><FONT SIZE=5> et de </FONT><FONT SIZE=5> <B>désarmement</B></FONT><FONT SIZE=5> d'un niveau d'interruption.
</FONT><FONT SIZE=5>masquer</FONT><FONT SIZE=5>
Masquer, c'est ignorer temporairement un niveau d'interruption.<BR>
<BR>
Si ce masquage est fait dans le mot d'état d'un traitement d'interruption, à la nouvelle commutation d'état, le masquage disparaît; les interruptions peuvent de nouveau être prises en compte.
</FONT><FONT SIZE=5>désarmer</FONT><FONT SIZE=5>
Désarmer, c'est rendre le positionnement de l'interruption caduque. (Il est clair que ceci ne peut s'appliquer aux déroutements).<BR>
<BR>
</FONT><!--TOC subsection <FONT SIZE=5> Etats et transitions d'un processus</FONT>-->

<H3><FONT SIZE=5>7.9.1&nbsp;&nbsp;  Etats et transitions d'un processus</FONT></H3><!--SEC END -->
<FONT SIZE=5> 

</FONT><FONT SIZE=5>processus!états</FONT><FONT SIZE=5>


</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML038.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 7.8&nbsp;: Diagramme d'état des processus</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="etats"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>

Nous nous plaçons dans le cas d'un système qui utilise un mécanisme de swap pour gérer la mémoire; nous étudierons ensuite le cas des systèmes de gestion paginée de la mémoire (les couples d'états 3,5 et 4,6 y sont fusionnés).<BR>
<BR>
</FONT><!--TOC subsection <FONT SIZE=5>Listes des états d'un processus</FONT>-->

<H3><FONT SIZE=5>7.9.2&nbsp;&nbsp; Listes des états d'un processus</FONT></H3><!--SEC END -->
<FONT SIZE=5>

</FONT><FONT SIZE=5>processus!mode d'un</FONT><FONT SIZE=5>

</FONT><OL type=1>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5> le processus s'exécute en mode utilisateur 
</FONT>
<LI><FONT SIZE=5> le processus s'exécute en mode noyau 
</FONT>
<LI><FONT SIZE=5> le processus ne s'exécute pas mais est éligible (prêt à s'exécuter)
</FONT>
<LI><FONT SIZE=5> le processus est endormi en mémoire centrale
</FONT>
<LI><FONT SIZE=5> le processus est prêt mais le swappeur doit le transférer en mémoire centrale pour le rendre éligible. (ce mode est différent dans un système à pagination).
</FONT>
<LI><FONT SIZE=5> le processus est endormi en zone de swap (sur disque par exemple).
</FONT>
<LI><FONT SIZE=5> le processus passe du mode noyau au mode utilisateur mais est
 préempté</FONT><A NAME="text7" HREF="#note7"><SUP><FONT SIZE=2>2</FONT></SUP></A><FONT SIZE=5> et a effectué un changement de contexte pour élire un autre processus.
</FONT>
<LI><FONT SIZE=5> naissance d'un processus, ce processus n'est pas encore prêt et n'est pas endormi, c'est l'état initial de tous processus sauf le </FONT><FONT SIZE=5><EM>swappeur</EM></FONT><FONT SIZE=5>.
</FONT>
<LI><FONT SIZE=5> </FONT><FONT SIZE=5><EM>zombie </EM></FONT><FONT SIZE=5> le processus vient de réaliser un exit, il
 apparaît uniquement dans la table des processus où il
 est conservé le temps pour son processus père de
 récupèrer le code de retour et d'autres informations de
 gestion (coût de l'exécution sous forme de temps, et
 d'utilisation des ressources ).
</FONT></OL><FONT SIZE=5>
L'état </FONT><FONT SIZE=5><EM>zombie</EM></FONT><FONT SIZE=5> est l'état final des processus, les processus restent dans cet état jusqu'à ce que leur père lise leur valeur de retour (exit status).<BR>
<BR>
</FONT><!--TOC section <FONT SIZE=5>Lecture du diagramme d'état.</FONT>-->

<H2><FONT SIZE=5>7.10&nbsp;&nbsp; Lecture du diagramme d'état.</FONT></H2><!--SEC END -->
<FONT SIZE=5>
Le diagramme des transitions d'état permet de décrire l'ensemble des états possibles d'un processus. Il est clair que tout processus ne passera pas nécessairement par tous ces différents états.<BR>
<BR>
La naissance d'un processus a lieu dans l'état 8 après l'appel système </FONT><FONT SIZE=5><TT>fork</TT></FONT><FONT SIZE=5> exécuté par un autre processus.
Il devient au bout d'un certain temps "prêt à s'exécuter".
Il passe alors dans l'état "exécuté en mode noyau" où il termine sa partie de l'appel système </FONT><FONT SIZE=5><TT>fork</TT></FONT><FONT SIZE=5>. Puis le processus termine l'appel système et passe dans l'état "exécuté en mode utilisateur".

</FONT><FONT SIZE=5>appels systèmes!fork@</FONT><FONT SIZE=5><TT>fork</TT></FONT><FONT SIZE=5>

Passé une certaine période de temps (variable d'un système à l'autre), l'horloge peut </FONT><FONT SIZE=5><I><FONT COLOR=maroon>interrompre</FONT></I></FONT><FONT SIZE=5> le processeur. Le processus rentre alors en mode noyau, l'interruption est alors réalisée avec le processus en mode noyau.<BR>
<BR>
Au retour de l'interruption, le processus peut être </FONT><FONT SIZE=5><TT>préempté</TT></FONT><FONT SIZE=5> (étant resté tout son quantum de temps sur le cpu), c'est à dire, il reste prêt à s'exécuter mais un autre processus est élu.
Cet état 7 est logiquement équivalent à l'état 3, mais il existe pour matérialiser le fait qu'un processus ne peut être préempté qu'au moment où il retourne du mode noyau au mode utilisateur.
Quand un processus préempté est réélu, il retourne directement en mode utilisateur.<BR>
<BR>
Un appel système ne peut être préempté. On peut détecter en pratique cette règle, en effet on constate un ralentissement du débit de la machine pendant la réalisation d'un core de grande taille.<BR>
<BR>
Quand un processus exécute un appel système, il passe du mode utilisateur au mode système.
Supposons que l'appel système réalise une entrée-sortie sur le disque et que le processus doive attendre la fin de l'entrée-sortie.
Le processus est mis en sommeil (sleep) et passe dans l'état endormi en mémoire.
Quand l'entrée-sortie se termine, une interruption a lieu, le traitement de l'interruption consistant à faire passer le processus dans le mode prêt à s'exécuter (en mémoire).<BR>
<BR>
</FONT><!--TOC section <FONT SIZE=5>Un exemple d'exécution</FONT>-->

<H2><FONT SIZE=5>7.11&nbsp;&nbsp; Un exemple d'exécution</FONT></H2><!--SEC END -->
<FONT SIZE=5>
Plaçons-nous dans la situation suivante&nbsp;:
l'ensemble de la mémoire est occupé par des processus, mais, le processus le plus prioritaire est un processus dans l'état 5, soit&nbsp;: "prêt à s'exécuter en zone de swap".
Pour pouvoir exécuter ce processus, il faut le placer dans l'état 3, soit&nbsp;: "prêt à s'exécuter en mémoire". Pour cela le système doit libérer de la mémoire (faire de la place), en faisant passer des processus des états 3 ou 4 en zone de swap (swapout) donc les faire passer dans les états 5 et 6.<BR>
<BR>
C'est au swappeur de réaliser les deux opérations&nbsp;:
</FONT><UL>
<LI><FONT SIZE=5>
 </FONT><FONT SIZE=5> Sélectionner une victime (le processus le plus approprié),
 pour un transfert hors mémoire centrale (swapout).
</FONT>
<LI><FONT SIZE=5> réaliser ce transfert.
</FONT>
<LI><FONT SIZE=5> une fois qu'une place suffisante est libérée, le processus qui a provoqué le swapout est chargé en mémoire (swapin).
</FONT></UL><FONT SIZE=5> 
</FONT><FONT SIZE=5>processus!swapin</FONT><FONT SIZE=5>

</FONT><FONT SIZE=5>processus!swapout</FONT><FONT SIZE=5>
<BR>
<BR>
Le processus a un contrôle sur un nombre réduit de
transitions&nbsp;: il peut faire un appel système, réaliser un </FONT><FONT SIZE=5><TT>exit</TT></FONT><FONT SIZE=5>, réaliser un </FONT><FONT SIZE=5><TT>sleep</TT></FONT><FONT SIZE=5>, les autres transitions lui sont dictées par les circonstances.

</FONT><FONT SIZE=5>appels systèmes!sleep@</FONT><FONT SIZE=5><TT>sleep</TT></FONT><FONT SIZE=5>
<BR>
<BR>
L'appel à </FONT><FONT SIZE=5><TT>exit()</TT></FONT><FONT SIZE=5> fait passer dans l'état zombie, il est possible de passer à l'état zombie sans que le processus ait explicitement appelé </FONT><FONT SIZE=5><TT>exit()</TT></FONT><FONT SIZE=5> (à la réception de certains signaux par exemple).

</FONT><FONT SIZE=5>appels systèmes!exit@</FONT><FONT SIZE=5><TT>exit</TT></FONT><FONT SIZE=5>

Toutes les autres transitions d'état sont sélectionnées et
réalisées par le noyau selon des règles bien
précises. Une de ces règles est par exemple qu'un processus en
mode noyau ne peut être préempté</FONT><A NAME="text8" HREF="#note8"><SUP><FONT SIZE=2>3</FONT></SUP></A><FONT SIZE=5>. Certaines de ces règles sont définies par l'algorithme d'ordonnancement utilisé.<BR>
<BR>
</FONT><!--TOC section <FONT SIZE=5>La table des processus</FONT>-->

<H2><FONT SIZE=5>7.12&nbsp;&nbsp; La table des processus</FONT></H2><!--SEC END -->
<FONT SIZE=5>
La table des processus est dans la mémoire du noyau. C'est un tableau de structure proc (</FONT><CODE><FONT SIZE=5>&lt;sys/proc.h&gt;</FONT></CODE><FONT SIZE=5>). Cette structure contient les informations qui doivent toujours être accessibles par le noyau.
</FONT><DL COMPACT=compact>
<DT><FONT SIZE=5>
</FONT><FONT SIZE=5>processus!états</FONT><FONT SIZE=5>

</FONT><FONT SIZE=5>état</FONT><DD><FONT SIZE=5> se reporter au diagramme, ce champ permet au noyau de prendre des décisions sur les changements d'état à effectuer sur le processus.
</FONT>
<DT><FONT SIZE=5>adresse de la zone u</FONT><DD><FONT SIZE=5> 
</FONT>
<DT><FONT SIZE=5>adresses</FONT><DD><FONT SIZE=5> taille et localisation en mémoire (centrale, secondaire). Ces informations permettent de transférer un processus en ou hors mémoire centrale.
</FONT>
<DT><FONT SIZE=5>UID</FONT><DD><FONT SIZE=5> propriétaire du processus, permet de savoir si le processus est autorisé à envoyer des signaux et à qui il peut les envoyer.
</FONT>
<DT><FONT SIZE=5>PID,PPID</FONT><DD><FONT SIZE=5> l'identificateur du processus et de son père. Ces deux valeurs sont initialisées dans l'état 8, création pendant l'appel système </FONT><FONT SIZE=5><TT>fork</TT></FONT><FONT SIZE=5>.
</FONT>
<DT><FONT SIZE=5>évènement</FONT><DD><FONT SIZE=5> un descripteur de l'évènement attendu quand le processus est dans un mode endormi.
</FONT>
<DT><FONT SIZE=5>Priorités</FONT><DD><FONT SIZE=5> Plusieurs paramètres sont utilisés par l'ordonnanceur pour sélectionner l'élu parmi les processus prêts.
</FONT>
<DT><FONT SIZE=5>vecteur d'interruption du processus</FONT><DD><FONT SIZE=5> ensemble des signaux reçus par le processus mais pas encore traités.
</FONT>
<DT><FONT SIZE=5>divers</FONT><DD><FONT SIZE=5> des compteurs utilisés pour la comptabilité (pour faire payer le temps CPU utilisé) et que l'on peut manipuler par la commande </FONT><FONT SIZE=5><TT>alarm</TT></FONT><FONT SIZE=5>, des données utilisées par l'implémentation effective du système, etc.
</FONT></DL><!--TOC section <FONT SIZE=5>La zone u</FONT>-->

<H2><FONT SIZE=5>7.13&nbsp;&nbsp; La zone u</FONT></H2><!--SEC END -->
<FONT SIZE=5>
</FONT><FONT SIZE=5>processus!zone u|(</FONT><FONT SIZE=5>

La zone u de type </FONT><FONT SIZE=5><TT>struct user</TT></FONT><FONT SIZE=5> définie dans </FONT><CODE><FONT SIZE=5><TT>&lt;sys/user.h&gt;</TT></FONT></CODE><FONT SIZE=5> est la zone utilisée quand un processus s'exécute que ce soit en mode noyau ou mode utilisateur.
Une unique zone u est accessible à la fois &nbsp;: celle de l'unique processus en cours d'exécution (dans un des états 1 ou 2).<BR>Contenu de la zone u&nbsp;:
</FONT><DL COMPACT=compact>
<DT><FONT SIZE=5>
</FONT><FONT SIZE=5>pointeur</FONT><DD><FONT SIZE=5> sur la structure de processus de la table des processus.
</FONT>
<DT><FONT SIZE=5>uid réel et effectif</FONT><DD><FONT SIZE=5> de l'utilisateur qui détermine les divers privilèges donnés au processus, tels que les droits d'accès à un fichier, les changements de priorité, etc.
</FONT>
<DT><FONT SIZE=5>Compteurs des temps</FONT><DD><FONT SIZE=5> (users et system) consommés par le processus
</FONT>
<DT><FONT SIZE=5>Masque de signaux</FONT><DD><FONT SIZE=5> Sur système V sous BSD dans la structure proc
</FONT>
<DT><FONT SIZE=5>Terminal</FONT><DD><FONT SIZE=5> terminal de contrôle du processus si celui-ci existe.
</FONT>
<DT><FONT SIZE=5>erreur</FONT><DD><FONT SIZE=5> stockage de la dernière erreur rencontrée pendant un appel système.
</FONT>
<DT><FONT SIZE=5>retour</FONT><DD><FONT SIZE=5> stockage de valeur de retour du dernier appel système.
</FONT>
<DT><FONT SIZE=5>E/S</FONT><DD><FONT SIZE=5> les structures associées aux entrées-sorties, les paramètres utilisés par la bibliothèque standard, adresses des buffers, tailles et adresses de zones à copier, etc.
</FONT>
<DT><FONT SIZE=5>"." et "/" </FONT><DD><FONT SIZE=5> le répertoire courant et la racine courante (c.f. chroot())
</FONT>
<DT><FONT SIZE=5>la table des descripteurs</FONT><DD><FONT SIZE=5> position variable d'un implémentation à l'autre.
</FONT>
<DT><FONT SIZE=5>limites</FONT><DD><FONT SIZE=5> de la taille des fichiers de la mémoire utilisable etc ¼(c.f. </FONT><FONT SIZE=5><EM>ulimit</EM></FONT><FONT SIZE=5> en Bourne shell et </FONT><FONT SIZE=5><EM>limit</EM></FONT><FONT SIZE=5> en Csh ).
</FONT>
<DT><FONT SIZE=5>umask</FONT><DD><FONT SIZE=5> masque de création de fichiers.
</FONT></DL><FONT SIZE=5>
 
</FONT><FONT SIZE=5>processus!zone u|)</FONT><FONT SIZE=5>
<BR>
<BR>
</FONT><!--TOC section <FONT SIZE=5>Accès aux structures </FONT><FONT SIZE=5><TT>proc</TT></FONT><FONT SIZE=5> et </FONT><FONT SIZE=5><TT>user</TT></FONT><FONT SIZE=5> du processus courant</FONT>-->

<H2><FONT SIZE=5>7.14&nbsp;&nbsp; Accès aux structures </FONT><FONT SIZE=5><TT>proc</TT></FONT><FONT SIZE=5> et </FONT><FONT SIZE=5><TT>user</TT></FONT><FONT SIZE=5> du processus courant</FONT></H2><!--SEC END -->
<FONT SIZE=5>
Les informations de la table des processus peuvent être lues grâce à la commande shell </FONT><FONT SIZE=5><TT>ps</TT></FONT><FONT SIZE=5>. Ou par des appels système.
Par contre, les informations contenues dans la zone u ne sont accessibles que par une réponse du processus lui-même (en progammation objet, on dit que ce sont des variables d'instances privées), d'où les appels système suivants&nbsp;:<BR></FONT><FONT SIZE=5><TT>times, chroot, chdir, fchdir, getuid, getgid, ..., setuid, ..., ulimit, nice, brk, sbrk</TT></FONT><FONT SIZE=5>.<BR>Qui permettent de lire ou de changer le contenu des deux structures.<BR>
<BR>
</FONT><!--TOC subsection <FONT SIZE=5>Les informations temporelles.</FONT>-->

<H3><FONT SIZE=5>7.14.1&nbsp;&nbsp; Les informations temporelles.</FONT></H3><!--SEC END -->
<FONT SIZE=5>
</FONT><PRE><FONT SIZE=5><TT>
#include &lt;sys/times.h&gt;
clock_t times(struct tms *buffer);
</TT></FONT></PRE><FONT SIZE=5> 
</FONT><FONT SIZE=5>appels systèmes!times@</FONT><FONT SIZE=5><TT>times</TT></FONT><FONT SIZE=5>
<BR>
<BR>
</FONT><FONT SIZE=5><EM>times</EM></FONT><FONT SIZE=5> remplit la structure pointée par </FONT><FONT SIZE=5><TT>buffer</TT></FONT><FONT SIZE=5> avec des
informations sur le temps machine utilisé dans les état 1 et 2.<BR>La structure &nbsp;:<BR></FONT><PRE><FONT SIZE=5><TT>
struct tms {
       clock_t    tms_utime;      /* user time */
       clock_t    tms_stime;      /* system time */
       clock_t    tms_cutime;     /* user time, children */
       clock_t    tms_cstime;     /* system time, children */
      };
</TT></FONT></PRE><FONT SIZE=5> contient des temps indiqués en microsecondes 10-6 secondes, la précision de l'horloge est par defaut sur les HP9000 700/800 de 10 microsecondes.<BR>
<BR>
</FONT><!--TOC subsection <FONT SIZE=5>Changement du répertoire racine pour un processus.</FONT>-->

<H3><FONT SIZE=5>7.14.2&nbsp;&nbsp; Changement du répertoire racine pour un processus.</FONT></H3><!--SEC END -->
<PRE><FONT SIZE=5><TT>
#include &lt;unistd.h&gt;
int chroot(const char *path);
</TT></FONT></PRE><FONT SIZE=5> 
</FONT><FONT SIZE=5>appels systèmes!chroot@</FONT><FONT SIZE=5><TT>chroot</TT></FONT><FONT SIZE=5>
<BR>
<BR>
permet de définir un nouveau point de départ pour les
références absolues (commençant par /).
La référence .. de ce répertoire racine est associée à
lui-même, il n'est donc pas possible de sortir du sous-arbre
défini par </FONT><FONT SIZE=5><TT>chroot</TT></FONT><FONT SIZE=5>. Cet appel est utilisé pour rsh et ftp, et
les comptes pour invités.<BR>
<BR>
Les appels suivants permettent de changer le répertoire de travail de
référence ``.'' et donc l'interprétation des références relatives&nbsp;:
</FONT><PRE><FONT SIZE=5><TT>
int chdir(char *ref);
int fchdir(int descripteur);
</TT></FONT></PRE><FONT SIZE=5> 
</FONT><FONT SIZE=5>appels systèmes!chdir@</FONT><FONT SIZE=5><TT>chdir</TT></FONT><FONT SIZE=5>

</FONT><FONT SIZE=5>appels systèmes!fchdir@</FONT><FONT SIZE=5><TT>fchdir</TT></FONT><FONT SIZE=5>
<BR>
<BR>
</FONT><!--TOC subsection <FONT SIZE=5>Récupération du PID d'un processus</FONT>-->

<H3><FONT SIZE=5>7.14.3&nbsp;&nbsp; Récupération du PID d'un processus</FONT></H3><!--SEC END -->
<PRE><FONT SIZE=5><TT>
#include &lt;unistd.h&gt;
pid_t   getpid(void);
pid_t   getpgrp(void);
pid_t   getppid(void);
pid_t   getpgrp2(pid_t pid);
</TT></FONT></PRE><FONT SIZE=5> 
</FONT><FONT SIZE=5>appels systèmes!getpgrp2@</FONT><FONT SIZE=5><TT>getpgrp2</TT></FONT><FONT SIZE=5>

</FONT><FONT SIZE=5>appels systèmes!getppid@</FONT><FONT SIZE=5><TT>getppid</TT></FONT><FONT SIZE=5>

</FONT><FONT SIZE=5>appels systèmes!getpgrp@</FONT><FONT SIZE=5><TT>getpgrp</TT></FONT><FONT SIZE=5>

</FONT><FONT SIZE=5>appels systèmes!getpid@</FONT><FONT SIZE=5><TT>getpid</TT></FONT><FONT SIZE=5>

L'appel </FONT><FONT SIZE=5><TT>getpid()</TT></FONT><FONT SIZE=5> retourne le PID du processus
courant, </FONT><FONT SIZE=5><TT>getppid</TT></FONT><FONT SIZE=5> le PID du processus père, </FONT><FONT SIZE=5><TT>getpgrp</TT></FONT><FONT SIZE=5> le
PID du groupe du processus courant, </FONT><FONT SIZE=5><TT>getpgrp2</TT></FONT><FONT SIZE=5> le PID du groupe du processus pid (si pid=0 alors équivalent à </FONT><FONT SIZE=5><TT>getpgrp</TT></FONT><FONT SIZE=5>).<BR>
<BR>
</FONT><!--TOC subsection <FONT SIZE=5>Positionement de l'euid, ruid et suid</FONT>-->

<H3><FONT SIZE=5>7.14.4&nbsp;&nbsp; Positionement de l'euid, ruid et suid</FONT></H3><!--SEC END -->
<FONT SIZE=5>L'uid d'un processus est l'identification de l'utilisateur exécutant le processus. Le système utilise trois uid qui sont&nbsp;:<BR>
<BR>
</FONT><DL COMPACT=compact>
<DT><FONT SIZE=5> 
</FONT><FONT SIZE=5>euid</FONT><DD><FONT SIZE=5> uid effective utilisé pour les tests d'accès.
</FONT>
<DT><FONT SIZE=5>ruid</FONT><DD><FONT SIZE=5> uid réelle, uid à qui est facturé le temps de calcul.
</FONT>
<DT><FONT SIZE=5>suid</FONT><DD><FONT SIZE=5> uid sauvegardée, pour pouvoir revenir en arrière après un setuid.
</FONT></DL><PRE><FONT SIZE=5><TT>
#include &lt;unistd.h&gt;
int setuid(uid_t uid);
int setgid(gid_t gid);
</TT></FONT></PRE><FONT SIZE=5> 
</FONT><FONT SIZE=5>appels systèmes!setgid@</FONT><FONT SIZE=5><TT>setgid</TT></FONT><FONT SIZE=5>

</FONT><FONT SIZE=5>appels systèmes!setuid@</FONT><FONT SIZE=5><TT>setuid</TT></FONT><FONT SIZE=5>
<BR>
<BR>
Fonctionnement&nbsp;:<BR>si euid == 0 (euid de root) les trois uid sont positionnés à la valeur de uid<BR>sinon si uid est égal à ruid ou suid alors euid devient uid. ruid et suid ne changent pas.
sinon rien! pas de changements.<BR>Syntaxe identique pour setgid et gid.<BR>
<BR>
La commande </FONT><FONT SIZE=5><EM>setreuid()</EM></FONT><FONT SIZE=5> permet de changer le propiétaire réel du processus, elle est utilisé pendant le login, seul le super utilisateur peut l'exécuter avec succès.<BR>
<BR>
</FONT><!--TOC section <FONT SIZE=5>Tailles limites d'un processus</FONT>-->

<H2><FONT SIZE=5>7.15&nbsp;&nbsp; Tailles limites d'un processus</FONT></H2><!--SEC END -->
<PRE><FONT SIZE=5><TT>
#include &lt;ulimit.h&gt;
long ulimit(int cmd,...);
</TT></FONT></PRE><FONT SIZE=5> 
</FONT><FONT SIZE=5>appels systèmes!ulimit@</FONT><FONT SIZE=5><TT>ulimit</TT></FONT><FONT SIZE=5>
<BR>
<BR>
La commande </FONT><FONT SIZE=5><EM>cmd</EM></FONT><FONT SIZE=5> est
</FONT><DL COMPACT=compact>
<DT><FONT SIZE=5> 
</FONT><FONT SIZE=5>UL_GETFSIZE</FONT><DD><FONT SIZE=5> retourne le taille maximum des fichiers en blocs.
</FONT>
<DT><FONT SIZE=5>UL_SETFSIZE</FONT><DD><FONT SIZE=5> positionne cette valeur avec le deuxième argument. 
</FONT>
<DT><FONT SIZE=5>UL_GETMAXBRK</FONT><DD><FONT SIZE=5> valeur maximale pour l'appel d'allocation dynamique de mémoire&nbsp;: brk.
 </FONT></DL><FONT SIZE=5>
Ces valeurs sont héritées du processus père.<BR>
<BR>
La valeur FSIZE (taille maximum des fichiers sur disques en blocs) peut être changée en ksh avec ulimit [n].<BR>
<BR>
</FONT><!--TOC subsection <FONT SIZE=5>Manipulation de la taille d'un processus.</FONT>-->

<H3><FONT SIZE=5>7.15.1&nbsp;&nbsp; Manipulation de la taille d'un processus.</FONT></H3><!--SEC END -->
<PRE><FONT SIZE=5><TT>
#include &lt;unistd.h&gt;
int brk(const void *endds);
void *sbrk(int incr);
</TT></FONT></PRE><FONT SIZE=5> 
</FONT><FONT SIZE=5>appels systèmes!brk@</FONT><FONT SIZE=5><TT>brk</TT></FONT><FONT SIZE=5>

</FONT><FONT SIZE=5>appels systèmes!sbrk@</FONT><FONT SIZE=5><TT>sbrk</TT></FONT><FONT SIZE=5>

Les deux appels permettent de changer la taille du processus.
L'adresse manipulée par les deux appels est la première adresse qui est en dehors du processus.
Ainsi on réalise des augmentations de la taille du processus avec des appels à </FONT><FONT SIZE=5><TT>sbrk</TT></FONT><FONT SIZE=5> et on utilise les adresses retournées par </FONT><FONT SIZE=5><TT>sbrk</TT></FONT><FONT SIZE=5> pour les appels à </FONT><FONT SIZE=5><TT>brk</TT></FONT><FONT SIZE=5> pour réduire la taille du processus.
On utilisera de préférence pour les appels à </FONT><FONT SIZE=5><TT>sbrk</TT></FONT><FONT SIZE=5> des valeurs de </FONT><FONT SIZE=5><TT>incr</TT></FONT><FONT SIZE=5> qui sont des multiples de la taille de page. Le système réalisant des déplacement du point de rupture par nombre entier de pages (ce qui est logique dans un système de mémoire paginé).
A ne pas utiliser en conjonction avec les fonctions d'allocation standard </FONT><FONT SIZE=5><TT>malloc, calloc, realloc, free</TT></FONT><FONT SIZE=5>.<BR>
<BR>
</FONT><!--TOC subsection <FONT SIZE=5>Manipulation de la valeur nice</FONT>-->

<H3><FONT SIZE=5>7.15.2&nbsp;&nbsp; Manipulation de la valeur nice</FONT></H3><!--SEC END -->
<FONT SIZE=5>Permet de changer la valeur de </FONT><FONT SIZE=5><EM>nice</EM></FONT><FONT SIZE=5> utilisée par le processus. Si l'on
a des droits privilégiés la valeur peut être négative. La valeur de
nice est toujours comprise entre 0 et 39.
</FONT><PRE><FONT SIZE=5><TT>
#include &lt;unistd.h&gt;
int  nice(int valeur);
</TT></FONT></PRE><FONT SIZE=5>
</FONT><FONT SIZE=5>appels systèmes!nice@</FONT><FONT SIZE=5><TT>nice</TT></FONT><FONT SIZE=5>
<BR>
<BR>
La commande shell </FONT><FONT SIZE=5><TT>renice</TT></FONT><FONT SIZE=5> permet de changer le nice d'un
processus actif.<BR>
<BR>
</FONT><!--TOC subsection <FONT SIZE=5>Manipulation de la valeur umask</FONT>-->

<H3><FONT SIZE=5>7.15.3&nbsp;&nbsp; Manipulation de la valeur umask</FONT></H3><!--SEC END -->
<FONT SIZE=5>L'appel </FONT><FONT SIZE=5><TT>umask </TT></FONT><FONT SIZE=5> permet de spécifier quels droits doivent être
interdits en cas de création de fichier. cf. </FONT><A HREF="#open"><FONT SIZE=5>6.1</FONT></A><FONT SIZE=5>
</FONT><PRE><FONT SIZE=5><TT>
#include &lt;sys/stat.h&gt;
mode_t umask(mode_t mask);
</TT></FONT></PRE><FONT SIZE=5>
</FONT><FONT SIZE=5>appels systèmes!umask@</FONT><FONT SIZE=5><TT>umask</TT></FONT><FONT SIZE=5>

la valeur retournée est l'ancienne valeur.<BR>
<BR>
</FONT><!--TOC section <FONT SIZE=5>L'appel système </FONT><FONT SIZE=5><TT>fork</TT></FONT>-->

<H2><FONT SIZE=5>7.16&nbsp;&nbsp; L'appel système </FONT><FONT SIZE=5><TT>fork</TT></FONT></H2><!--SEC END -->
<FONT SIZE=5>l'appel système </FONT><FONT SIZE=5><TT>fork</TT></FONT><FONT SIZE=5> permet le création d'un processus clône du processus courrant.
</FONT><PRE><FONT SIZE=5><TT>
pid_t  fork(void);
</TT></FONT></PRE><FONT SIZE=5> 
</FONT><FONT SIZE=5>appels systèmes!fork@</FONT><FONT SIZE=5><TT>fork</TT></FONT><FONT SIZE=5>
<BR>
<BR>
</FONT><FONT SIZE=5><B>DEUX</B></FONT><FONT SIZE=5> valeurs de retour en cas de succès&nbsp;:
</FONT><UL>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5> Dans le processus père valeur de retour = le PID du fils,
</FONT>
<LI><FONT SIZE=5> Dans le processus fils valeur de retour = zéro.
</FONT></UL><FONT SIZE=5>
Sinon 
</FONT><UL>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5> Dans le processus père valeur de retour = -1.
</FONT></UL><FONT SIZE=5>Les </FONT><FONT SIZE=5><TT>PID</TT></FONT><FONT SIZE=5> et </FONT><FONT SIZE=5><TT>PPID</TT></FONT><FONT SIZE=5> sont les seules informations différentes entre les deux processus.<BR>
<BR>
</FONT><!--TOC section <FONT SIZE=5>L'appel système </FONT><FONT SIZE=5><TT>exec</TT></FONT>-->

<H2><FONT SIZE=5>7.17&nbsp;&nbsp; L'appel système </FONT><FONT SIZE=5><TT>exec</TT></FONT></H2><!--SEC END -->
<FONT SIZE=5>
</FONT><PRE><FONT SIZE=5><TT>
#include &lt;unistd.h&gt;
extern char **environ;

int execl( const char *path, const char *arg0, ...,NULL);
int execv(const char *path, char * const argv[]);
int execle( const char *path, const char *arg0, ...,NULL,  char * const envp[]);

int execve(const char *file, char * const argv[], char * const envp[]);
int execlp( const char *file,const char *arg0, ... , NULL );
int execvp(const char *file, char * const argv[]);

</TT></FONT></PRE><FONT SIZE=5> 
</FONT><FONT SIZE=5>appels systèmes!execv@</FONT><FONT SIZE=5><TT>execv</TT></FONT><FONT SIZE=5>

</FONT><FONT SIZE=5>appels systèmes!execvp@</FONT><FONT SIZE=5><TT>execvp</TT></FONT><FONT SIZE=5>

</FONT><FONT SIZE=5>appels systèmes!execlp@</FONT><FONT SIZE=5><TT>execlp</TT></FONT><FONT SIZE=5>

</FONT><FONT SIZE=5>appels systèmes!execve@</FONT><FONT SIZE=5><TT>execve</TT></FONT><FONT SIZE=5>

</FONT><FONT SIZE=5>appels systèmes!execle@</FONT><FONT SIZE=5><TT>execle</TT></FONT><FONT SIZE=5>
<BR>
<BR>
Informations conservées par le processus&nbsp;: PID PPID PGID ruid
suid (pour l'euid cf le </FONT><FONT SIZE=5><TT>setuidbit </TT></FONT><FONT SIZE=5> de </FONT><FONT SIZE=5><TT>chmod </TT></FONT><FONT SIZE=5>), nice,
groupe d'accès, catalogue courant, catalogue ``/'', terminal de
contrôle, utilisation et limites des ressources
(temps machine, mémoire, etc), umask, masques des signaux, signaux en
attente, table des descripteurs de fichiers, verrous, session.<BR>
<BR>
Quand le processus exécute dans le nouvel exécutable la fonction&nbsp;:
</FONT><PRE><FONT SIZE=5><TT>
 main(int argc, char **argv,char **envp)
</TT></FONT></PRE><FONT SIZE=5> </FONT><FONT SIZE=5><EM>argv</EM></FONT><FONT SIZE=5> et </FONT><FONT SIZE=5><EM>env</EM></FONT><FONT SIZE=5> sont ceux qui ont été utilisés
dans l'appel de </FONT><FONT SIZE=5><TT>execve</TT></FONT><FONT SIZE=5>.<BR>
</FONT><FONT SIZE=5>appels systèmes!execve@</FONT><FONT SIZE=5><TT>execve</TT></FONT><FONT SIZE=5>
<BR>
<BR>
Les différents noms des fonction </FONT><FONT SIZE=5><TT>exec</TT></FONT><FONT SIZE=5> sont des mnémoniques&nbsp;:
</FONT><DL COMPACT=compact>
<DT><FONT SIZE=5>
</FONT><FONT SIZE=5><TT>l</TT></FONT><DD><FONT SIZE=5> liste d'arguments
</FONT>
<DT><FONT SIZE=5><TT>v</TT></FONT><DD><FONT SIZE=5> arguments sont forme d'un vecteur.
</FONT>
<DT><FONT SIZE=5><TT>p</TT></FONT><DD><FONT SIZE=5> recherche du fichier avec la variable d'environnement </FONT><FONT SIZE=5><TT>PATH</TT></FONT><FONT SIZE=5>.
</FONT>
<DT><FONT SIZE=5><TT>e</TT></FONT><DD><FONT SIZE=5> transmission d'un environnement en dernier paramètre, en remplacement de l'environnement courant.
</FONT></DL><FONT SIZE=5>
</FONT><!--BEGIN NOTES chapter-->
<HR WIDTH="50%" SIZE=1><DL>
<DT><A NAME="note6" HREF="#text6"><FONT SIZE=5><FONT SIZE=5>1</FONT></FONT></A><DD><FONT SIZE=5> swappeur,gestionnaire de pages
</FONT>
<DT><A NAME="note7" HREF="#text7"><FONT SIZE=5><FONT SIZE=5>2</FONT></FONT></A><DD><FONT SIZE=5> Bien que le processus soit prêt, il est
 retiré de l'unité de traitement pour que les autres processus
 puissent avancer.
</FONT>
<DT><A NAME="note8" HREF="#text8"><FONT SIZE=5><FONT SIZE=5>3</FONT></FONT></A><DD><FONT SIZE=5> Exercice&nbsp;: Donner un
exemple.
</FONT></DL>
<!--END NOTES-->
<!--TOC chapter <FONT SIZE=5>L'ordonnancement des processus</FONT>-->

<H1><FONT SIZE=5>Chapitre&nbsp;8&nbsp;&nbsp; L'ordonnancement des processus</FONT></H1><!--SEC END -->
<FONT SIZE=5>ordonnancement</FONT><FONT SIZE=5>
La sélection dans le temps des processus pouvant accèder à une
ressource est un problème dit d'ordonnancement. Nous présentons ici&nbsp;:
</FONT><UL>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5> le cas général
</FONT>
<LI><FONT SIZE=5> les besoins et les problèmes
</FONT></UL><FONT SIZE=5>
et nous décrirons des solutions que l'on trouve sous UNIX pour
différents problèmes d'ordonnancement.<BR>
<BR>
Les algorithmes d'ordonnancement réalisent la sélection parmi les processus actifs de celui qui va obtenir l'utilisation d'une ressource, que ce soit l'unité centrale, ou bien un périphérique d'entrée-sortie.<BR>
<BR>
Pour l'unité centrale notre but est de maximiser débit et taux
utile de l'unité centrale&nbsp;:
</FONT><DL COMPACT=compact>
<DT><FONT SIZE=5>
</FONT><FONT SIZE=5>le débit</FONT><DD><FONT SIZE=5> est le nombre moyen de processus exécutés en un temps donné.</FONT><BR>
<BR>

<DT><FONT SIZE=5>le taux utile</FONT><DD><FONT SIZE=5> est la proportion de temps réellement utilisée pour exécuter des processus utilisateurs.
</FONT></DL><FONT SIZE=5>Un exemple&nbsp;:<BR>Soient 2 processus A et B de même comportement 
30 périodes de deux seconde&nbsp;:<BR>1 seconde d'activité<BR>1 seconde d'inactivité<BR></FONT><PRE><FONT SIZE=5><TT>
AIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAI
</TT></FONT></PRE><FONT SIZE=5> Si l'on exécute les deux processus consécutivement on obtient un débit de 1 processus par minute, et un taux utile de 50%.
Si l'on entrelace les périodes actives et inactives des deux processus on obtient un débit de 2 processus par minute et un taux d'utilisation de 100%.<BR>
<BR>
Pour une autre ressource d'autres critères seront utilisés.<BR>
<BR>
</FONT><!--TOC section <FONT SIZE=5>Le partage de l'unité centrale</FONT>-->

<H2><FONT SIZE=5>8.1&nbsp;&nbsp; Le partage de l'unité centrale</FONT></H2><!--SEC END -->
<FONT SIZE=5>Ce partage doit être fait non seulement entre les processus
utilisateurs mais aussi entre les différentes tâches du
système, scheduler, entrées-sorties, gestion des
interruptions, etc.<BR>
<BR>
Nous demandons de plus à l'algorithme d'ordonnancement de nous assurer </FONT><FONT SIZE=5><B>l'exclusion mutuelle</B></FONT><FONT SIZE=5> et </FONT><FONT SIZE=5><B>l'absence de famine</B></FONT><FONT SIZE=5>, qui sont les points-clefs de la plupart des problèmes d'ordonnancement.
</FONT><FONT SIZE=5>exclusion mutuelle</FONT><FONT SIZE=5>famine</FONT><FONT SIZE=5>
L'invention d'un algorithme d'ordonnancement se base en générale sur
des remarques statistique sur le comportement des processus&nbsp;:
</FONT><UL>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5> Le couple UC/ES (cpu/io), les processus ont tendance à basculer constamment entre des phases d'entrées-sorties et des phases de calcul sur l'unité centrale. </FONT><BR>
<BR>

<LI><FONT SIZE=5> Les processus consommant de longues périodes d'U.C. sont
proportionnellement rares.
</FONT></UL><FONT SIZE=5>
</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML039.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 8.1&nbsp;: Histogramme de répartition de la durée de la période d'utilisation de l'unité centrale</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="histogramme"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>
</FONT><!--TOC subsection <FONT SIZE=5>Famine</FONT>-->

<H3><FONT SIZE=5>8.1.1&nbsp;&nbsp; Famine</FONT></H3><!--SEC END -->
<FONT SIZE=5>
Notre première tâche est d'affecter une ressource (l'UC par exemple) à un unique processus à la fois (exclusion mutuelle) et s'assurer de l'absence de famine.<BR>
<BR>
</FONT><FONT SIZE=5><B>famine</B></FONT><FONT SIZE=5>&nbsp;: un processus peut se voir refuser l'accès à une ressource pendant un temps indéterminé, il est dit alors que le processus est en famine. <BR>
<BR>
Un système qui ne crée pas de cas de famine&nbsp;: fournira toujours la ressource demandée par un processus, au bout d'un temps fini.<BR>
<BR>
Si on prend le cas des périphériques (tels que les disques) l'ordonnancement peut se faire de façon simple avec par exemple une file d'attente (FIFO).<BR>
<BR>
Pour l'unité centrale on va devoir utiliser des structures de données plus complexes car nous allons avoir besoin de gérer des priorités. C'est par exemple, autoriser l'existence de processus qui évitent la file d'attente.
La structure de données utilisée peut parfaitement être une file, une liste, un arbre ou un tas, ceci en fonction de l'élément-clef de notre algorithme de sélection (âge, priorité simple, priorité à plusieurs niveaux, etc).<BR>
<BR>
Cette structure de données doit nous permettre d'accéder à tous les processus prêts (éligibles).<BR>
<BR>
</FONT><!--TOC subsection <FONT SIZE=5>Stratégie globale</FONT>-->

<H3><FONT SIZE=5>8.1.2&nbsp;&nbsp; Stratégie globale</FONT></H3><!--SEC END -->
<FONT SIZE=5>
On peut représenter l'ordonnancement global avec le schéma </FONT><A HREF="#courlong"><FONT SIZE=5>8.2</FONT></A><FONT SIZE=5>

</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML040.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 8.2&nbsp;: Stratégie globale d'ordonnancement.</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="courlong"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>
Les ordonnancements à court terme doivent être très
rapides, en effet le processus élu ne va utiliser l'unité
centrale que pendant un très court laps de temps (
10 milli-secondes par exemple). Si on utilise trop de temps (1
milli-seconde) pour sélectionner cet élu, le taux utile décroît très rapidement (ici on perd 9% du temps d'unité centrale).<BR>
<BR>
Par contre l'ordonnancement à long terme peut être plus long
car il a lieu moins souvent (toutes les secondes par exemple). 
La conception de l'ordonnanceur à long terme est faite dans l'optique d'obtenir un ordonnanceur à court terme rapide.<BR>
<BR>
</FONT><!--TOC subsection <FONT SIZE=5>Critères de performance </FONT>-->

<H3><FONT SIZE=5>8.1.3&nbsp;&nbsp; Critères de performance </FONT></H3><!--SEC END -->
<FONT SIZE=5><B>Les critères de performance des algorithmes d'ordonnancement</B></FONT><FONT SIZE=5>
</FONT><UL>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5> Taux d'utilisation de l'unité centrale
</FONT>
<LI><FONT SIZE=5> Débit 
</FONT>
<LI><FONT SIZE=5> Temps réel d'exécution
</FONT>
<LI><FONT SIZE=5> Temps d'attente 
</FONT>
<LI><FONT SIZE=5> Temps de réponse 
</FONT></UL><FONT SIZE=5><B>Ces cinq critères sont plus ou moins mutuellement exclusifs.</B></FONT><BR>
<BR>
<FONT SIZE=5>Les comparaisons des différents algorithmes se fait donc sur une sélection de ces critères.<BR>
<BR>
</FONT><!--TOC section <FONT SIZE=5>Ordonnancement sans préemption.</FONT>-->

<H2><FONT SIZE=5>8.2&nbsp;&nbsp; Ordonnancement sans préemption.</FONT></H2><!--SEC END -->
<UL>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5> FCFS&nbsp;: First Come First served<BR>Facile à écrire et à comprendre, peu efficace ...</FONT><FONT SIZE=5>FCFS</FONT><BR>
<BR>

<LI><FONT SIZE=5> SJF&nbsp;: Shortest Job First<BR>le plus petit en premier.<BR>Optimal pour le temps d'attente moyen ...</FONT><FONT SIZE=5>SJF</FONT><BR>
<BR>

<LI><FONT SIZE=5> A priorité&nbsp;:<BR>L'utilisateur donne des priorités aux différents processus
 et ils sont activés en fonction de cette priorité.<BR> problème </FONT><FONT SIZE=5><FONT FACE=symbol>¾®</FONT></FONT><FONT SIZE=5> famine possible des processus peu prioritaires<BR> Solution </FONT><FONT SIZE=5><FONT FACE=symbol>¾®</FONT></FONT><FONT SIZE=5> faire augmenter la priorité avec le temps d'attente&nbsp;:<BR>plus un processus attend, plus sa priorité augmente ainsi au bout d'un certain temps le processus devient nécessairement le plus prioritaire.<BR>
<BR>
 re-problème </FONT><FONT SIZE=5><FONT FACE=symbol>¾®</FONT></FONT><FONT SIZE=5> si le processus en question (le
 très vieux très gros) est exécuté alors que de
 nombreux utilisateurs sont en mode interactif chute catastrophique du
 temps de réponse et du débit<BR> solution </FONT><FONT SIZE=5><FONT FACE=symbol>¾®</FONT></FONT><FONT SIZE=5> préemption.<BR></FONT></UL><FONT SIZE=5>
</FONT><FONT SIZE=5>préemption</FONT><FONT SIZE=5>
La </FONT><FONT SIZE=5><B>préemption</B></FONT><FONT SIZE=5> est la possibilité qu'a le système de
reprendre une ressource à un processus sans que celui-ci ait libéré cette ressource.<BR>Ceci est impossible sur bon nombre de ressources. Lesquelles ? <BR>
<BR>
</FONT><!--TOC section <FONT SIZE=5>Les algorithmes préemptifs</FONT>-->

<H2><FONT SIZE=5>8.3&nbsp;&nbsp; Les algorithmes préemptifs</FONT></H2><!--SEC END -->
<FONT SIZE=5>FCFS ne peut être préemptif ...<BR>SJF peut être préemptif&nbsp;: si un processus plus court que le processus actif arrive dans la queue, le processus actif est préempté.<BR>
<BR>
Dans des systèmes interactifs en temps partagé un des critères
est le temps de réponse, c'est à dire que chaque utilisateur dispose de l'unité centrale régulièrement. Heureusement, les processus interactifs utilisent l'UC pendant de très courts intervalles à chaque fois.<BR>
<BR>
</FONT><!--TOC subsection <FONT SIZE=5>Round Robin (tourniquet)</FONT>-->

<H3><FONT SIZE=5>8.3.1&nbsp;&nbsp; Round Robin (tourniquet)</FONT></H3><!--SEC END -->
<FONT SIZE=5>
</FONT><FONT SIZE=5>Round Robin</FONT><FONT SIZE=5>
Cet algorithme est spécialement adapté aux systèmes en temps partagé. <BR>On définit un </FONT><FONT SIZE=5><B>quantum de temps</B></FONT><FONT SIZE=5> (time quantum) d'utilisation de l'unité centrale.<BR>La file d'attente des processus éligibles est vue comme une queue circulaire (fifo circulaire).<BR>Tout nouveau processus est placé à la fin de la liste.<BR>
<BR>
De deux choses l'une, soit le processus actif rend l'Unité Centrale avant la fin de sa tranche de temps (pour cause d'entrée/sortie) soit il est préempté, et dans les deux cas placé en fin de liste.<BR>
<BR>
Un processus obtiendra le processeur au bout de (n -1)*q secondes au plus (n nombre de processus et q longueur du quantum de temps), la famine est donc assurément évitée.<BR>
<BR>
Remarquons que si le quantum de temps est trop grand, round-robin devient équivalent à FCFS. De l'autre coté si le quantum de temps est très court, nous avons théoriquement un processeur n fois moins rapide pour chaque processus (n nombre de processus).<BR>
<BR>
Malheureusement si le quantum de temps est court, le nombre de changements de contexte dûs à la préemption grandit, d'où une diminution du taux utile, d'où un processeur virtuel très lent.<BR>
<BR>
Une règle empirique est d'utiliser un quantum de temps tel que 80% des processus interrompent naturellement leur utilisation de l'unité centrale avant l'expiration du quantum de temps.<BR>
<BR>
</FONT><!--TOC subsection <FONT SIZE=5>Les algorithmes à queues multiples</FONT>-->

<H3><FONT SIZE=5>8.3.2&nbsp;&nbsp; Les algorithmes à queues multiples</FONT></H3><!--SEC END -->
<FONT SIZE=5>Nous supposons que nous avons un moyen de différencier facilement
les processus en plusieurs classes de priorité différentes
(c'est le cas sous UNIX où nous allons différencier les tâches
système, comme le swappeur, des autres tâches).<BR>
<BR>
Pour sélectionner un processus, le scheduler parcourt
successivement les queues dans l'ordre décroissant des
priorités.<BR>Un exemple de queues organisées en fonction du contenu des processus&nbsp;: 
</FONT><UL>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5> les processus systèmes
</FONT>
<LI><FONT SIZE=5> les processus interactifs
</FONT>
<LI><FONT SIZE=5> les processus édition
</FONT>
<LI><FONT SIZE=5> les processus gros calcul
</FONT>
<LI><FONT SIZE=5> les processus des étudiants
</FONT></UL><FONT SIZE=5>
pour qu'un processus étudiant soit exécuté il faut que toutes les autres files d'attente soient vides ...<BR>Une autre possibilité est de partager les quantums de temps sur les différentes queues.<BR>Il est aussi possible de réaliser différents algorithmes de
scheduling sur les différentes queues&nbsp;: 
</FONT><UL>
<LI><FONT SIZE=5>
 </FONT><FONT SIZE=5> Round Robin sur les processus interactifs
 </FONT>
<LI><FONT SIZE=5> FCFS sur les gros calculs en tâche de fond.
</FONT></UL><!--TOC section <FONT SIZE=5>Multi-level-feedback round robin Queues</FONT>-->

<H2><FONT SIZE=5>8.4&nbsp;&nbsp; Multi-level-feedback round robin Queues</FONT></H2><!--SEC END -->
<FONT SIZE=5>Le système d'ordonnancement des processus sous UNIX (BSD 4.3 et
system V4) utilise plusieurs files d'attente qui vont
matérialiser des niveaux de priorité différents et à
l'intérieur de ces différents niveaux de priorité, un
système de tourniquet.<BR>
<BR>

</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML041.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 8.3&nbsp;: Les queues multiples en tourniquet </FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="multilevel"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>
</FONT><!--TOC subsection <FONT SIZE=5>Les niveaux de priorité</FONT>-->

<H3><FONT SIZE=5>8.4.1&nbsp;&nbsp; Les niveaux de priorité</FONT></H3><!--SEC END -->
<FONT SIZE=5>
Le scheduler parcourt les listes une par une de haut en bas jusqu'à trouver une liste contenant un processus éligible.
Ainsi tant qu'il y a des processus de catégorie supérieure à exécuter les autres processus sont en attente de l'unité centrale.<BR>
<BR>
Dans les listes internes au noyau, de simples files d'attente sont utilisées avec la possibilité de doubler les processus endormis de la même liste (en effet seul le processus réveillé par la fin de son entrée/sortie est éligible).<BR>
<BR>
Pour les processus utilisateurs, la même règle est utilisée mais avec préemption et la règle du tourniquet.<BR>
<BR>
C'est à dire, on calcul une priorité de base qui est utilisée pour placer le processus dans la bonne file d'attente.<BR>
<BR>
Un processus qui utilise l'unité centrale voit augmenter sa priorité.<BR>Un processus qui libère l'unité centrale pour demander une entrée/sortie ne voit pas sa priorité changer.<BR>Un processus qui utilise tout sont quantum de temps est préempté et placé dans une nouvelle file d'attente.<BR></FONT><FONT SIZE=5><B>Attention&nbsp;: plus la priorité est grande moins le processus est prioritaire.</B></FONT><FONT SIZE=5>
</FONT><FONT SIZE=5>priorité</FONT><FONT SIZE=5>
</FONT><!--TOC subsection <FONT SIZE=5>Evolution de la priorité</FONT>-->

<H3><FONT SIZE=5>8.4.2&nbsp;&nbsp; Evolution de la priorité</FONT></H3><!--SEC END -->
<FONT SIZE=5>
Regardons la priorité et l'évolution de la priorité d'un processus utilisateur au cours du temps. Les fonctions suivantes sont utilisées dans une implémentation BSD.<BR>
<BR>
Pour calculer la priorité d'un processus utilisateur, le scheduler utilise l'équation suivante qui est calculée tous les 4 clicks horloge (valeur pratique empirique)&nbsp;:<BR>
<BR>
</FONT><DIV ALIGN=center><TABLE CELLSPACING=0 CELLPADDING=0>
<TR VALIGN=middle><TD NOWRAP><FONT SIZE=5> <I>P</I></FONT></TD>
<TD NOWRAP><TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD><FONT SIZE=5>&nbsp;</FONT></TD>
</TR>
<TR><TD NOWRAP><FONT SIZE=2>&nbsp;usrpri</FONT></TD>
</TR></TABLE></TD>
<TD NOWRAP><FONT SIZE=5> = </FONT><FONT SIZE=5>PUSER</FONT><FONT SIZE=5> + </FONT></TD>
<TD NOWRAP><TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD NOWRAP ALIGN=center><TABLE CELLSPACING=0 CELLPADDING=0>
<TR VALIGN=middle><TD NOWRAP><FONT SIZE=5><I>P</I></FONT></TD>
<TD NOWRAP><TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD><FONT SIZE=5>&nbsp;</FONT></TD>
</TR>
<TR><TD NOWRAP><FONT SIZE=2>&nbsp;cpu</FONT></TD>
</TR></TABLE></TD>
</TR></TABLE></TD>
</TR>
<TR><TD BGCOLOR=black><TABLE BORDER=0 WIDTH="100%" CELLSPACING=0 CELLPADING=1><TR><TD></TD></TR></TABLE></TD>
</TR>
<TR><TD NOWRAP ALIGN=center><FONT SIZE=5>4</FONT></TD>
</TR></TABLE></TD>
<TD NOWRAP><FONT SIZE=5> + 2 × <I>P</I></FONT></TD>
<TD NOWRAP><TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD><FONT SIZE=5>&nbsp;</FONT></TD>
</TR>
<TR><TD NOWRAP><FONT SIZE=2>&nbsp;nice</FONT></TD>
</TR></TABLE></TD>
</TR></TABLE></DIV><BR>
<FONT SIZE=5>cette valeur est tronquée à l'intervalle PUSER..127.
En fonction de cette valeur le processus est placé dans une des
listes correspondant à son niveau courant de priorité.<BR>
<BR>
Ceci nous donne une priorité qui diminue linéairement en fonction de l'utilisation de l'unité centrale (il advient donc un moment où le processus devient le processus le plus prioritaire!).<BR>
<BR>
</FONT><FONT SIZE=5><I>P</I></FONT><SUB><FONT SIZE=2>&nbsp;nice</FONT></SUB><FONT SIZE=5> est une valeur spécifiée par le programmeur grâce à l'appel système </FONT><FONT SIZE=5><TT>nice</TT></FONT><FONT SIZE=5>. Elle varie entre -20 et +20 et seul le super utilisateur peut spécifier une valeur négative.<BR>
<BR>
</FONT><FONT SIZE=5><I>P</I></FONT><SUB><FONT SIZE=2>&nbsp;cpu</FONT></SUB><FONT SIZE=5> donne une estimation du temps passé par un processus sur l'unité centrale. A chaque click d'horloge, la variable </FONT><FONT SIZE=5><TT>p_cpu</TT></FONT><FONT SIZE=5> du processus actif est incrémentée.
Ce qui permet de matérialiser la consommation d'unité central du processus.
Pour que cette valeur ne devienne pas trop pénalisante sur le long terme (comme pour un shell) elle est atténuée toute les secondes grâce à la formule suivante&nbsp;:<BR>
<BR>
</FONT><DIV ALIGN=center><TABLE CELLSPACING=0 CELLPADDING=0>
<TR VALIGN=middle><TD NOWRAP><FONT SIZE=5> <I>P</I></FONT></TD>
<TD NOWRAP><TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD><FONT SIZE=5>&nbsp;</FONT></TD>
</TR>
<TR><TD NOWRAP><FONT SIZE=2>&nbsp;cpu</FONT></TD>
</TR></TABLE></TD>
<TD NOWRAP><FONT SIZE=5> = </FONT></TD>
<TD NOWRAP><TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD NOWRAP ALIGN=center><FONT SIZE=5>2 × </FONT><FONT SIZE=5>load</FONT></TD>
</TR>
<TR><TD BGCOLOR=black><TABLE BORDER=0 WIDTH="100%" CELLSPACING=0 CELLPADING=1><TR><TD></TD></TR></TABLE></TD>
</TR>
<TR><TD NOWRAP ALIGN=center><FONT SIZE=5>2 × </FONT><FONT SIZE=5>load</FONT><FONT SIZE=5> + 1</FONT></TD>
</TR></TABLE></TD>
<TD NOWRAP><FONT SIZE=5> × <I>P</I></FONT></TD>
<TD NOWRAP><TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD><FONT SIZE=5>&nbsp;</FONT></TD>
</TR>
<TR><TD NOWRAP><FONT SIZE=2>&nbsp;cpu</FONT></TD>
</TR></TABLE></TD>
<TD NOWRAP><FONT SIZE=5>
 + <I>P</I></FONT></TD>
<TD NOWRAP><TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD><FONT SIZE=5>&nbsp;</FONT></TD>
</TR>
<TR><TD NOWRAP><FONT SIZE=2>&nbsp;nice</FONT></TD>
</TR></TABLE></TD>
</TR></TABLE></DIV><BR>
<FONT SIZE=5>la valeur de </FONT><FONT SIZE=5><TT>load</TT></FONT><FONT SIZE=5> (la charge) est calculée sur une moyenne du nombre de processus actifs pendant une minute.<BR>
<BR>
Pour ne pas utiliser trop de ressources, les processus qui sont en sommeil (sleep)
voient leur </FONT><FONT SIZE=5><I>P</I></FONT><SUB><FONT SIZE=2>&nbsp;cpu</FONT></SUB><FONT SIZE=5> recalculé uniquement à la fin de leur période de sommeil grâce à la formule&nbsp;:<BR>
<BR>
</FONT><DIV ALIGN=center><TABLE CELLSPACING=0 CELLPADDING=0>
<TR VALIGN=middle><TD NOWRAP><FONT SIZE=5> <I>P</I></FONT></TD>
<TD NOWRAP><TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD><FONT SIZE=5>&nbsp;</FONT></TD>
</TR>
<TR><TD NOWRAP><FONT SIZE=2>&nbsp;cpu</FONT></TD>
</TR></TABLE></TD>
<TD NOWRAP><FONT SIZE=5> = </FONT></TD>
<TD NOWRAP><FONT SIZE=5><FONT FACE=symbol>
æ<BR>ç<BR>ç<BR>è</FONT></FONT></TD>
<TD NOWRAP><TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD NOWRAP ALIGN=center><FONT SIZE=5>2 × </FONT><FONT SIZE=5>load</FONT></TD>
</TR>
<TR><TD BGCOLOR=black><TABLE BORDER=0 WIDTH="100%" CELLSPACING=0 CELLPADING=1><TR><TD></TD></TR></TABLE></TD>
</TR>
<TR><TD NOWRAP ALIGN=center><FONT SIZE=5>2 ×
 </FONT><FONT SIZE=5>load</FONT><FONT SIZE=5> + 1</FONT></TD>
</TR></TABLE></TD>
<TD NOWRAP><FONT SIZE=5><FONT FACE=symbol>
ö<BR>÷<BR>÷<BR>ø</FONT></FONT></TD>
<TD NOWRAP><TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=2>&nbsp;sleep_time</FONT></TD>
</TR>
<TR><TD ALIGN=left><FONT SIZE=5><BR><BR><BR></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=4>&nbsp;</FONT></TD>
</TR></TABLE></TD>
<TD NOWRAP><FONT SIZE=5>× <I>P</I></FONT></TD>
<TD NOWRAP><TABLE CELLSPACING=0 CELLPADDING=0>
<TR><TD><FONT SIZE=5>&nbsp;</FONT></TD>
</TR>
<TR><TD NOWRAP><FONT SIZE=2>&nbsp;cpu</FONT></TD>
</TR></TABLE></TD>
</TR></TABLE></DIV><BR>
<FONT SIZE=5>la variable </FONT><FONT SIZE=5><TT>sleep_time</TT></FONT><FONT SIZE=5> étant initialisée à zéro puis incrémentée une fois par seconde.
</FONT><FONT SIZE=5>load</FONT><FONT SIZE=5>
</FONT><!--TOC subsection <FONT SIZE=5>Les classes de priorité</FONT>-->

<H3><FONT SIZE=5>8.4.3&nbsp;&nbsp; Les classes de priorité</FONT></H3><!--SEC END -->
<FONT SIZE=5><B>La priorité des processus en mode système dépend de
l'action à réaliser.</B></FONT><FONT SIZE=5><BR>PSWAP 0 priorité en cours de swap<BR>PINOD 10 priorité en attendant une lecture d'information sur le système de fichiers<BR>PRIBIO 20 priorité en attente d'une lecture/écriture sur disque<BR>PZERO 25 priorité limite<BR>PWAIT 30 priorité d'attente de base<BR>PLOCK 35 priorité d'attente sur un verrou<BR>PSLEP 40 priorité d'attente d'un évènement <BR>PUSER 50 priorité de base pour les processus en mode utilisateur<BR>Le choix de l'ordre de ces priorités est très important, en effet un mauvais choix peut entraîner une diminution importante des performances du système.<BR>
<BR>
Il vaut mieux que les processus en attente d'un disque soient plus
prioritaires que les processus en attente d'un buffer, car les premiers
risquent fort de libérer un buffer après leur accès disque
(de plus il est possible que ce soit exactement le buffer attendu par
le deuxième processus). Si la priorité était inverse, il
deviendrait possible d'avoir un interblocage ou une attente très
longue si le système est bloqué par ailleurs.<BR>
<BR>
De la même façons, le swappeur doit être le plus prioritaire et non interruptible </FONT><FONT SIZE=5><FONT FACE=symbol>¾®</FONT></FONT><FONT SIZE=5> Si un processus est plus prioritaire que le swappeur et qu'il doit être swappé en mémoire ...<BR>En Demand-Paging le swappeur est aussi le processus qui réalise les chargements de page, ce processus doit être le plus prioritaire.
</FONT><FONT SIZE=5>Demand-Paging</FONT><BR>
<BR>
<FONT SIZE=5>

</FONT><!--TOC chapter <FONT SIZE=5>La mémoire</FONT>-->

<H1><FONT SIZE=5>Chapitre&nbsp;9&nbsp;&nbsp; La mémoire</FONT></H1><!--SEC END -->
<!--TOC subsection <FONT SIZE=5>les mémoires</FONT>-->

<H3><FONT SIZE=5>9.0.4&nbsp;&nbsp; les mémoires</FONT></H3><!--SEC END -->
<FONT SIZE=5>La mémoire d'un ordinateur se décompose en plusieurs éléments, dont le
prix et le temps d'accès sont très variables, cf figure
</FONT><A HREF="#hierarchie"><FONT SIZE=5>9.1</FONT></A><FONT SIZE=5>. Nous développerons dans ce chapitre et le suivant
les questions et solutions relatives à la mémoire centrale.<BR>
<BR>


</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML042.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 9.1&nbsp;: Hiérarchie de mémoires</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="hierarchie"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>

L'importance de la gestion de la mémoire centrale vient de son
coût et du coût relatif des autres formes de stockage, la figure
</FONT><A HREF="#caracteristiques"><FONT SIZE=5>9.2</FONT></A><FONT SIZE=5> donne une idée des caractéristiques relatives
des différents types de stockage.<BR>
<BR>


</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML043.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 9.2&nbsp;: Caractéristiques relatives des mémoires.</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="caracteristiques"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>

</FONT><!--TOC subsection <FONT SIZE=5>La mémoire centrale</FONT>-->

<H3><FONT SIZE=5>9.0.5&nbsp;&nbsp; La mémoire centrale</FONT></H3><!--SEC END -->
<FONT SIZE=5>
La mémoire est un tableau à une dimension de mots machines (ou d'octets), chacun ayant une adresse propre. Les échanges avec l'extérieur se font en général par des lectures ou des écritures à des adresses spécifiques.<BR>
<BR>
Le système Unix est multi-tâche,ceci pour maximiser l'utilisation du cpu. Cette technique pose comme condition obligatoire que la mémoire centrale soit utilisée et/ou partagée entre les différentes tâches.<BR>
<BR>
Les solutions de gestion de la mémoire sont très dépendantes du matériel et ont mis longtemps à évoluer vers les solutions actuelles. Nous allons voir plusieurs approches qui peuvent servir dans des situations particulières .<BR>
<BR>
La mémoire est le point central dans un système d'exploitation, c'est à travers elle que l'unité centrale communique avec l'extérieur.<BR>
<BR>

</FONT><!--TOC section <FONT SIZE=5>Allocation contiguë</FONT>-->

<H2><FONT SIZE=5>9.1&nbsp;&nbsp; Allocation contiguë</FONT></H2><!--SEC END -->
<FONT SIZE=5>
</FONT><FONT SIZE=5>Allocation contiguë</FONT><FONT SIZE=5>
</FONT><!--TOC subsection <FONT SIZE=5>Pas de gestion de la mémoire</FONT>-->

<H3><FONT SIZE=5>9.1.1&nbsp;&nbsp; Pas de gestion de la mémoire</FONT></H3><!--SEC END -->
<FONT SIZE=5>

</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML044.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 9.3&nbsp;: Une mémoire de 64 Kilo Octets.</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="mem1"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>

Pas de gestion de la mémoire ! Cette méthode, qui a l'avantage de la simplicité et de la rapidité, permet toute liberté quand à l'utilisation de la mémoire. En effet, toute adresse est accessible, et peut être utilisée pour n'importe quelle tâche.
Le désavantage &nbsp;: aucune fonctionnalité, tout doit être reprogrammé, typiquement il n'y pas de système d'exploitation !<BR>
<BR>
</FONT><!--TOC subsection <FONT SIZE=5>Le moniteur résidant</FONT>-->

<H3><FONT SIZE=5>9.1.2&nbsp;&nbsp; Le moniteur résidant</FONT></H3><!--SEC END -->
<FONT SIZE=5>
On cherche à protéger le noyau des interférences possibles de la part des utilisateurs. Pour cela, toute adresse d'instruction ou de donnée manipulée par un programme utilisateur est comparée à un registre barrière (fence register).<BR>
<BR>
Tant que l'adresse est supérieure à la barrière, l'adresse est légale, sinon l'adresse est une référence illégale au moniteur et une interruption est émise (invalid adress).


</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML045.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 9.4&nbsp;: Protection du moniteur par un registre barrière.</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="mem2"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>

Cette méthode demande que pour tout accès à la mémoire une vérification de la validité de l'adresse soit réalisée. Ceci ralentit toute exécution d'un accès mémoire. (Paterson donne comme exemple de ralentissement des temps de 980 nanosecondes sans vérification et 995 nanosecondes avec vérification). Globalement ce temps supplémentaire peut être oublié.<BR>
<BR>
</FONT><!--TOC subsection <FONT SIZE=5>Le registre barrière</FONT>-->

<H3><FONT SIZE=5>9.1.3&nbsp;&nbsp; Le registre barrière</FONT></H3><!--SEC END -->
<FONT SIZE=5>registre barrière</FONT><FONT SIZE=5>
L'implémentation d'un tel mécanisme doit être réalisée de façon matérielle.<BR>
<BR>
La valeur du registre barrière est parfois réalisée de façon fixe sur une machine, ce qui pose des problèmes dès que l'on veut changer le noyau et/ou protéger plus de mémoire (voir DOS).


</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML046.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 9.5&nbsp;: Implémentation du registre Barrière.</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="mem3"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>



</FONT><!--TOC subsection <FONT SIZE=5>Le registre base</FONT>-->

<H3><FONT SIZE=5>9.1.4&nbsp;&nbsp; Le registre base</FONT></H3><!--SEC END -->
<FONT SIZE=5>registre base</FONT><FONT SIZE=5>
Le mécanisme suivant est une notion plus utile et plus ergonomique pour décrire la zone d'adressage d'un programme, et utile pour résoudre le problème de déplacement des programmes en mémoire (relocation).


</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML047.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 9.6&nbsp;: Implémentation du registre de Base.</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="mem5"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>

En effet, du fait que l'on utilise un registre barrière, les adresses utilisables de la mémoire ne commencent plus à 0000, alors que l'utilisateur veut continuer à utiliser des adresses logiques qui commencent à 0000.


</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML048.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 9.7&nbsp;: Positionnement d'un processus par un registre de Base.</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="mem4"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>

Pour continuer à fournir cette possibilité le registre barrière est transformé en registre de base (relocation) . A chaque utilisation d'une adresse logique du programme, on ajoute à cette adresse la valeur du registre de base pour trouver l'adresse physique. L'utilisateur ne connaît plus les adresses physiques. Il travaille uniquement avec des adresses logiques (xdb).<BR>
<BR>
Le moniteur a évidemment une valeur nulle pour son registre de base et donc peut adresser toute la mémoire. Le changement de la valeur du registre de base se fait de façon protégée en mode moniteur.<BR>
<BR>
Ces deux systèmes de protection de la mémoire sont clairement mono-processus. Seul le moniteur peut être protégé par ces mécanismes, il n'est pas possible de protéger les processus entre eux.<BR>
<BR>

</FONT><!--TOC subsection <FONT SIZE=5>Le swap</FONT>-->

<H3><FONT SIZE=5>9.1.5&nbsp;&nbsp; Le swap</FONT></H3><!--SEC END -->
<FONT SIZE=5>swap</FONT><FONT SIZE=5>


</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML049.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 9.8&nbsp;: Un système de swap utilisant uniquement un registre barrière.</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="mem.swap"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>

Il est possible avec les registres barrière ou les registres de base d'écrire des systèmes temps partagé, en utilisant le mécanisme de swap (échange).<BR></FONT><FONT SIZE=5><B>Swapper</B></FONT><FONT SIZE=5>, c'est échanger le contenu de la mémoire centrale avec le contenu d'une mémoire secondaire. Par extension swapper devient l'action de déplacer une zone mémoire de la mémoire vers le support de swap (en général un disque) ou réciproquement du périphérique de swap vers la mémoire.<BR>
<BR>
Le système va réaliser cet échange à chaque changement de contexte.
Les systèmes de swap utilisent une mémoire secondaire qui est en général un disque mais on peut utiliser d'autre supports secondaires plus lents ou plus rapides comme des bandes ou mémoires secondaires (non accessibles par l'unité de traitement).<BR>
<BR>
</FONT><!--TOC subsection <FONT SIZE=5>Le coût du swap</FONT>-->

<H3><FONT SIZE=5>9.1.6&nbsp;&nbsp; Le coût du swap</FONT></H3><!--SEC END -->
<FONT SIZE=5>
Sur un tel système, le temps de commutation de tâches est très important. Il est donc nécessaire que chaque processus reste possesseur de l'unité de traitement un temps suffisamment long pour que le ralentissement dû au swap ne soit pas trop sensible. 
Que ce passe-t-il sinon ? Le système utilise la majeure partie de ses ressources à déplacer des processus en et hors mémoire centrale. L'unité de traitement n'est plus utilisée au maximum ...<BR>
<BR>
</FONT><!--TOC subsection <FONT SIZE=5>Utilisation de la taille des processus</FONT>-->

<H3><FONT SIZE=5>9.1.7&nbsp;&nbsp; Utilisation de la taille des processus</FONT></H3><!--SEC END -->
<FONT SIZE=5>
Pour améliorer les mécanismes de swap, on remarque que le temps de swap est proportionnel à la taille des données à déplacer. Pour améliorer les performances, il faut donc introduire la notion de taille effective d'un processus, ce qui permet d'améliorer le débit mais cela impose que toutes les augmentations ou réductions de taille d'un processus utilisateur soient réalisée par un appel système (</FONT><FONT SIZE=5><TT>sbrk</TT></FONT><FONT SIZE=5>) afin que le noyau connaisse à tout moment la taille réelle de chaque processus.<BR>
<BR>
</FONT><!--TOC subsection <FONT SIZE=5>Swap et exécutions concurrentes</FONT>-->

<H3><FONT SIZE=5>9.1.8&nbsp;&nbsp; Swap et exécutions concurrentes</FONT></H3><!--SEC END -->
<FONT SIZE=5>
Une autre approche très efficace est de réaliser le swap
pendant l'exécution d'un autre processus. Mais avec le système
de registres de relocation c'est dangereux. En effet nous ne pouvons
pas assurer qu'un processus utilisateur donné ne va pas écrire dans les adresses réservées à un autre processus.<BR>
<BR>
</FONT><!--TOC subsection <FONT SIZE=5>Contraintes</FONT>-->

<H3><FONT SIZE=5>9.1.9&nbsp;&nbsp; Contraintes</FONT></H3><!--SEC END -->
<FONT SIZE=5>
Le swap introduit d'autres contraintes&nbsp;: un processus doit être en préempté actif pour être swappé, c'est à dire n'être en attente d'aucune entrée-sortie. En effet, si P1 demande une E/S et pendant cette demande il y a échange de P1 et P2, alors la lecture demandée par P1 a lieu dans les données de P2.<BR>
<BR>
</FONT><!--TOC subsection <FONT SIZE=5>Deux solutions existent</FONT>-->

<H3><FONT SIZE=5>9.1.10&nbsp;&nbsp; Deux solutions existent</FONT></H3><!--SEC END -->
<FONT SIZE=5>
Soit ne jamais swapper de processus en attente d'entrées-sorties.
Soit réaliser toutes les entrées-sorties dans des buffers internes au noyau (solution UNIX), ce qui a pour coût une recopie mémoire à mémoire supplémentaire par E/S.
Les transferts entre le noyau et le processus ayant lieu uniquement quand le processus est en mémoire.<BR>
<BR>
</FONT><!--TOC subsection <FONT SIZE=5>Les problèmes de protection</FONT>-->

<H3><FONT SIZE=5>9.1.11&nbsp;&nbsp; Les problèmes de protection</FONT></H3><!--SEC END -->
<FONT SIZE=5>
Nous venons d'apercevoir des problèmes de protection entre un processus et le noyau. Si l'on autorise plusieurs processus à résider en mémoire en même temps, il nous faut un mécanisme de protection inter-processus.<BR>Deux méthodes sont couramment utilisées&nbsp;: les extensions du registre barrière et du registre de base (relocation).

<BR>
<BR>
</FONT><!--TOC subsection <FONT SIZE=5>Les registres doubles</FONT>-->

<H3><FONT SIZE=5>9.1.12&nbsp;&nbsp; Les registres doubles</FONT></H3><!--SEC END -->
<FONT SIZE=5>

</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML050.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 9.9&nbsp;: Double registre barrière.</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="mem6"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>

Deux registres Barrière Bas et Haut <BR>Si Adresse </FONT><FONT SIZE=5>&lt;</FONT><FONT SIZE=5> Bas </FONT><FONT SIZE=5><FONT FACE=symbol>¾®</FONT></FONT><FONT SIZE=5> lever une exception erreur d'adresse<BR>Si Adresse </FONT><FONT SIZE=5>&gt;=</FONT><FONT SIZE=5> Haut </FONT><FONT SIZE=5><FONT FACE=symbol>¾®</FONT></FONT><FONT SIZE=5> lever une exception erreur d'adresse<BR>Sinon adresse correcte.<BR>

</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML051.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 9.10&nbsp;: Base et Limite.</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="mem7"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>

Deux registres de relocation </FONT><FONT SIZE=5><I>Base</I></FONT><FONT SIZE=5> et </FONT><FONT SIZE=5><I>Limit</I></FONT><FONT SIZE=5>, on travaille avec des
adresses logiques </FONT><FONT SIZE=5><I>Limit</I></FONT><FONT SIZE=5> donne la valeur maximale d'une adresse logique
et </FONT><FONT SIZE=5><I>Base</I></FONT><FONT SIZE=5> donne la position en mémoire de l'adresse logique zéro.<BR>Si Adresse </FONT><FONT SIZE=5>&gt;=</FONT><FONT SIZE=5> </FONT><FONT SIZE=5><I>Limit</I></FONT><FONT SIZE=5> </FONT><FONT SIZE=5><FONT FACE=symbol>¾®</FONT></FONT><FONT SIZE=5> lever une exception erreur d'adresse<BR>sinon utiliser l'adresse physique Adresse+</FONT><FONT SIZE=5><I>Base</I></FONT><FONT SIZE=5>.<BR>
<BR>
<BR>
</FONT><!--TOC section <FONT SIZE=5>Ordonnancement en mémoire des processus</FONT>-->

<H2><FONT SIZE=5>9.2&nbsp;&nbsp; Ordonnancement en mémoire des processus</FONT></H2><!--SEC END -->
<FONT SIZE=5>
Les choix de l'implémentation des mécanismes d'adressage influence énormément l'ordonnancement des processus.<BR>
<BR>
Nous travaillons dans le cas d'un système de traitement par lots c'est à dire en temps partagé mais les processus restent en mémoire tout le temps de leur exécution. S'il n'y a plus de place le processus est mis en attente (i.e. non chargé en mémoire).


</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML052.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 9.11&nbsp;: Une situation d'ordonnancement de processus en mémoire.</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="mem.ordo.1"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>



Nous devons résoudre le problème suivant&nbsp;: il nous faut un algorithme pour choisir dynamiquement, parmi les blocs libres de la mémoire centrale, celui qui va recevoir le nouveau processus (algorithme d'allocation de mémoire à un processus).
On reconnaît en général trois méthodes&nbsp;:
</FONT><DL COMPACT=compact>
<DT><FONT SIZE=5>First-fit</FONT><FONT SIZE=5>
</FONT><FONT SIZE=5>First-fit</FONT><DD><FONT SIZE=5> Le premier bloc suffisamment grand pour contenir notre processus est choisi.
</FONT>
<DT><FONT SIZE=5>Best-fit</FONT><DD><FONT SIZE=5> Le plus petit bloc suffisamment grand pour contenir notre processus est choisi.</FONT><FONT SIZE=5>Best-fit</FONT><FONT SIZE=5>
</FONT>
<DT><FONT SIZE=5>Worst-fit</FONT><DD><FONT SIZE=5> Le bloc qui nous laisse le plus grand morceau de mémoire libre est choisi (le plus grand bloc).</FONT><FONT SIZE=5>Worst-fit</FONT><FONT SIZE=5>
</FONT></DL><FONT SIZE=5>De nombreuse expériences pratiques et des simulations ont montré que le meilleur est first-fit puis best-fit et que ces deux algorithmes sont beaucoup plus efficaces que worst-fit.

</FONT><FONT SIZE=5> <B>Compactage</B></FONT><FONT SIZE=5> 
On cherche à améliorer ces mécanismes en défragmentant la mémoire c'est à dire en déplaçant les processus en mémoire de façon à rendre contiguës les zones de mémoire libre de façon à pouvoir les utiliser.


</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML053.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 9.12&nbsp;: Compactage</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="mem.ordo.3"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>




</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML054.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 9.13&nbsp;: Plusieurs déplacements possibles.</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="mem.ordo.2"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>


</FONT><FONT SIZE=5>compactage</FONT><FONT SIZE=5>
</FONT><!--TOC section <FONT SIZE=5>Allocation non-contiguë</FONT>-->

<H2><FONT SIZE=5>9.3&nbsp;&nbsp; Allocation non-contiguë</FONT></H2><!--SEC END -->
<FONT SIZE=5>
</FONT><!--TOC subsection <FONT SIZE=5>Les pages et la pagination</FONT>-->

<H3><FONT SIZE=5>9.3.1&nbsp;&nbsp; Les pages et la pagination</FONT></H3><!--SEC END -->
<FONT SIZE=5>pages</FONT><FONT SIZE=5>
Pour accélérer ces mécanismes d'allocation, la notion de page a été introduite.<BR>
<BR>
On va découper la mémoire et les processus en pages. Grâce à ce système, il ne sera plus nécessaire de placer les processus dans une zone contig</FONT><FONT SIZE=5>ü</FONT><FONT SIZE=5>e de la mémoire.
Il devient possible d'allouer de la mémoire à un processus sans avoir à réaliser de compactage !<BR>
<BR>
Ce principe des page nécessite de nouvelles possibilités matérielles.
Toute adresse est maintenant considérée comme un couple <BR>
<BR>
(Numéro de page, Position dans la page)<BR>
<BR>


</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML055.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 9.14&nbsp;: Calcul d'une adresse avec la table des pages</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="mem.page"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>


A &nbsp;: adresse logique, P &nbsp;: taille de page <BR>Numéro de page = A div P<BR>Position = A modulo P<BR>
</FONT><!--TOC subsection <FONT SIZE=5>Ordonnancement des processus dans une mémoire paginée </FONT>-->

<H3><FONT SIZE=5>9.3.2&nbsp;&nbsp; Ordonnancement des processus dans une mémoire paginée </FONT></H3><!--SEC END -->
<FONT SIZE=5>
Le choix de l'organisation mémoire a une influence prépondérante sur l'ordonnancement des processus, qui devient beaucoup plus indépendant de la mémoire quand celle-ci est paginée.<BR></FONT><FONT SIZE=5>ordonnancement</FONT><FONT SIZE=5>
Le désavantage de la méthode de gestion de mémoire par un mécanisme de
page est le phénomène de </FONT><FONT SIZE=5><B>fragmentation interne</B></FONT><FONT SIZE=5>. On alloue une page entière alors que le processus ne l'utilise qu'en partie. Mais la taille des mémoires et des processus deviennent tels par rapport aux tailles de page que cette perte devient minime.<BR>Un avantage des pages est une plus grande simplicité du partage de la mémoire entre différents processus. En particulier quand plusieurs processus partagent le même code. La page qui contient du code utilisé par les processus sera partageable et protégée en écriture.<BR>Sous Unix le compilateur produit automatiquement des programmes dont la partie code est partageable.


</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML056.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 9.15&nbsp;: La mémoire logique et la Table des pages.</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="mem.page2"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>

</FONT><!--TOC subsection <FONT SIZE=5>Comment protéger la mémoire paginée</FONT>-->

<H3><FONT SIZE=5>9.3.3&nbsp;&nbsp; Comment protéger la mémoire paginée</FONT></H3><!--SEC END -->
<FONT SIZE=5>
Les protections d'accès sont faites au niveau de la table des pages.<BR>
<BR>
On a une table des pages globale. C'est donc le système qui alloue les
pages à un processus, qui par construction (du système de pagination) ne peut pas écrire en dehors de ses propres pages.
De plus, dans la table des pages d'un processus, des drapeaux indiquent le type de page (droits d'accès en lecture/écriture/exécution).<BR>
<BR>
</FONT><!--TOC subsection <FONT SIZE=5>La mémoire segmentée</FONT>-->

<H3><FONT SIZE=5>9.3.4&nbsp;&nbsp; La mémoire segmentée</FONT></H3><!--SEC END -->
<FONT SIZE=5>
Nous venons de voir que les adresses logiques utilisées par le programmeur sont différentes des adresses physiques.<BR>
<BR>
La mémoire segmentée est une organisation de la mémoire qui respecte
le comportement usuel des programmeurs, qui généralement voient la mémoire comme un ensemble de tableaux distincts contenant des informations de types différents. Un segment pour chaque type&nbsp;: données, code, table des symboles, librairies etc. Ces différentes zones ayant des tailles variées, et parfois variables au cours du temps (le tas par exemple).<BR>
<BR>


</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML057.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 9.16&nbsp;: Mémoire segmentée</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="mem.seg"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>


La mémoire segmentée non paginée pose des problèmes de compactage (défragmentation).
La stratégie idéale est&nbsp;: la mémoire en segments paginés.<BR>
<BR>


</FONT><!--TOC chapter <FONT SIZE=5>La mémoire virtuelle</FONT>-->

<H1><FONT SIZE=5>Chapitre&nbsp;10&nbsp;&nbsp; La mémoire virtuelle</FONT></H1><!--SEC END -->
<FONT SIZE=5>Les méthodes de gestion mémoire que nous venons de voir ont toutes un défaut majeur qui est de garder l'ensemble du processus en mémoire, ce qui donne :
</FONT><UL>
<LI><FONT SIZE=5>swap</FONT><FONT SIZE=5>
</FONT><FONT SIZE=5> un coût en swap important
</FONT>
<LI><FONT SIZE=5> Impossibilité de créer de très gros processus.
</FONT></UL><FONT SIZE=5>
Les méthodes de mémoire virtuelle permettent d'exécuter un programme qui ne tient pas entièrement en mémoire centrale&nbsp;!<BR>
<BR>
Nous avons commencé par présenter des algorithmes de gestion de la mémoire qui utilisent le concept de base suivant&nbsp;:<BR>l'ensemble de l'espace logique adressable d'un processus doit être en mémoire pour pouvoir exécuter le processus.<BR> Cette restriction semble à la fois raisonnable et nécessaire, mais aussi très dommageable car cela limite la taille des processus à la taille de la mémoire physique.<BR> Or si l'on regarde des programmes très standards, on voit que&nbsp;:
</FONT><UL>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5> il y des portions de code qui gèrent des cas très inhabituels qui ont lieu très rarement (si ils ont lieu)
</FONT>
<LI><FONT SIZE=5> les tableaux, les listes et autres tables sont en général initialisés à des tailles beaucoup plus grandes que ce qui est réellement utile
</FONT>
<LI><FONT SIZE=5> Certaines options d'application sont très rarement utilisées
</FONT></UL><FONT SIZE=5>
Même dans le cas où le programme en entier doit résider en mémoire, tout n'est peut-être pas absolument nécessaire en même temps.<BR>
<BR>
Avec la mémoire virtuelle, la mémoire logique devient beaucoup plus grande que la mémoire physique.<BR>
<BR>
De nombreux avantages&nbsp;:<BR>Comme les utilisateurs consomment individuellement moins de mémoire, plus d'utilisateurs peuvent travailler en même temps.
 Avec l'augmentation de l'utilisation du CPU et de débit que cela implique (mais pas d'augmentation de la vitesse).<BR>
<BR>
Moins d'entrées-sorties sont effectuées pour l'exécution d'un processus, ce qui fait que le processus s'exécute (temps réel) plus rapidement.<BR>
<BR>
</FONT><!--TOC subsection <FONT SIZE=5>Les overlays</FONT>-->

<H3><FONT SIZE=5>10.0.5&nbsp;&nbsp; Les overlays</FONT></H3><!--SEC END -->
<FONT SIZE=5>overlays</FONT><FONT SIZE=5>
Une des premières versions d'exécutables partiellement en mémoire est celle des "overlay" qui est l'idée de charger successivement des portions disjointes et différentes de code en mémoire, exécutées l'une après l'autre.<BR>
<BR>
Les différentes passes d'un compilateur sont souvent réalisées en utilisant un overlay (préprocesseurs, pass1, pass2, pour les compilateurs C).<BR>
<BR>
Les overlay nécessitent quelques adaptations de l'éditeur de liens et
des mécanismes de relocation.<BR>
<BR>
</FONT><!--TOC subsection <FONT SIZE=5>Le chargement dynamique</FONT>-->

<H3><FONT SIZE=5>10.0.6&nbsp;&nbsp; Le chargement dynamique</FONT></H3><!--SEC END -->
<FONT SIZE=5>chargement dynamique</FONT><FONT SIZE=5>
Un autre système couramment utilisé dans les logiciels du marché des micros est le chargement dynamique.
Avec le chargement dynamique, une fonction n'est chargée en mémoire qu'au moment de son appel.
Le chargement dynamique demande que toutes les fonctions soient repositionnables en mémoire de façon indépendante.<BR>
<BR>
A chaque appel de fonction on regarde si la fonction est en mémoire sinon un éditeur de liens dynamique est appelé pour la charger.<BR>
<BR>
Dans les deux cas (overlay et chargement dynamique), le système joue un rôle très restreint, il suffit en effet d'avoir un bon système de gestion de fichiers.<BR>
<BR>
Malheureusement, </FONT><FONT SIZE=5><EM>le travail</EM></FONT><FONT SIZE=5> que doit réaliser le programmeur
pour choisir les overlays et/ou installer un mécanisme de chargement
dynamique efficace </FONT><FONT SIZE=5><EM>est non trivial</EM></FONT><FONT SIZE=5> et requiert que le
programmeur ait une </FONT><FONT SIZE=5><EM>parfaite connaissance</EM></FONT><FONT SIZE=5> du programme.<BR>
<BR>
Ceci nous amène aux </FONT><FONT SIZE=5><EM>techniques automatiques</EM></FONT><FONT SIZE=5>.<BR>
<BR>
</FONT><!--TOC section <FONT SIZE=5>Demand Paging</FONT>-->

<H2><FONT SIZE=5>10.1&nbsp;&nbsp; Demand Paging</FONT></H2><!--SEC END -->
<FONT SIZE=5>Demand Paging</FONT><FONT SIZE=5>
La méthode de </FONT><FONT SIZE=5><B>Demand Paging</B></FONT><FONT SIZE=5> est la plus répandue des implémentations de mémoire virtuelle, elle demande de nombreuse capacités matérielles.<BR>Nous partons d'un système de swap où la mémoire est découpée en pages. Comme pour le swap, quand un programme doit être exécuté nous le chargeons en mémoire (swap in) mais au lieu de faire un swap complet, on utilise un "swappeur paresseux" (lazy swapper).<BR></FONT><FONT SIZE=5>lazy swapper</FONT><FONT SIZE=5>
Un swappeur paresseux charge une page </FONT><FONT SIZE=5><B>uniquement si</B></FONT><FONT SIZE=5> elle est nécessaire.<BR>Que ce passe-t-il quand le programme essaie d'accéder à une page qui
est hors mémoire ?
</FONT><UL>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5> le matériel va traduire l'adresse logique en une adresse physique grâce à la table des pages.
</FONT>
<LI><FONT SIZE=5> tant que les pages demandées sont en mémoire, le programme tourne normalement,
 sinon si la page est contenue dans l'espace des adresses logiques mais n'est pas chargée,
 il y a une </FONT><FONT SIZE=5><B>page fault</B></FONT><FONT SIZE=5>.
</FONT><FONT SIZE=5>page fault</FONT><FONT SIZE=5>
</FONT></UL><FONT SIZE=5> En général, une erreur d'adresse est dûe à une tentative d'accès à une adresse extérieure (invalide).
 Dans ce cas, le programme doit être interrompu, c'est le comportement normal d'un système de swap.<BR>
<BR>
Mais il est possible avec un swappeur paresseux que la page existe mais ne soit pas en mémoire centrale, d'où les étapes suivantes dans ce cas&nbsp;:


</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML058.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 10.1&nbsp;: Etapes de la gestion d'une erreur de page</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="mem.fault"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>

On peut faire démarrer un processus sans aucune page en mémoire. La
première </FONT><FONT SIZE=5><B>Page Fault</B></FONT><FONT SIZE=5> aurait lieu à la lecture de la première instruction (l'instruction n'étant pas en mémoire).<BR>
<BR>
Il faut réaliser une forme spéciale de sauvegarde de contexte, il faut garder une image de l'état du processus qui vient d'effectuer une </FONT><FONT SIZE=5><B>Page Fault</B></FONT><FONT SIZE=5> mais de plus il faudra redémarrer (réexécuter) l'instruction qui a placé le processus dans cet état, en effet il est possible que l'instruction ne se soit pas terminé par manque de données.<BR>
<BR>
Le système d'exploitation a ici un rôle important, c'est lui qui va réaliser le chargement de la page manquante puis relancer le processus et l'instruction.<BR>
<BR>
Les circuits nécessaires à la méthode de Demande Paging sont les mêmes que ceux que l'on utilise pour un système de swap paginé,
c'est-à-dire une mémoire secondaire et un gestionnaire de pages (table des pages).<BR>
<BR>
Par contre, la partie logicielle est beaucoup plus importante.<BR>
<BR>
Enfin il faut que les </FONT><FONT SIZE=5><B>instructions soient interruptibles</B></FONT><FONT SIZE=5>, ce qui n'est pas toujours le cas sur tous les processeurs et ce qui est fondamental, comme nous allons le voir sur des exemples:<BR>
<BR>
 add A,B in C<BR>
<BR>
</FONT><OL type=1>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5> chercher et décoder l'instruction add
</FONT>
<LI><FONT SIZE=5> charger le contenu de l'adresse A
</FONT>
<LI><FONT SIZE=5> charger le contenu de l'adresse B
</FONT>
<LI><FONT SIZE=5> sommer et sauvegarder dans C
</FONT></OL><FONT SIZE=5>
Si l'erreur de page a lieu dans le 4ième accès à la mémoire (C), il faudra de nouveau recommencer les 3 accès mémoire de l'instruction, c'est-à-dire lire l'instruction, etc.<BR>
<BR>
Un autre type de problème vient d'instructions comme la suivante que l'on trouve sur PDP-11 &nbsp;:<BR>
<BR>
MOV (R2)++,--(R3)<BR>
<BR>
cette instruction déplace l'objet pointé par le registre R2 dans l'adresse pointé par R3, R2 est incrémenté après le transfert et R3 avant.<BR>
<BR>
Que se passe-t-il si l'on a une erreur de page en cherchant à accéder à la page pointé par R3 ?<BR>
<BR>
</FONT><!--TOC subsection <FONT SIZE=5>Efficacité</FONT>-->

<H3><FONT SIZE=5>10.1.1&nbsp;&nbsp; Efficacité</FONT></H3><!--SEC END -->
<FONT SIZE=5>Efficacité des performances de Demand Paging &nbsp;:<BR>Soit ma = 500 nanosecondes, le temps moyen d'accès a une mémoire.<BR>le temps effectif d'accès avec le Demand Paging est <BR>temps effectif = (1-p)*ma + p * "temps de gestion de l'erreur de page"<BR>où p est la probabilité d'occurrence d'une erreur de page (page fault).<BR>
<BR>
Une erreur de page nécessite de réaliser les opérations suivantes 
</FONT><OL type=1>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5> lever une interruption pour le système
</FONT>
<LI><FONT SIZE=5> sauvegarder le contexte du processus
</FONT>
<LI><FONT SIZE=5> déterminer que l'interruption est une erreur de page
</FONT>
<LI><FONT SIZE=5> vérifier que la page en question est une page légale de l'espace logique, déterminer où se trouve la page dans la mémoire secondaire.
</FONT>
<LI><FONT SIZE=5> exécuter une lecture de la page sur une page mémoire libre
 (libérer éventuellement une page cf. algorithme de remplacement
 de page)
</FONT><UL>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5> attendre que le périphérique soit libre
</FONT>
<LI><FONT SIZE=5> temps de latence du périphérique
</FONT>
<LI><FONT SIZE=5> commencer le transfert
</FONT></UL><FONT SIZE=5>
</FONT>
<LI><FONT SIZE=5> allouer pendant ce temps-là le cpu à un autre utilisateur
</FONT>
<LI><FONT SIZE=5> interruption du périphérique
</FONT>
<LI><FONT SIZE=5> sauvegarde du contexte du processus courant
</FONT>
<LI><FONT SIZE=5> déterminer que l'interruption était la bonne interruption (venant du périphérique)
</FONT>
<LI><FONT SIZE=5> mise à jour de la table des pages et d'autres pages pour indiquer que la page demandée est en mémoire maintenant.
</FONT>
<LI><FONT SIZE=5> attendre que le processus soit sélectionné de nouveau pour utiliser l'unité centrale (cpu)
</FONT>
<LI><FONT SIZE=5> charger le contexte du processus !
</FONT></OL><FONT SIZE=5>Toutes ces instructions ne sont pas toujours réalisées (on peut en
particulier supposer que l'on ne peut pas préempter l'unité centrale,
mais alors quelle perte de temps pour l'ensemble du système).<BR>
<BR>
Dans tous les cas, nous devons au moins réaliser les 3 actions suivantes&nbsp;:<BR></FONT><UL>
<LI><FONT SIZE=5>
 </FONT><FONT SIZE=5> gérer l'interruption
 </FONT>
<LI><FONT SIZE=5> swapper la page demandée
 </FONT>
<LI><FONT SIZE=5> relancer le processus 
</FONT></UL><FONT SIZE=5>
Ce qui coûte le plus cher est la recherche de la page sur le disque et son transfert en mémoire, ce qui prend de l'ordre de 1 à 10 millisecondes.<BR>Ce qui nous donne en prenant une vitesse d'accès mémoire de 1 microseconde et un temps de gestion de page de 5 millisecondes un
</FONT><DIV ALIGN=center><FONT SIZE=5> </FONT><FONT SIZE=5>temps effectif</FONT><FONT SIZE=5> = (1 - <I>p</I>) + <I>p</I> × 5000 &nbsp; </FONT><FONT SIZE=5> microsecondes</FONT><FONT SIZE=5> </FONT></DIV><BR>
<FONT SIZE=5>Une erreur de page toutes les mille pages nous donne un temps effectif onze fois plus long que l'accès standard.<BR>Il faut réduire à moins d'une erreur de page tout les 100000 accès pour obtenir une dégradation inférieure à 10<BR>
<BR>
On comprend bien que les choix à faire sur des pages qu'il faut placer en mémoire sont donc très importants.<BR>Ces choix deviennent encore plus importants quand l'on a de nombreux
utilisateurs et qu'il y a sur-allocation de la mémoire, exécution
concurrente de 6 processus de la taille supérieure ou égale à la mémoire physique&nbsp;!<BR>Si l'on suppose de plus que nos 6 programmes utilisent dans une petite séquence d'instructions toutes les pages de leur mémoire logique,
nous nous trouvons alors dans une situation de pénurie de pages libres.<BR>Le système d'exploitation peut avoir recoure à plusieurs solution dans ce cas-là
</FONT><OL type=1>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5> tuer le processus fautif ...
</FONT>
<LI><FONT SIZE=5> utiliser un algorithme de remplacement de page
</FONT></OL><FONT SIZE=5> Cet algorithme de remplacement est introduit dans notre séquence de gestion d'erreur de page là où l'on s'attribuait une page libre de la mémoire centrale.<BR>Maintenant il nous faut sélectionner une victime, c'est-à-dire, une des pages occupées de la mémoire centrale qui sera swappée sur disque et remplacée par la page demandée.<BR>Remarquons que dans ce cas-là notre temps de transfert est doublé, comme il faut à la fois lire une page et sauvegarder une page sur disque (le temps de transfert disque est ce qui est le plus coûteux dans la gestion d'une erreur de page).<BR>Il est possible de réaliser des systèmes de </FONT><FONT SIZE=5><B>demand segments</B></FONT><FONT SIZE=5>, mais le lecteur avisé remarquera rapidement les problèmes posés par la taille variable des segments.<BR>
<BR>
</FONT><!--TOC section <FONT SIZE=5>Les algorithmes de remplacement de page</FONT>-->

<H2><FONT SIZE=5>10.2&nbsp;&nbsp; Les algorithmes de remplacement de page</FONT></H2><!--SEC END -->
<FONT SIZE=5>Un algorithme de remplacement de page doit minimiser le nombre de Page Faults.<BR>On recherche l'algorithme qui réduit au mieux la probabilité
d'occurrence d'une erreur de page.<BR>Un algorithme est évalué en prenant une chaîne de numéros de page et
en comptant le nombre de fautes de page qui ont lieu au cours de cette
suite d'accès, et cela en fonction du nombre de pages de mémoire
centrale dont il dispose.<BR>Pour illustrer les algorithmes de remplacement, nous utiliserons la suite de pages suivante :<BR>7,0,1,2,0,3,0,4,2,3,0,3,2,1,2,0,1,7,0,1<BR>et 3 pages en mémoire centrale.<BR>
<BR>
</FONT><!--TOC subsection <FONT SIZE=5>Le remplacement optimal</FONT>-->

<H3><FONT SIZE=5>10.2.1&nbsp;&nbsp; Le remplacement optimal</FONT></H3><!--SEC END -->
<FONT SIZE=5>
Utiliser comme victime la page qui ne sera pas utilisée pendant le plus longtemps.<BR>
<BR>
Soit pour notre suite :
</FONT><PRE><FONT SIZE=5>
7xx 70x 701 201 - 203 - 243 - -203 - - 201 - - - 701 - -
</FONT></PRE><FONT SIZE=5>soit seulement 9 fautes de page.<BR>
<BR>
Mais cet "algorithme" n'est valable que dans un cas où l'on connaît à l'avance les besoins, ce qui n'est généralement pas le cas.<BR>
<BR>
</FONT><!--TOC subsection <FONT SIZE=5>Le remplacement peps (FIFO)</FONT>-->

<H3><FONT SIZE=5>10.2.2&nbsp;&nbsp; Le remplacement peps (FIFO)</FONT></H3><!--SEC END -->
<FONT SIZE=5>L'algorithme le plus simple est Premier Entré Premier Sorti 
(First-In-First-Out ).<BR>Quand une victime doit être sélectionnée c'est la page la plus ancienne qui est sélectionnée.<BR>Soit pour la liste 
</FONT><PRE><FONT SIZE=5>
7,0,1,2,0,3,0,4,2,3,0,3,2,1,2,0,1,7,0,1
</FONT></PRE><FONT SIZE=5>et trois page de mémoire centrale&nbsp;:
</FONT><PRE><FONT SIZE=5>
7XX/70X/701/201-201/231/230/430/420/423/
023-023-023/013/012-012-012/712/702/701  
</FONT></PRE><FONT SIZE=5>soit </FONT><FONT SIZE=5><B>Quinze</B></FONT><FONT SIZE=5> Page Faults.<BR>
<BR>
Ce mécanisme rapide et simple à programmer n'est malheureusement pas très efficace.
Il existe des suites de pages pour lesquelles cet algorithme fait plus de page faults avec quatre pages mémoire qu'avec trois !
(par exemple : 1,2,3,4,1,2,5,1,2,3,4,5).<BR>
<BR>
</FONT><!--TOC subsection <FONT SIZE=5>Moins récemment utilisée LRU.</FONT>-->

<H3><FONT SIZE=5>10.2.3&nbsp;&nbsp; Moins récemment utilisée LRU.</FONT></H3><!--SEC END -->
<FONT SIZE=5>LRU (Least Recently Used page).<BR>Nous utilisons ici le vieillissement d'une page et non plus l'ordre de création de la page. On fait le pari que les pages qui ont été récemment utilisées le seront dans un proche avenir, alors que les pages qui n'ont pas été utilisées depuis longtemps ne sont plus utiles.<BR>
<BR>
Soit pour notre suite&nbsp;:
</FONT><PRE><FONT SIZE=5>
7xx 70x 701 201 - 203 - 403 402 432 032 - - 132 - 102 - 107 - 
</FONT></PRE><FONT SIZE=5>soit </FONT><FONT SIZE=5><B>Douze</B></FONT><FONT SIZE=5> Page Faults.<BR>
<BR>
L'algorithme LRU est un bon algorithme mais il pose de nombreux problèmes d'implémentation et peut demander de substantiels outils matériels.<BR>Des solutions logicielles&nbsp;:
</FONT><DL COMPACT=compact>
<DT><FONT SIZE=5>
</FONT><FONT SIZE=5>Des compteurs</FONT><DD><FONT SIZE=5> à chaque entrée de la table des pages, on ajoute un compteur de temps qui est mis à jour à chaque accès à la page. Il faut rechercher sur l'ensemble de la table la victime. De plus, ces temps doivent être mis à jour quand on change de table de page (celle d'un autre processus ...). On ne peut utiliser le temps réel ...
</FONT>
<DT><FONT SIZE=5>Une pile</FONT><DD><FONT SIZE=5> à chaque fois que l'on accède à une page, la page est placée en sommet de pile. Le dessus est toujours la page la plus récemment utilisée et le fond de la pile la moins récemment utilisée.
</FONT>
<DT><FONT SIZE=5>Des masques</FONT><DD><FONT SIZE=5> On utilise un octet associé à chaque page. Le
 système positionne à 1 le bit de poids fort à chaque accès à la
 page. Toutes les N millisecondes (click d'horloge, cf clock, N =
 100 sur fillmore) le système fait un décalage à droite de
 l'octet associé à chaque page. On obtient ainsi un historique de
 l'utilisation de la page. L'octet à 00000000 indique que la
 page n'a pas été utilisée depuis 8 cycles, 11111111 indique que
 la page a été utilisée pendant les 8 cycles. La page de masque
 11000100 à été utilisée plus récemment que 01110111. Si l'on
 interprète ces octets comme des entiers non-signés, c'est la page
 ayant le plus petit octet qui a été utilisée le moins récemment
 (l'unicité des numéros n'étant pas assurée, la sélection entre
 numéros identiques se fait avec l'ordre FIFO).
</FONT></DL><!--TOC subsection <FONT SIZE=5>L'algorithme de la deuxième chance</FONT>-->

<H3><FONT SIZE=5>10.2.4&nbsp;&nbsp; L'algorithme de la deuxième chance</FONT></H3><!--SEC END -->
<FONT SIZE=5>Un bit associé à chaque page est positionné à 1 à chaque fois qu'une page est utilisée par un processus.
Avant de retirer une page de la mémoire, on va essayer de lui donner une deuxième chance.
On utilise un algorithme FIFO plus la deuxième chance&nbsp;:<BR>Si le bit d'utilisation est à 0, la page est swappée hors mémoire (elle n'a pas été utilisée depuis la dernière demande de page).<BR>Si le bit est à 1, il est positionné a zéro et l'on cherche une autre victime. Ainsi cette page ne sera swappée hors mémoire que si toutes les autres pages ont été utilisées, et utilisent aussi leur deuxième chance.<BR>On peut voir ceci comme une queue circulaire, où l'on avance sur les pages qui ont le bit à 1 (en le positionnant à zéro) jusqu'à ce que l'on trouve une page avec le bit d'utilisation à zéro.<BR>
<BR>
</FONT><!--TOC subsection <FONT SIZE=5>Plus fréquemment utilisé MFU</FONT>-->

<H3><FONT SIZE=5>10.2.5&nbsp;&nbsp; Plus fréquemment utilisé MFU</FONT></H3><!--SEC END -->
<FONT SIZE=5>Plus fréquemment Utilisée&nbsp;:<BR>Comme son nom l'indique, c'est la fréquence d'utilisation qui joue au lieu de l'ancienneté, mais c'est le même mécanisme que LRU. 
Ces deux algorithmes de LRU et MFU sont rarement utilisés car trop gourmands en temps de calcul et difficiles à implémenter, mais ils sont assez efficaces.<BR>
<BR>
</FONT><!--TOC subsection <FONT SIZE=5>Le bit de saleté (Dirty Bit)</FONT>-->

<H3><FONT SIZE=5>10.2.6&nbsp;&nbsp; Le bit de saleté (Dirty Bit)</FONT></H3><!--SEC END -->
<FONT SIZE=5>Remarquons que si il existe une copie identique sur disque (zone de swap) d'une page de mémoire, il n'est pas nécessaire dans le cas d'un swapout de sauvegarder la page sur disque, il suffit de la libérer.<BR>Le bit de saleté permet d'indiquer qu'une page est (ou n'est plus) conforme à la page en zone de swap.<BR>
<BR>
Ce bit de propreté est utilisé dans les autres algorithmes, on choisit entre deux victimes possibles la plus propre, c'est-à-dire celle qui ne nécessite pas de swapout.<BR>
<BR>
</FONT><!--TOC section <FONT SIZE=5>Allocation de pages aux processus</FONT>-->

<H2><FONT SIZE=5>10.3&nbsp;&nbsp; Allocation de pages aux processus</FONT></H2><!--SEC END -->
<FONT SIZE=5>Comment répartir les pages sur les différents processus et le système ?
</FONT><DL COMPACT=compact>
<DT><FONT SIZE=5>
</FONT><FONT SIZE=5>remplacement local</FONT><DD><FONT SIZE=5> le processus se voit affecté un certain
 nombre de pages qu'il va utiliser de façon autonome, son temps
 d'exécution ne dépend que de son propre comportement.
</FONT>
<DT><FONT SIZE=5>remplacement global</FONT><DD><FONT SIZE=5> le comportement d'allocation de pages aux processus dépend de la charge du système et du comportement des différents processus.
</FONT></DL><FONT SIZE=5>Le remplacement local demande que l'on réalise un partage entre les différents processus.<BR>Le partage "équitable" &nbsp;:
m pages de mémoire physique,
n processus,
m/n pages par processus &nbsp;!
On retrouve ici un problème proche de la fragmentation interne, un grand nombre de pages est donné à un processus qui en utilise effectivement peu.<BR>On fait un peu mieux en utilisant&nbsp;: </FONT><FONT SIZE=5><I>S</I> = <FONT FACE=symbol>S</FONT> &nbsp; <I>s</I></FONT><SUB><FONT SIZE=4><I>i</I></FONT></SUB><FONT SIZE=5> </FONT><FONT SIZE=5>
 où </FONT><FONT SIZE=5><I>s</I></FONT><SUB><FONT SIZE=4><I>i</I></FONT></SUB><FONT SIZE=5> est le nombre de pages de la mémoire logique du Processus i.
Chaque processus se voit attribué </FONT><FONT SIZE=5>(<I>s</I></FONT><SUB><FONT SIZE=4><I>i</I></FONT></SUB><FONT SIZE=5> / <I>S</I>) <I>m</I></FONT><FONT SIZE=5> pages.
On améliore en faisant varier ce rapport en fonction de la priorité de chaque processus.<BR></FONT><!--TOC paragraph <FONT SIZE=5>Problèmes d'écroulement</FONT>-->

<H5><FONT SIZE=5> Problèmes d'écroulement</FONT></H5><!--SEC END -->
<FONT SIZE=5>
Si le nombre de pages allouées à un processus non-prioritaire tombe en dessous de son minimum vital,
ce processus est constamment en erreur de page &nbsp;: il passe tout son temps à réaliser des demandes de pages.
Ce processus doit être alors éjecté entièrement en zone de swap et
reviendra plus prioritaire quand il y aura de la place.<BR>
<BR>
Un exemple de bonne et mauvaise utilisation des pages (rappel les
compilateurs c allouent les tableaux sur des plages d'adresse croissante
 contigües int m[A][B] est un tableau de A tableaux de B entiers) &nbsp;:
</FONT><PRE><FONT SIZE=5><TT>
/* bonne initialisation */
int m[2048][2048];
main()
{int i,j;
for(i=0;i&lt;2048;i++)
        for(j=0;j&lt;2048;j++)
        m[i][j] = 1;       
}
</TT></FONT></PRE><FONT SIZE=5>
ce processus accède a une nouvelle page toute les 2048 affectation.
</FONT><PRE><FONT SIZE=5><TT>
/* mauvaise initialisation */
int m[2048][2048];
main()
{int i,j;
for(i=0;i&lt;2048;i++)
        for(j=0;j&lt;2048;j++)
        m[j][i] = 1;       
}
</TT></FONT></PRE><FONT SIZE=5>
ce processus accède a une nouvelle page toute les affectations&nbsp;!<BR>Attention&nbsp;: En </FONT><FONT SIZE=5><TT>fortran</TT></FONT><FONT SIZE=5> l'allocation des tableaux se fait dans
l'autre sens par colones ...<BR>Si la mémoire est libre et assez grande, les deux processus sont grossièrement aussi rapides, par contre si on lance dix exemplaires du premier, le temps d'attente est juste multiplié par 10. Pour le deuxième, le temps d'attente est au moins multiplié par 100 (je n'ai pas attendu la fin de l'exécution).<BR>
<BR>
</FONT><!--TOC section <FONT SIZE=5>L'appel fork et la mémoire virtuelle</FONT>-->

<H2><FONT SIZE=5>10.4&nbsp;&nbsp; L'appel fork et la mémoire virtuelle</FONT></H2><!--SEC END -->
<FONT SIZE=5>Nous avons vu que la primitive </FONT><FONT SIZE=5><TT>fork()</TT></FONT><FONT SIZE=5> réalise une copie de l'image mémoire du processus père pour créer le processus fils. Cette copie n'est pas intégrale car les deux processus peuvent partager des pages marquées en lecture seule, en particulier le segment du code est partagé par les deux processus (réentrance standard des processus unix).<BR>Mais avec le système de demand-paging, on peut introduire une nouvelle notion qui est la "copie sur écriture" (copy on write).
On ajoute à la structure de page de la table des pages des indicateurs de "copie sur écriture". L'idée est de réaliser la copie de la page uniquement dans le cas où l'un des processus qui peuvent y accèder réalise une écriture. Dans ce cas-là, la page est recopiée avant l'écriture et le processus écrivain possède alors sa propre page.<BR>L'intérêt de ce mécanisme est surtout visible dans le cas très fréquent où le </FONT><FONT SIZE=5><TT>fork</TT></FONT><FONT SIZE=5> est immédiatement suivi par un </FONT><FONT SIZE=5><TT>exec</TT></FONT><FONT SIZE=5>. En effet, ce dernier va réaliser une libération de toutes les pages, il est donc inutile de les recopier juste avant cette libération.<BR>Le système BSD a introduit la première version de cette idée en partant de l'appel système </FONT><FONT SIZE=5><TT>vfork()</TT></FONT><FONT SIZE=5> qui lui permet le partage totale de toutes les pages entre le processus père et le processus fils sans aucune copie. L'intérêt est de pouvoir réaliser rapidement un </FONT><FONT SIZE=5><TT>execve</TT></FONT><FONT SIZE=5> sans avoir à recopier l'espace d'adressage du processus père.<BR><BR>
<BR>
</FONT><!--TOC section <FONT SIZE=5>Projection de fichiers en mémoire</FONT>-->

<H2><FONT SIZE=5>10.5&nbsp;&nbsp; Projection de fichiers en mémoire</FONT></H2><!--SEC END -->
<A NAME="mmap"></A><FONT SIZE=5>La fonction </FONT><FONT SIZE=5><TT>mmap</TT></FONT><FONT SIZE=5> permet la projection de fichiers en mémoire. Le segment du fichier indiqué est placé en mémoire à partir de l'adresse indiquée. Le segment de fichier peut ainsi être parcouru par des accès par adresse sans utiliser de commande de lecture ou d'écriture.<BR>
<BR>
</FONT><PRE><FONT SIZE=5><TT>
#include &lt;sys/mman.h&gt;
#include &lt;sys/types.h&gt;

void *mmap(void  *adr, int len,
           int   prot, int options,
           int   desc, int offset);

int munmap(void *adr, int len);
</TT></FONT></PRE><FONT SIZE=5>
</FONT><FONT SIZE=5>appels systèmes!mmap@</FONT><FONT SIZE=5><TT>mmap</TT></FONT><FONT SIZE=5>

</FONT><FONT SIZE=5>appels systèmes!munmap@</FONT><FONT SIZE=5><TT>munmap</TT></FONT><FONT SIZE=5>
<BR>
<BR>
L'adresse </FONT><FONT SIZE=5><TT>adr</TT></FONT><FONT SIZE=5> indique où doit être placé le fichier, cette adresse doit être une adresse de début de page (un multiple de </FONT><FONT SIZE=5><TT>sysconf(_SC_PAGE_SIZE)</TT></FONT><FONT SIZE=5>), si le paramètre est NULL alors le système sélectionne l'adresse de placement qui est retournée par la fonction. L'intervalle de position <BR></FONT><DIV ALIGN=center><FONT SIZE=5><TT>[offset, offset+len]</TT></FONT></DIV><FONT SIZE=5>
du fichier </FONT><FONT SIZE=5><TT>desc</TT></FONT><FONT SIZE=5> est placé en mémoire.<BR></FONT><FONT SIZE=5><TT>prot</TT></FONT><FONT SIZE=5> indique les protections d'accès sous HP-UX les protections suivantes sont disponible&nbsp;:
</FONT><PRE><FONT SIZE=5><TT>
---     PROT_NONE
r--     PROT_READ
r-x     PROT_READ|PROT_EXECUTE
rw      PROT_READ|PROT_WRITE
rwx     PROT_READ|PROT_WRITE|PROT_EXECUTE
</TT></FONT></PRE><FONT SIZE=5>
</FONT><FONT SIZE=5><TT>options</TT></FONT><FONT SIZE=5> indique si l'on veut que les écritures réalisées dans les pages contenant la projection soient partagées (MAP_SHARED), ou au contraire qu'une copie sur écriture soit réalisée (MAP_PRIVATE).<BR>
<BR>
La fonction </FONT><FONT SIZE=5><TT>munmap</TT></FONT><FONT SIZE=5> permet de libérer la zone mémoire d'adresse </FONT><FONT SIZE=5><TT>adr</TT></FONT><FONT SIZE=5> et de longueur </FONT><FONT SIZE=5><TT>len</TT></FONT><FONT SIZE=5>.<BR>
<BR>
Pour une autre forme de mémoire partagée, voir le chapitre </FONT><A HREF="#IPC"><FONT SIZE=5>16</FONT></A><FONT SIZE=5> sur les IPC.<BR>Un exemple d'utilisation de </FONT><FONT SIZE=5><TT>mmap</TT></FONT><FONT SIZE=5> pour copier un fichier&nbsp;:<BR></FONT><FONT SIZE=5><TT>#include &lt;stdio.h&gt;<BR>#include &lt;sys/types.h&gt;<BR>#include &lt;sys/stat.h&gt;<BR>#include &lt;sys/mman.h&gt;<BR>#include &lt;fcntl.h&gt;<BR><BR>int main(int argc,char *argv[])<BR>{<BR>  int fdin,fdout;<BR>  struct stat statbuf;<BR>  char *src,*dst;<BR>  if (argc != 3)<BR>    {<BR>      fprintf(stderr,"usage: %s source destination ",argv[0]);<BR>      exit(-1);<BR>    }<BR>  if ((fdin = open(argv[1], O_RDONLY)) &lt; 0)<BR>    {<BR>      fprintf(stderr,"impossible d</TT></FONT><FONT SIZE=5><TT>\</TT></FONT><FONT SIZE=5><TT>'ouvrir: %s en lecture ",argv[1]);<BR>      exit(-2);<BR>    }<BR>  if ((fdout = open(argv[2], O_RDWR|O_CREAT|O_TRUNC,0666)) &lt; 0)<BR>    {<BR>      fprintf(stderr,"impossible d</TT></FONT><FONT SIZE=5><TT>\</TT></FONT><FONT SIZE=5><TT>'ouvrir: %s en ecriture ",argv[2]);<BR>      exit(-3);<BR>    }<BR>  if (fstat(fdin,&amp;statbuf) &lt; 0 )<BR>    {<BR>      fprintf(stderr,"impossible de faire stat sur  %s ",argv[1]);<BR>      exit(-4);<BR>    }<BR>  if (lseek(fdout, statbuf.st_size -1 , SEEK_SET) == -1 )<BR>    {<BR>      fprintf(stderr,"impossible de lseek  %s ",argv[2]);<BR>      exit(-5);<BR>    }<BR>  if (write(fdout,"",1) != 1)<BR>    {<BR>      fprintf(stderr,"impossible d</TT></FONT><FONT SIZE=5><TT>\</TT></FONT><FONT SIZE=5><TT>'ecrire sur   %s ",argv[2]);<BR>      exit(-6);<BR>    }<BR>  if ((src = mmap (0,statbuf.st_size, PROT_READ,<BR>                  MAP_FILE | MAP_SHARED, fdin,0)) == (caddr_t) -1 )<BR>    {<BR>      fprintf(stderr,"impossible de mapper   %s ",argv[1]);<BR>      exit(-7);<BR>    }<BR>  if ((dst = mmap (0,statbuf.st_size, PROT_READ | PROT_WRITE,<BR>                  MAP_FILE | MAP_SHARED, fdout,0)) == (caddr_t) -1 )<BR>    {<BR>      fprintf(stderr,"impossible de mapper   %s ",argv[2]);<BR>      exit(-8);<BR>    }<BR>  memcpy(dst,src,statbuf.st_size); /* copie */<BR><BR>  exit(0);<BR><BR>}<BR><BR></TT></FONT><BR>
<BR>
<FONT SIZE=5>Programme très rapide, il pourrait être encore amélioré si la fonction </FONT><FONT SIZE=5><TT>madvice</TT></FONT><FONT SIZE=5> fonctionnait ce commentaire n'est plus vrai sur la version 10.* de HPUX.<BR>Attention, quand vous utilisez </FONT><FONT SIZE=5><TT>mmap</TT></FONT><FONT SIZE=5> les
adresses mémoire dans la zone mappée ne sont pas nécessairement bien
alignées, il faut faire .<BR>
<BR>

</FONT><!--TOC chapter <FONT SIZE=5>Tubes et Tubes Nommés</FONT>-->

<H1><FONT SIZE=5>Chapitre&nbsp;11&nbsp;&nbsp; Tubes et Tubes Nommés</FONT></H1><!--SEC END -->
<FONT SIZE=5>
</FONT><FONT SIZE=5>tubes</FONT><FONT SIZE=5>
Les tubes sont un mécanisme de communication qui permet de réaliser des communications entre processus sous forme d'un flot continu d'octets. Les tubes sont un des éléments de l'agrément d'utilisation d'UNIX. C'est ce mécanisme qui permet l'approche filtre de la conception sous UNIX.<BR>
<BR>
Mécanisme de communication lié au système de gestion de fichier, les
tubes nommés ou non sont des paires d'entrées de la table des fichiers
ouverts, associées à une inode en mémoire gérée par un driver
spécifique. Une entrée est utilisée par les processus qui écrivent dans le tube, une entrée pour les lecteurs du tube. <BR></FONT><FONT SIZE=5><B>L'opération de lecture y est destructive&nbsp;!<BR>L'ordre des caractères en entrée est conservé en sortie (premier entré premier sortie).<BR>Un tube a une capacité finie&nbsp;: en général le nombre d'adresses directes des inodes du SGF (ce qui peut varier de 5 à 80 Ko).
</B></FONT><FONT SIZE=5>
</FONT><!--TOC section <FONT SIZE=5>Les tubes ordinaires (</FONT><FONT SIZE=5><EM>pipe</EM></FONT><FONT SIZE=5>)</FONT>-->

<H2><FONT SIZE=5>11.1&nbsp;&nbsp; Les tubes ordinaires (</FONT><FONT SIZE=5><EM>pipe</EM></FONT><FONT SIZE=5>)</FONT></H2><!--SEC END -->
<FONT SIZE=5>
Un tube est matérialisé par deux entrées de la table des ouvertures de fichiers, une de ces entrées est ouverte en écriture (l'entrée du tube), l'autre en lecture (la sortie du tube).
Ces deux entrées de la table des fichiers ouverts nous donnent le nombre de descripteurs qui pointent sur elles. Ces valeurs peuvent être traduites comme&nbsp;:
</FONT><DL COMPACT=compact>
<DT><FONT SIZE=5>
</FONT><FONT SIZE=5>nombre de lecteurs</FONT><DD><FONT SIZE=5> = nombre de descripteurs associés à l'entrée ouverte en lecture.</FONT><FONT SIZE=5><EM>On ne peut pas écrire dans un tube sans lecteur</EM></FONT><FONT SIZE=5>.
</FONT>
<DT><FONT SIZE=5>nombre d'écrivains</FONT><DD><FONT SIZE=5> = nombre de descripteurs associés à
 l'entrée ouverte en écriture. La nullité de ce nombre définit le comportement de la primitive </FONT><FONT SIZE=5><TT>read</TT></FONT><FONT SIZE=5> lorsque le tube est vide.
</FONT></DL><!--TOC section <FONT SIZE=5>Création de tubes ordinaires</FONT>-->

<H2><FONT SIZE=5>11.2&nbsp;&nbsp; Création de tubes ordinaires</FONT></H2><!--SEC END -->
<FONT SIZE=5>Un processus ne peut utiliser que les tubes qu'il a créés lui-même par la primitive </FONT><FONT SIZE=5><TT>pipe</TT></FONT><FONT SIZE=5> ou qu'il a hérités de son père grâce à l'héritage des descripteurs à travers </FONT><FONT SIZE=5><TT>fork</TT></FONT><FONT SIZE=5> et </FONT><FONT SIZE=5><TT>exec</TT></FONT><FONT SIZE=5>.<BR></FONT><PRE><FONT SIZE=5><TT>
#include &lt;unistd.h&gt;
int pipe(int  p[2]);
</TT></FONT></PRE><FONT SIZE=5> 
</FONT><FONT SIZE=5>appels systèmes!pipe@</FONT><FONT SIZE=5><TT>pipe</TT></FONT><FONT SIZE=5>



</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML059.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 11.1&nbsp;: Ouverture d'un tube</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="tube1"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>

On ne peut pas manipuler les descripteurs de tubes avec les fonctions et primitives&nbsp;: </FONT><FONT SIZE=5><TT>lseek, ioctl, tcsetattr</TT></FONT><FONT SIZE=5> et </FONT><FONT SIZE=5><TT>tcgetattr</TT></FONT><FONT SIZE=5>, comme il n'y a pas de périphérique associé au tube (tout est fait en mémoire).<BR>Héritage d'un tube dans la figure </FONT><A HREF="#tube2"><FONT SIZE=5>11.2</FONT></A><FONT SIZE=5> &nbsp;: le processus B hérite des descripteurs ouverts par son père A et donc, ici, du tube.<BR>
<BR>


</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML060.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 11.2&nbsp;: Héritage d'un tube</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="tube2"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>

Dans la Figure </FONT><A HREF="#tube3"><FONT SIZE=5>11.3</FONT></A><FONT SIZE=5>, les descripteurs associés aux tubes sont placés comme descripteurs 0 et 1 des processus A et B, c'est à dire la sortie de A et l'entrée de B. Les autres descripteurs sont fermés pour assurer l'unicité du nombre de lecteurs et d'écrivains dans le tube.<BR>
<BR>


</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML061.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 11.3&nbsp;: Redirection de la sortie standard de A dans le tube et
 de l'entrée standard de B dans le tube, et fermeture des descripteurs inutiles</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="tube3"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>

</FONT><!--TOC section <FONT SIZE=5>Lecture dans un tube</FONT>-->

<H2><FONT SIZE=5>11.3&nbsp;&nbsp; Lecture dans un tube</FONT></H2><!--SEC END -->
<FONT SIZE=5>On utilise l'appel système </FONT><FONT SIZE=5><TT>read</TT></FONT><FONT SIZE=5>.
</FONT><PRE><FONT SIZE=5><TT>
int nb_lu;
nb_lu = read(p[0], buffer, TAILLE_READ);
</TT></FONT></PRE><FONT SIZE=5> 
</FONT><FONT SIZE=5>appels systèmes!read@</FONT><FONT SIZE=5><TT>read</TT></FONT><FONT SIZE=5>

Remarquer que la lecture se fait dans le descripteur p[0].<BR>Comportement de l'appel&nbsp;:
</FONT><TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=5>Si le tube n'est </FONT><FONT SIZE=5> <B>pas vide</B></FONT><FONT SIZE=5> et contient </FONT><FONT SIZE=5> <B>taille</B></FONT><FONT SIZE=5> caractères&nbsp;:</FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>lecture de nb_lu = min(taille, TAILLE_READ) caractères.</FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=5>Si le tube est </FONT><FONT SIZE=5> <B>vide</B></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>Si le nombre d'écrivains est </FONT><FONT SIZE=5><EM>nul</EM></FONT><FONT SIZE=5></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>alors c'est la fin de fichier et nb_lu est nul.</FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>Si le nombre d'écrivains est </FONT><FONT SIZE=5><EM>non nul</EM></FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>Si lecture bloquante alors sommeil</FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>Si lecture non bloquante alors en fonction de l'indicateur</FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5><TT>O_NONBLOCK</TT></FONT><FONT SIZE=5> nb_lu= -1 et errno=EAGAIN.</FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5><TT>O_NDELAY</TT></FONT><FONT SIZE=5> nb_lu = 0.
</FONT></TD>
</TR></TABLE><BR>
<!--TOC section <FONT SIZE=5>Ecriture dans un tube</FONT>-->

<H2><FONT SIZE=5>11.4&nbsp;&nbsp; Ecriture dans un tube</FONT></H2><!--SEC END -->
<FONT SIZE=5>
</FONT><PRE><FONT SIZE=5><TT>
nb_ecrit = write(p[1], buf, n);
</TT></FONT></PRE><FONT SIZE=5> 
</FONT><FONT SIZE=5>appels systèmes!write@</FONT><FONT SIZE=5><TT>write</TT></FONT><FONT SIZE=5>

L'écriture est atomique si le nombre de caractères à écrire est inférieur à PIPE_BUF, la taille du tube sur le système. (cf </FONT><CODE><FONT SIZE=5><TT>&lt;limits.h&gt;</TT></FONT></CODE><FONT SIZE=5>).<BR>
<BR>
</FONT><TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=5>Si le nombre de lecteurs est nul</FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>envoi du signal SIGPIPE à l'écrivain.</FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=5>Sinon</FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>Si l'écriture est bloquante, il n'y a retour que quand</FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>les n caractères ont été écrits dans le tube.</FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>Si écriture non bloquante</FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>Si n </FONT><FONT SIZE=5>&gt;</FONT><FONT SIZE=5> PIPE_BUF, retour avec un nombre inférieur à n</FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>éventuellement -1 !</FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>Si n </FONT><FONT SIZE=5><FONT FACE=symbol>£</FONT></FONT><FONT SIZE=5> PIPE_BUF</FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>et si n emplacements libres, écriture nb_ecrit = n</FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>sinon retour -1 ou 0.
</FONT></TD>
</TR></TABLE><BR>
<!--TOC section <FONT SIZE=5>Interblocage avec des tubes</FONT>-->

<H2><FONT SIZE=5>11.5&nbsp;&nbsp; Interblocage avec des tubes</FONT></H2><!--SEC END -->
<FONT SIZE=5>Un même processus a deux accès à un tube, un accès en lecture, un accès en écriture et essaie de lire sur le tube vide en mode bloquant 
 </FONT><FONT SIZE=5><FONT FACE=symbol>¾®</FONT></FONT><FONT SIZE=5> le processus est bloqué indéfiniment dans la primitive </FONT><FONT SIZE=5><TT>read</TT></FONT><FONT SIZE=5>.<BR>Avec deux processus&nbsp;:<BR>deux tubes entre les deux processus, tous les deux bloqués en lecture
ou tous les deux bloqués en écriture, tous les deux en attente d'une action de l'autre processus.<BR>
<BR>
</FONT><!--TOC section <FONT SIZE=5>Les tubes nommés</FONT>-->

<H2><FONT SIZE=5>11.6&nbsp;&nbsp; Les tubes nommés</FONT></H2><!--SEC END -->
<FONT SIZE=5>
</FONT><FONT SIZE=5>fifo</FONT><FONT SIZE=5>tubes nommés</FONT><FONT SIZE=5>
Les tube nommés sont des tubes (</FONT><FONT SIZE=5><TT>pipe</TT></FONT><FONT SIZE=5>) qui existent dans le système de fichiers, et donc peuvent être ouverts grâce à une référence.<BR>Il faut préalablement créer le tube nommé dans le système de fichiers, grâce à la primitive </FONT><FONT SIZE=5><TT>mknod</TT></FONT><FONT SIZE=5> (</FONT><FONT SIZE=5><TT>mkfifo</TT></FONT><FONT SIZE=5>), avant de pouvoir l'ouvrir avec la primitive </FONT><FONT SIZE=5><TT>open</TT></FONT><FONT SIZE=5>.<BR>
<BR>
</FONT><PRE><FONT SIZE=5><TT>
int mknod(reference, mode | S_IFIFO,0);
</TT></FONT></PRE><FONT SIZE=5> </FONT><FONT SIZE=5>mkfifo</FONT><FONT SIZE=5>
</FONT><FONT SIZE=5>appels systèmes!mknod@</FONT><FONT SIZE=5><TT>mknod</TT></FONT><FONT SIZE=5>

</FONT><FONT SIZE=5><TT>mode</TT></FONT><FONT SIZE=5> est construit comme le paramètre de mode de la fonction </FONT><FONT SIZE=5><TT>open</TT></FONT><FONT SIZE=5>.<BR>En POSIX, un appel simplifié &nbsp;:
</FONT><PRE><FONT SIZE=5><TT>
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
int mkfifo(const char *ref, mode_t mode);
</TT></FONT></PRE><FONT SIZE=5> 
</FONT><FONT SIZE=5>appels systèmes!mkfifo@</FONT><FONT SIZE=5><TT>mkfifo</TT></FONT><FONT SIZE=5>
<BR>
<BR>
On peut créer des FIFOs à partir du shell grâce à
</FONT><PRE><FONT SIZE=5><TT>
mkfifo [-p] [-m mode] ref ... 
</TT></FONT></PRE><FONT SIZE=5> L'ouverture d'un tube nommé se fait exclusivement soit en mode O_RDONLY soit 
en mode O_WRONLY, ainsi le nombre de lecteur et d'écrivain peut être comptabilisé.<BR></FONT><!--TOC subsection <FONT SIZE=5>Ouverture et synchronisation des ouvertures de tubes nommés</FONT>-->

<H3><FONT SIZE=5>11.6.1&nbsp;&nbsp; Ouverture et synchronisation des ouvertures de tubes nommés</FONT></H3><!--SEC END -->
<FONT SIZE=5>synchronisation</FONT><FONT SIZE=5>
</FONT><FONT SIZE=5><B>Il y a automatiquement synchronisation des processus qui ouvrent
en mode bloquant un tube nommé.</B></FONT><FONT SIZE=5><BR>L'opération d'ouverture sur un tube nommé est bloquante en lecture.<BR>Le processus attend qu'un autre processus ouvre la fifo en écriture.<BR>L'ouverture en écriture est aussi bloquante, avec attente qu'un autre
processus ouvre la fifo en lecture. L'ouverture bloquante se termine
de façons synchrone pour les deux processus.<BR>Ainsi un unique processus ne peut ouvrire à la fois en lecture et écriture
un tube nommé.<BR>En mode non bloquant (O_NONBLOCK, O_NDELAY), seule l'ouverture en
lecture réussit dans tous les cas. L'ouverture en écriture en mode
non bloquant d'un tube nommé ne fonctionne que si un autre processus a
déjà ouvert en mode non bloquant le tube en lecture, ou bien qu'il est
bloqué dans l'appel d'une ouverture en lecture en mode bloquant. Ceci
pour éviter que le processus qui vient d'ouvrir le tube nommé,
n'écrive dans le tube avant qu'il n'y ait de lecteur (qu'un processus
ait ouvert le tube en lecture) et ce qui engendrerait un signal SIGPIPE
(tube détruit), ce qui n'est pas vrai car le tube n'a pas encore été
utilisé.<BR>
<BR>
</FONT><!--TOC subsection <FONT SIZE=5>Suppression d'un tube nommé </FONT>-->

<H3><FONT SIZE=5>11.6.2&nbsp;&nbsp; Suppression d'un tube nommé </FONT></H3><!--SEC END -->
<FONT SIZE=5>L'utilisation de </FONT><FONT SIZE=5><TT>rm</TT></FONT><FONT SIZE=5> ou </FONT><FONT SIZE=5><TT>unlink</TT></FONT><FONT SIZE=5> ne fait que détruire la référence, le tube n'est réellement détruit que lorsque son compteur de liens internes et externes est nul.<BR>Une fois que tous les liens par référence sont détruits, le tube nommé devient un tube ordinaire. <BR> </FONT><!--TOC subsection <FONT SIZE=5> les appels popen et pclose </FONT>-->

<H3><FONT SIZE=5>11.6.3&nbsp;&nbsp;  les appels popen et pclose </FONT></H3><!--SEC END -->
<FONT SIZE=5>Une interface plus facile pour lancer un coprocessus est proposé avec les primitives popen et pclose.<BR>
<BR>

</FONT><!--TOC chapter <FONT SIZE=5>La gestion des terminaux</FONT>-->

<H1><FONT SIZE=5>Chapitre&nbsp;12&nbsp;&nbsp; La gestion des terminaux</FONT></H1><!--SEC END -->
<A NAME="terminaux"></A><FONT SIZE=5>Les terminaux ont un rôle fondamental puisqu'ils permettent l'interaction entre les utilisateurs et les applications. Vis-à-vis des processus dits interactifs, les terminaux ont une double fonction&nbsp;:
</FONT><DL COMPACT=compact>
<DT><FONT SIZE=5>
</FONT><FONT SIZE=5>fonction de "fichier"</FONT><DD><FONT SIZE=5> sur lequel il est possible de lire ou d'écrire.
</FONT>
<DT><FONT SIZE=5>fonction de contrôle</FONT><DD><FONT SIZE=5> &nbsp;: la possibilité de faire parvenir des signaux à un ensemble particulier de processus connectés.
</FONT></DL><FONT SIZE=5>Un terminal correspond à l'un de ces types &nbsp;:
</FONT><DL COMPACT=compact>
<DT><FONT SIZE=5>
</FONT><FONT SIZE=5>terminal physique</FONT><DD><FONT SIZE=5>, connecté à un port de communication de la machine
(port série, port parallèle).
On compte dans les terminaux physiques les imprimantes mais pas les Terminaux X !
</FONT><FONT SIZE=5>physique</FONT><FONT SIZE=5>
</FONT>
<DT><FONT SIZE=5>pseudo-terminal</FONT><DD><FONT SIZE=5>, par exemple une fenêtre de terminal X ou une connection ETHERNET avec un autre site UNIX, une connections modem etc.
</FONT></DL><FONT SIZE=5> </FONT><FONT SIZE=5>pseudo-terminaux</FONT><BR>
<BR>
<FONT SIZE=5>Dans tous les cas on trouvera une représentation sous forme de fichier spécial en mode caractère dans le répertoire /dev. En standard un fichier de terminal s'appelle /dev/tty</FONT><FONT SIZE=5><EM>xy</EM></FONT><FONT SIZE=5>. On trouvera aussi sur fillmore des fichiers de pseudo terminaux dans /dev/pty/tty</FONT><FONT SIZE=5><EM>xy</EM></FONT><FONT SIZE=5>.<BR>Le paramétrage des terminaux et de la ligne de communication est différent sous BSD et SYSTEM V.<BR>La norme POSIX est basée sur SYSTEM V.<BR>
</FONT><!--TOC section <FONT SIZE=5>Acquisition d'un descripteur associé à un terminal</FONT>-->

<H2><FONT SIZE=5>12.1&nbsp;&nbsp; Acquisition d'un descripteur associé à un terminal</FONT></H2><!--SEC END -->
<FONT SIZE=5>
En standard, l'acquisition d'un descripteur de terminal se fait par héritage à la naissance du processus. On hérite en particulier du terminal de contrôle. Pour ouvrir un terminal, on utilise la primitive </FONT><FONT SIZE=5><TT>open</TT></FONT><FONT SIZE=5> avec une référence du type /dev/ttyxy, qui est celle d'un fichier spécial caractères correspondant au terminal à ouvrir. Dans le cas où l'on cherche à ouvrir le terminal de contrôle du processus, il faut utiliser la référence symbolique "</FONT><FONT SIZE=5><EM>/dev/tty</EM></FONT><FONT SIZE=5>". Si le terminal n'est pas prêt, la primitive </FONT><FONT SIZE=5><TT>open</TT></FONT><FONT SIZE=5> est bloquante, on utilisera pour un appel non bloquant l'indicateur O_NONBLOCK.<BR>
<BR>
</FONT><!--TOC subsubsection <FONT SIZE=5>Test d'association d'un descripteur avec un terminal</FONT>-->

<H4><FONT SIZE=5> Test d'association d'un descripteur avec un terminal</FONT></H4><!--SEC END -->
<FONT SIZE=5>La primitive 
</FONT><PRE><FONT SIZE=5><TT>
        #include &lt;unistd.h&gt;
        int isatty(int desc);
</TT></FONT></PRE><FONT SIZE=5> 
</FONT><FONT SIZE=5>appels systèmes!isatty@</FONT><FONT SIZE=5><TT>isatty</TT></FONT><FONT SIZE=5>
<BR>
<BR>
permet de tester si le descripteur est (1) associé ou non (0) à un terminal.<BR>La primitive 
</FONT><PRE><FONT SIZE=5><TT>
        #include &lt;unistd.h&gt;
        char *ttyname(int desc);
</TT></FONT></PRE><FONT SIZE=5> 
</FONT><FONT SIZE=5>appels systèmes!ttyname@</FONT><FONT SIZE=5><TT>ttyname</TT></FONT><FONT SIZE=5>
<BR>
<BR>
renvoie, lorsque le descripteur est associé à un terminal, le nom de celui-ci grâce à un pointeur en zone statique. Sinon elle retourne NULL.<BR>Exemple&nbsp;:
</FONT><BLOCKQUOTE><FONT SIZE=5>
</FONT><FONT SIZE=5><TT>da=open("/dev/tty",O_RDWR));<BR>db=open("/dev/ttyp2",O_RDWR));<BR>a=ttyname(da); printf(" %s</TT></FONT><FONT SIZE=5><TT>\</TT></FONT><FONT SIZE=5><TT>t",a);<BR>b=ttyname(db);printf(" %s</TT></FONT><FONT SIZE=5><TT>\</TT></FONT><FONT SIZE=5><TT>t",b); printf(" %s </TT></FONT><FONT SIZE=5><TT>\</TT></FONT><FONT SIZE=5><TT>n",a);<BR></TT></FONT><FONT SIZE=5>
</FONT></BLOCKQUOTE><FONT SIZE=5>
nous donne&nbsp;:
</FONT><BLOCKQUOTE><FONT SIZE=5>
</FONT><PRE><FONT SIZE=5><TT>
 /dev/tty    /dev/ttyp2   /dev/ttyp2 
</TT></FONT></PRE><FONT SIZE=5> </FONT><FONT SIZE=5>static</FONT><FONT SIZE=5>
</FONT></BLOCKQUOTE><FONT SIZE=5>
</FONT><!--TOC section <FONT SIZE=5>Terminal de contrôle - Sessions - Groupes de processus</FONT>-->

<H2><FONT SIZE=5>12.2&nbsp;&nbsp; Terminal de contrôle - Sessions - Groupes de processus</FONT></H2><!--SEC END -->
<FONT SIZE=5>L'ensemble des processus existant dans le système à un moment donné est partitionné en sessions&nbsp;: tout processus appartient à une seule et unique session, on hérite de la session du processus père.<BR>Un processus qui n'est pas </FONT><FONT SIZE=5><EM>leader</EM></FONT><FONT SIZE=5> de groupe peut créer une nouvelle session avec la primitive
</FONT><PRE><FONT SIZE=5><TT>
        #include &lt;unistd.h&gt;
        pid_t setsid(void);
</TT></FONT></PRE><FONT SIZE=5> 
</FONT><FONT SIZE=5>appels systèmes!setsid@</FONT><FONT SIZE=5><TT>setsid</TT></FONT><FONT SIZE=5>

Lors du login, le processus shell créé est le </FONT><FONT SIZE=5><EM>leader</EM></FONT><FONT SIZE=5> d'une nouvelle session. Une tel session est caractérisée par le terminal de l'utilisateur (sur lequel il se loge) qui devient le </FONT><FONT SIZE=5><B>terminal de contrôle</B></FONT><FONT SIZE=5> de la session. Tous les processus de la session sont informés de la frappe des caractères de contrôle sur le terminal
</FONT><PRE><FONT SIZE=5><TT>
intr, quit, susp.
</TT></FONT></PRE><FONT SIZE=5> </FONT><FONT SIZE=5>intr</FONT><FONT SIZE=5>quit</FONT><FONT SIZE=5>susp</FONT><FONT SIZE=5>
</FONT><FONT SIZE=5>/dev/tty</FONT><FONT SIZE=5>
Le terminal de contrôle est symbolisé par la référence "</FONT><FONT SIZE=5><TT>/dev/tty</TT></FONT><FONT SIZE=5>".<BR>Lorsque le </FONT><FONT SIZE=5><EM>leader</EM></FONT><FONT SIZE=5> d'une session attachée à un terminal se </FONT><FONT SIZE=5><B>termine</B></FONT><FONT SIZE=5> tous les processus de la session reçoivent le signal SIGHUP et sont alors interrompus (on réalise sur fillmore une fin de session en tuant la fenêtre console, ce qui termine le processus shell leader ...) sauf si un handler a été positionné pour le signal SIGHUP.
</FONT><FONT SIZE=5>SIGHUP</FONT><FONT SIZE=5>
On peut réaliser ceci en sh avec la commande </FONT><FONT SIZE=5><TT>nohup</TT></FONT><FONT SIZE=5>, ou la commande </FONT><FONT SIZE=5><TT>trap</TT></FONT><FONT SIZE=5> qui permettent d'ignorer le signal SIGHUP. Le terminal de contrôle et la session d'un tel processus résistant n'est pas normée dans POSIX. <BR>
<BR>
</FONT><!--TOC subsection <FONT SIZE=5>Acquisition d'un terminal de contrôle par une session</FONT>-->

<H3><FONT SIZE=5>12.2.1&nbsp;&nbsp; Acquisition d'un terminal de contrôle par une session</FONT></H3><!--SEC END -->
<FONT SIZE=5>
</FONT><FONT SIZE=5>terminal de contrôle</FONT><FONT SIZE=5>
</FONT><FONT SIZE=5><B>A sa création, une session n'a pas de terminal de contrôle!</B></FONT><FONT SIZE=5><BR>L'acquisition d'un terminal de contrôle n'est pas normée, mais, si l'on ouvre un terminal qui n'est pas le terminal de contrôle d'une autre session avec un processus </FONT><FONT SIZE=5><EM>leader</EM></FONT><FONT SIZE=5> qui n'a pas de terminal de contrôle, alors le terminal ouvert devient le terminal de contrôle de la session. <BR>
<BR>
Un terminal peut être le terminal de contrôle d'au plus une session.

</FONT><!--TOC subsection <FONT SIZE=5>Groupes de processus</FONT>-->

<H3><FONT SIZE=5>12.2.2&nbsp;&nbsp; Groupes de processus</FONT></H3><!--SEC END -->
<FONT SIZE=5>
Les </FONT><FONT SIZE=5><B>groupes de processus</B></FONT><FONT SIZE=5> sont un raffinement POSIX de la notion de session. Ils permettent de travailler avec des groupes de processus sans toutes les obligations liées aux sessions.<BR>
<BR>
L'objectif est de spécifier l'ensemble des processus qui sont interactifs sur un terminal donné à un moment donné, et donc qui ont le droit de lire sur le terminal et de plus sont informés de la frappe des caractères de contrôle.<BR>
<BR>
Un </FONT><FONT SIZE=5><EM>groupe de processus</EM></FONT><FONT SIZE=5> est identifié par le PID du </FONT><FONT SIZE=5><EM>leader</EM></FONT><FONT SIZE=5> du groupe, à la naissance, un processus hérite du groupe de son père. La primitive suivante&nbsp;:
</FONT><PRE><FONT SIZE=5><TT>
        #include &lt;unistd.h&gt;
        pid_t setpgid(pid_t pid, pid_t id_grp);
</TT></FONT></PRE><FONT SIZE=5> 
</FONT><FONT SIZE=5>appels systèmes!setpgid@</FONT><FONT SIZE=5><TT>setpgid</TT></FONT><FONT SIZE=5>

permet de rattacher le processus </FONT><FONT SIZE=5><EM>pid</EM></FONT><FONT SIZE=5> au groupe </FONT><FONT SIZE=5><EM>id_grp</EM></FONT><FONT SIZE=5>.<BR>Si </FONT><FONT SIZE=5><EM>pid</EM></FONT><FONT SIZE=5> est nul c'est le processus courant qui est rattaché.<BR>Si </FONT><FONT SIZE=5><EM>id_grp</EM></FONT><FONT SIZE=5> est nul le numéro déduit de </FONT><FONT SIZE=5><EM>pid</EM></FONT><FONT SIZE=5> est utilisé.<BR>Dans tous les cas soit le groupe existe et le processus est rattaché, soit le groupe est créé et le processus traité devient le leader du groupe.<BR>Un processus ne peut être rattaché qu'à un groupe appartenant à la même session que lui,c'est-à-dire, que les groupes sont définis à l'intérieur des sessions.<BR>La primitive 
</FONT><PRE><FONT SIZE=5><TT>
        #include &lt;unistd.h&gt;
        pid_t getpgrp(void);
</TT></FONT></PRE><FONT SIZE=5> 
</FONT><FONT SIZE=5>appels systèmes!getpgrp@</FONT><FONT SIZE=5><TT>getpgrp</TT></FONT><FONT SIZE=5>

renvoie le numéro du </FONT><FONT SIZE=5><EM>leader</EM></FONT><FONT SIZE=5> du groupe du processus courant.<BR>Sur certaines machines, la primitive 
</FONT><PRE><FONT SIZE=5><TT>
        #include &lt;unistd.h&gt;
        pid_t getgrp2(pid_t pid);
</TT></FONT></PRE><FONT SIZE=5>
</FONT><FONT SIZE=5>appels systèmes!getgrp2@</FONT><FONT SIZE=5><TT>getgrp2</TT></FONT><FONT SIZE=5>

renvoie le numéro du groupe du processus </FONT><FONT SIZE=5><EM>pid</EM></FONT><FONT SIZE=5>.<BR>
<BR>

</FONT><!--TOC subsection <FONT SIZE=5>Premier Plan et Arrière Plan</FONT>-->

<H3><FONT SIZE=5>12.2.3&nbsp;&nbsp; Premier Plan et Arrière Plan</FONT></H3><!--SEC END -->
<FONT SIZE=5>Le </FONT><FONT SIZE=5><B>premier plan</B></FONT><FONT SIZE=5> est l'unique sous-groupe de processus de la session qui est en mode interactif. Les processus de ce groupe peuvent lire et écrire sur le terminal, ce sont les processus qui reçoivent les signaux engendrés par les caractères de contrôle.
</FONT><FONT SIZE=5>premier plan</FONT><FONT SIZE=5>arrière plan</FONT><FONT SIZE=5>
Les groupes en </FONT><FONT SIZE=5><B>arrière plan</B></FONT><FONT SIZE=5> sont tous les autres sous-groupes de
la session. En csh/ksh ce sont tous les processus lancés en tâche de
fond (&amp;), que l'on peut manipuler avec les commandes </FONT><FONT SIZE=5><TT>fg</TT></FONT><FONT SIZE=5> et </FONT><FONT SIZE=5><TT>bg</TT></FONT><FONT SIZE=5>.<BR>
<BR>
Ces groupes ne peuvent lire sur le terminal (signaux SIGTTIN et SIGTTOU), de plus à la frappe de caractère de contrôle sur le terminal ils ne reçoivent pas de signaux. <BR>
<BR>
Avant POSIX les processus lancés en tâche de fond par le shell ignoraient les signaux SIGINT et SIGQUIT et avaient leur entrée standard redirigée sur le "trou noir"&nbsp;: /dev/null.
</FONT><FONT SIZE=5>/dev/null</FONT><FONT SIZE=5>
</FONT><!--TOC subsection <FONT SIZE=5>Quelques fonctions</FONT>-->

<H3><FONT SIZE=5>12.2.4&nbsp;&nbsp; Quelques fonctions</FONT></H3><!--SEC END -->
<FONT SIZE=5>Quelques fonctions d'information sur les sessions et les groupes.<BR>Elles nécessite toute l'include 
</FONT><PRE><FONT SIZE=5><TT>
#include &lt;unistd.h&gt;
</TT></FONT></PRE><FONT SIZE=5>
La primitive 
</FONT><PRE><FONT SIZE=5><TT>
        pid_t tcgetsid(int desc);
</TT></FONT></PRE><FONT SIZE=5> 
</FONT><FONT SIZE=5>appels systèmes!tcgetsid@</FONT><FONT SIZE=5><TT>tcgetsid</TT></FONT><FONT SIZE=5>

renvoie l'identité du processus leader.<BR>La primitive renvoie -1 si le terminal n'est pas terminal de contrôle.<BR></FONT><PRE><FONT SIZE=5><TT>
        pid_t getsid(pid_t pid);
</TT></FONT></PRE><FONT SIZE=5>
</FONT><FONT SIZE=5>appels systèmes!getsid@</FONT><FONT SIZE=5><TT>getsid</TT></FONT><FONT SIZE=5>

renvoie l'identité du leader de la session du processus </FONT><FONT SIZE=5><EM>pid</EM></FONT><FONT SIZE=5>.
 Si </FONT><FONT SIZE=5><EM>pid</EM></FONT><FONT SIZE=5> ==0 c'est le pid du processus courant qui est utilisé,
 un appel équivalent à </FONT><CODE><FONT SIZE=5><TT>getsid(getpid())</TT></FONT></CODE><FONT SIZE=5> mais avec un appel système de moins.<BR>
<BR>
</FONT><!--TOC paragraph <FONT SIZE=5>Changement du groupe en premier plan</FONT>-->

<H5><FONT SIZE=5> Changement du groupe en premier plan</FONT></H5><!--SEC END -->
<FONT SIZE=5>
La primitive
</FONT><PRE><FONT SIZE=5><TT>
        pid_t  tcgetgrp(int desc);
</TT></FONT></PRE><FONT SIZE=5> 
</FONT><FONT SIZE=5>appels systèmes!tcgetgrp@</FONT><FONT SIZE=5><TT>tcgetgrp</TT></FONT><FONT SIZE=5>

renvoie le groupe de processus en premier plan associé au terminal de contrôle indiqué par le descripteur </FONT><FONT SIZE=5><EM>desc</EM></FONT><FONT SIZE=5>.<BR>Ceci s'applique évidement uniquement au terminal de contrôle de la session du processus courant.<BR>La primitive
</FONT><PRE><FONT SIZE=5><TT>
pid_t tcsetpgrp(int desc, pid_t id_grp);
</TT></FONT></PRE><FONT SIZE=5> 
</FONT><FONT SIZE=5>appels systèmes!tcsetpgrp@</FONT><FONT SIZE=5><TT>tcsetpgrp</TT></FONT><FONT SIZE=5>

permet de placer en premier plan le groupe </FONT><FONT SIZE=5><EM>id_grp</EM></FONT><FONT SIZE=5> dans la session associée au terminal pointé par </FONT><FONT SIZE=5><EM>desc</EM></FONT><FONT SIZE=5>.<BR>
<BR>

</FONT><!--TOC section <FONT SIZE=5>Les drivers logiciels de terminaux</FONT>-->

<H2><FONT SIZE=5>12.3&nbsp;&nbsp; Les drivers logiciels de terminaux</FONT></H2><!--SEC END -->
<FONT SIZE=5>Les terminaux physiques sont manipulés par des drivers spécifiques
pour chaque terminal(en fonction du modèle, de la marque, de l'age, etc
...). Sur cet ensemble de drivers, on trouve une super-structure
logicielle, les </FONT><FONT SIZE=5><B>tty driver</B></FONT><FONT SIZE=5>, drivers logiciels de terminaux. Ces
drivers permettent de travailler sur l'ensemble des terminaux de façon
homogène et transparente (polymorphisme).<BR>Structure de description du mode de communication &nbsp;: la structure termios.<BR>
<BR>


</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML062.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 12.1&nbsp;: Structure de la communication entre le processus et le terminal.</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="terminaux1"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>

</FONT><!--TOC subsection <FONT SIZE=5>La structure </FONT><FONT SIZE=5><TT>termios</TT></FONT>-->

<H3><FONT SIZE=5>12.3.1&nbsp;&nbsp; La structure </FONT><FONT SIZE=5><TT>termios</TT></FONT></H3><!--SEC END -->
<FONT SIZE=5>En POSIX, toutes les caractéristiques d'une voie de communication sont rassemblées dans la structure termios prédéfinie dans le fichier </FONT><CODE><FONT SIZE=5><TT> &lt;termios.h&gt;</TT></FONT></CODE><FONT SIZE=5>.<BR></FONT><FONT SIZE=5>termios</FONT><FONT SIZE=5>
Sur un HP/UX &nbsp;:
</FONT><PRE><FONT SIZE=5><TT>
/* machine: fillmore */

#define NCCS 16

   typedef unsigned int tcflag_t;
   typedef unsigned char cc_t;

     struct termios {
        tcflag_t        c_iflag;        /* Input modes */
        tcflag_t        c_oflag;        /* Output modes */
        tcflag_t        c_cflag;        /* Control modes */
        tcflag_t        c_lflag;        /* Local modes */
        tcflag_t        c_reserved;     /* Reserved for future use */
        cc_t            c_cc[NCCS];     /* Control characters */
     };
</TT></FONT></PRE><FONT SIZE=5> Le type tcflag_t est considéré comme un tableau de bits. On peut donc
tester le positionnement d'un indicateur par un &amp; (conjonction binaire) avec sa macro-définition.<BR>Par exemple:<BR></FONT><CODE><FONT SIZE=5><TT>(c_iflag &amp; IXOFF )</TT></FONT></CODE><FONT SIZE=5> est vrai si le drapeau est positionné.<BR>
<BR>

</FONT><!--TOC subsection <FONT SIZE=5>Modes d'entrée</FONT>-->

<H3><FONT SIZE=5>12.3.2&nbsp;&nbsp; Modes d'entrée</FONT></H3><!--SEC END -->
<FONT SIZE=5>
Macro-définitions des drapeaux du mode d'entrée &nbsp;:
</FONT><DL COMPACT=compact>
<DT><FONT SIZE=5>
</FONT><FONT SIZE=5>IGNBRK</FONT><DD><FONT SIZE=5> Ignorer </FONT><FONT SIZE=5>&lt;</FONT><FONT SIZE=5>break</FONT><FONT SIZE=5>&gt;</FONT><FONT SIZE=5> 
</FONT>
<DT><FONT SIZE=5>BRKINT</FONT><DD><FONT SIZE=5> Signal SIGINT à la frappe de </FONT><FONT SIZE=5>&lt;</FONT><FONT SIZE=5>break</FONT><FONT SIZE=5>&gt;</FONT><FONT SIZE=5> 
</FONT>
<DT><FONT SIZE=5>IGNPAR</FONT><DD><FONT SIZE=5> Ignorer les erreurs de parité
</FONT>
<DT><FONT SIZE=5>PARMRK</FONT><DD><FONT SIZE=5> Marquer les erreurs de parité 
</FONT>
<DT><FONT SIZE=5>INPCK</FONT><DD><FONT SIZE=5> Vérification de parité
</FONT>
<DT><FONT SIZE=5>ISTRIP</FONT><DD><FONT SIZE=5> Strip character&nbsp;: compacter sur 7 bits
</FONT>
<DT><FONT SIZE=5>INLCR</FONT><DD><FONT SIZE=5> Transformer NL en CR 
</FONT>
<DT><FONT SIZE=5>IGNCR</FONT><DD><FONT SIZE=5> Ignorer CR 
</FONT>
<DT><FONT SIZE=5>ICRNL</FONT><DD><FONT SIZE=5> Transformer CR en NL 
</FONT>
<DT><FONT SIZE=5>_IUCLC</FONT><DD><FONT SIZE=5> Transformer Majuscules en minuscules
</FONT>
<DT><FONT SIZE=5>IXON</FONT><DD><FONT SIZE=5> Autoriser l'arrêt du flux avec (Ctrl-S/Ctrl-Q)
</FONT>
<DT><FONT SIZE=5>_IXANY</FONT><DD><FONT SIZE=5> N'importe quel caractère relance le flux.
</FONT>
<DT><FONT SIZE=5>IXOFF</FONT><DD><FONT SIZE=5> Interdit l'arrêt du flux.
</FONT></DL><FONT SIZE=5>

</FONT><!--TOC subsection <FONT SIZE=5>Modes de sortie</FONT>-->

<H3><FONT SIZE=5>12.3.3&nbsp;&nbsp; Modes de sortie</FONT></H3><!--SEC END -->
<FONT SIZE=5>
Macro-définitions des drapeaux du mode de sortie &nbsp;:
</FONT><DL COMPACT=compact>
<DT><FONT SIZE=5>
 </FONT><FONT SIZE=5>OPOST</FONT><DD><FONT SIZE=5> Postprocessing de la sortie.
 </FONT>
<DT><FONT SIZE=5>OLCUC</FONT><DD><FONT SIZE=5> Transformer minuscule en MAJUSCULE en sortie.
 </FONT>
<DT><FONT SIZE=5>ONLCR</FONT><DD><FONT SIZE=5> NL en CR+NL.
 </FONT>
<DT><FONT SIZE=5>OCRNL</FONT><DD><FONT SIZE=5> CR en NL .
 </FONT>
<DT><FONT SIZE=5>ONOCR</FONT><DD><FONT SIZE=5> No CR en colonne 0.
 </FONT>
<DT><FONT SIZE=5>ONLRET</FONT><DD><FONT SIZE=5> NL en NL+CR.
</FONT></DL><!--TOC subsection <FONT SIZE=5>Modes de contrôle</FONT>-->

<H3><FONT SIZE=5>12.3.4&nbsp;&nbsp; Modes de contrôle</FONT></H3><!--SEC END -->
<FONT SIZE=5>
Description plus bas niveau de la ligne de communication. Utilisés
surtout pour des périphériques de communication (modems).
</FONT><DL COMPACT=compact>
<DT><FONT SIZE=5>
</FONT><FONT SIZE=5>CLOCAL</FONT><DD><FONT SIZE=5> Ouverture non bloquante, sinon l'ouverture est bloquante tant que
 la ligne n'est pas prête (par exemple un modem), sauf demande contraire dans
 l'appel de </FONT><FONT SIZE=5><TT>open</TT></FONT><FONT SIZE=5> avec </FONT><FONT SIZE=5><TT>O_NONBLOCK</TT></FONT><FONT SIZE=5>.
</FONT>
<DT><FONT SIZE=5>HUPCL</FONT><DD><FONT SIZE=5> hangup sur le dernier </FONT><FONT SIZE=5><TT>close</TT></FONT><FONT SIZE=5>.
</FONT></DL><FONT SIZE=5>

</FONT><!--TOC subsection <FONT SIZE=5>Modes locaux</FONT>-->

<H3><FONT SIZE=5>12.3.5&nbsp;&nbsp; Modes locaux</FONT></H3><!--SEC END -->
<FONT SIZE=5>
Ce sont ces modes-là qui ont le plus d'impact au niveau logiciel.
Ce sont eux qui indiquent les traitements réalisés sur les caractères de contrôle et déterminent le comportement de la primitive </FONT><FONT SIZE=5><TT>read</TT></FONT><FONT SIZE=5>.
</FONT><DL COMPACT=compact>
<DT><FONT SIZE=5>
</FONT><FONT SIZE=5>ISIG</FONT><DD><FONT SIZE=5> les caractères de contrôle </FONT><FONT SIZE=5><TT>intr, quit</TT></FONT><FONT SIZE=5>, etc sont transformés en signaux.</FONT><BR>
<BR>

<DT><FONT SIZE=5>ECHO</FONT><DD><FONT SIZE=5> Les caractères frappés au clavier sont après transformation, définie dans le mode d'entrée, insérés dans le flux de sortie (écho des caractères en sh par exemple).</FONT><BR>
<BR>

<DT><FONT SIZE=5>ECHOE</FONT><DD><FONT SIZE=5> dans ce mode et en mode ICANON, le caractère de contrôle
 </FONT><FONT SIZE=5><TT>erase</TT></FONT><FONT SIZE=5> a un écho provoquant l'effacement du dernier caractère sur l'écran.</FONT><BR>
<BR>

<DT><FONT SIZE=5>ECHOK</FONT><DD><FONT SIZE=5> dans ce mode et en mode ICANON, le caractère de contrôle </FONT><FONT SIZE=5><TT>kill</TT></FONT><FONT SIZE=5> a comme écho le caractère de fin de ligne.</FONT><BR>
<BR>

<DT><FONT SIZE=5>NOFLSH</FONT><DD><FONT SIZE=5> dans ce mode, il n'y a pas de vidange par défaut des
 tampons de lecture et d'écriture à la prise en compte des
 caractères </FONT><FONT SIZE=5><TT>intr, quit, susp</TT></FONT><FONT SIZE=5> en mode ISIG. </FONT><BR>
<BR>

<DT><FONT SIZE=5>TOSTOP</FONT><DD><FONT SIZE=5> dans ce mode, les processus du groupe de processus en arrière-plan du terminal sont suspendus, lorsqu'ils essaient d'écrire sur le terminal, par le signal SIGTTOU.
</FONT>
<DT><FONT SIZE=5>ICANON</FONT><DD><FONT SIZE=5> est un mode complexe, voir plus bas.
</FONT></DL><FONT SIZE=5>
</FONT><!--TOC paragraph <FONT SIZE=5>les modes canoniques et non-canoniques</FONT>-->

<H5><FONT SIZE=5> les modes canoniques et non-canoniques</FONT></H5><!--SEC END -->
<FONT SIZE=5>
Le choix de l'option ICANON a un effet sur la primitive </FONT><FONT SIZE=5><TT>read</TT></FONT><FONT SIZE=5> en
particulier l'accessibilité des caractères frappés dépend de choix
effectués sur ce mode.<BR></FONT><DL COMPACT=compact>
<DT><FONT SIZE=5>
</FONT><FONT SIZE=5>Mode canonique</FONT><DD><FONT SIZE=5> : c'est le mode de fonctionnement d'un terminal en mode interactif, il se caractérise de la manière suivante&nbsp;:
 le tampon d'entrée est structuré en ligne, une ligne étant une suite de caractères terminée par le caractère newline de code ASCII 10 (le newline du C). Ceci signifie que les caractères lus au cours d'une opération de lecture </FONT><FONT SIZE=5><TT>read</TT></FONT><FONT SIZE=5> sur le terminal sont extraits dans une et une seule ligne. Donc tout caractère non suivi d'un newline n'est pas accessible en lecture&nbsp;! Une opération de lecture ne peut avoir lieu à cheval sur plusieurs lignes.
</FONT>
<DT><FONT SIZE=5>Mode non-canonique</FONT><DD><FONT SIZE=5> : la structure de ligne ne définit plus le
 critère d'accessibilité des caractères et les 4 caractères </FONT><FONT SIZE=5><TT>erase, kill, eof, eol</TT></FONT><FONT SIZE=5> perdent leur qualité de caractères de contrôle.
</FONT></DL><FONT SIZE=5>Les critères d'accessibilité en mode non-canonique sont définis par deux
caractères spéciaux </FONT><FONT SIZE=5><TT>MIN</TT></FONT><FONT SIZE=5> et </FONT><FONT SIZE=5><TT>TIME</TT></FONT><FONT SIZE=5> du tableau </FONT><FONT SIZE=5><TT>c_cc</TT></FONT><FONT SIZE=5> de
la structure </FONT><FONT SIZE=5><TT>termios</TT></FONT><FONT SIZE=5>.<BR>Si </FONT><FONT SIZE=5><TT>MIN</TT></FONT><FONT SIZE=5> </FONT><FONT SIZE=5>&gt;</FONT><FONT SIZE=5> 0 et </FONT><FONT SIZE=5><TT>TIME</TT></FONT><FONT SIZE=5> </FONT><FONT SIZE=5>&gt;</FONT><FONT SIZE=5> 0 , </FONT><FONT SIZE=5><TT>TIME</TT></FONT><FONT SIZE=5> est un minuteur inter-caractères de granularité 0.1 seconde.
</FONT><UL>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5> A chaque caractère reçu le minuteur est repositionné.
</FONT>
<LI><FONT SIZE=5> Si le nombre de caractères reçu avant l'expiration du minuteur est égal à </FONT><FONT SIZE=5><TT>MIN</TT></FONT><FONT SIZE=5> l'appel </FONT><FONT SIZE=5><TT>read</TT></FONT><FONT SIZE=5> retourne ces caractère au processus.
</FONT>
<LI><FONT SIZE=5> Si le minuteur expire avant la reception de </FONT><FONT SIZE=5><TT>MIN</TT></FONT><FONT SIZE=5> caractères, l'appel </FONT><FONT SIZE=5><TT>read</TT></FONT><FONT SIZE=5> retourne les caractères reçus au processus.
</FONT>
<LI><FONT SIZE=5> Remarquer qu'au moins un caractère sera renvoyé. Le </FONT><FONT SIZE=5><TT>read</TT></FONT><FONT SIZE=5> est bloquant tant que le premier caractère n'est pas reçu et que </FONT><FONT SIZE=5><TT>MIN</TT></FONT><FONT SIZE=5> et </FONT><FONT SIZE=5><TT>TIME</TT></FONT><FONT SIZE=5> ne sont pas mis en marche.
</FONT></UL><FONT SIZE=5>Pour certaines valeurs de </FONT><FONT SIZE=5><TT>MIN</TT></FONT><FONT SIZE=5> et </FONT><FONT SIZE=5><TT>TIME</TT></FONT><FONT SIZE=5>&nbsp;:
</FONT><DL COMPACT=compact>
<DT><FONT SIZE=5>
 </FONT><FONT SIZE=5><TT>MIN</TT></FONT><FONT SIZE=5> </FONT><FONT SIZE=5>&gt;</FONT><FONT SIZE=5> 0, </FONT><FONT SIZE=5><TT>TIME</TT></FONT><FONT SIZE=5> = 0</FONT><DD><FONT SIZE=5> Même comportement mais seul </FONT><FONT SIZE=5><TT>MIN</TT></FONT><FONT SIZE=5> est significatif. Le </FONT><FONT SIZE=5><TT>read</TT></FONT><FONT SIZE=5> est bloquant jusqu'à la reception de </FONT><FONT SIZE=5><TT>MIN</TT></FONT><FONT SIZE=5> caractères.
 </FONT>
<DT><FONT SIZE=5><TT>MIN</TT></FONT><FONT SIZE=5> = 0, </FONT><FONT SIZE=5><TT>TIME</TT></FONT><FONT SIZE=5> </FONT><FONT SIZE=5>&gt;</FONT><FONT SIZE=5> 0</FONT><DD><FONT SIZE=5> comme le nombre de caractères à lire est nul (</FONT><FONT SIZE=5><TT>MIN</TT></FONT><FONT SIZE=5> = 0), le minuteur est initialisé au debut de l'appel </FONT><FONT SIZE=5><TT>read</TT></FONT><FONT SIZE=5>. L'appel </FONT><FONT SIZE=5><TT>read</TT></FONT><FONT SIZE=5> retourne soit parce qu'un caractère a été lu ou que le délai a expiré.
 </FONT>
<DT><FONT SIZE=5><TT>MIN</TT></FONT><FONT SIZE=5> = 0, </FONT><FONT SIZE=5><TT>TIME</TT></FONT><FONT SIZE=5> = 0</FONT><DD><FONT SIZE=5> mode non bloquant &nbsp;: l'appel </FONT><FONT SIZE=5><TT>read</TT></FONT><FONT SIZE=5> retourne les caractères disponibles (le minimum des caractères disponibles et du nombre de caractères demandés dans l'appel de </FONT><FONT SIZE=5><TT>read</TT></FONT><FONT SIZE=5>).
</FONT></DL><FONT SIZE=5>
Les valeurs les plus couramment utilisées sont </FONT><FONT SIZE=5><TT>MIN</TT></FONT><FONT SIZE=5>=1, </FONT><FONT SIZE=5><TT>TIME</TT></FONT><FONT SIZE=5>=0, ce qui est le mode CBREAK des versions BSD. Ce mode permet
d'avoir une saisie bloquante de chaque caractère frappé au clavier (vi utilise
ce mode), le </FONT><FONT SIZE=5><TT>read</TT></FONT><FONT SIZE=5> retourne dès qu'un caractère est frappé.<BR>
<BR>

</FONT><!--TOC subsection <FONT SIZE=5>Les caractères spéciaux</FONT>-->

<H3><FONT SIZE=5>12.3.6&nbsp;&nbsp; Les caractères spéciaux</FONT></H3><!--SEC END -->
<FONT SIZE=5>Les caractères spéciaux sont définis par le tableau c_cc de la structure termios. Les positions et les valeurs initiales du rôle des différents caractères spéciaux sont les suivantes&nbsp;:<BR>
<BR>
</FONT><TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>nom</FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>code</FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>caractère</FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>EOF</FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>VEOF</FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>Control-D</FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>EOL</FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>VEOL</FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>NUL</FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>ERASE</FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>VERASE</FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>#</FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>INTR</FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>VINTR</FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>DEL</FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>KILL</FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>VKILL</FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>@</FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>MIN</FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>VMIN</FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>NUL</FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>QUIT</FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>VQUIT</FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>Control-pipe</FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>START</FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>VSTART</FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>Control-Q</FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>STOP</FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>VSTOP</FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>Control-S</FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>SUSP</FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>VSUSP</FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>disabled</FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>SWTCH</FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>VSWTCH</FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>NUL</FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>TIME</FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>VTIME</FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>Control-D</FONT></TD>
</TR></TABLE><BR>
<FONT SIZE=5>
</FONT><!--TOC subsection <FONT SIZE=5>Manipulation du driver logiciel de terminaux 
et de la structure termios</FONT>-->

<H3><FONT SIZE=5>12.3.7&nbsp;&nbsp; Manipulation du driver logiciel de terminaux 
et de la structure termios</FONT></H3><!--SEC END -->
<B><FONT SIZE=4>Attention</FONT></B><FONT SIZE=5><B> toutes ces opérations se font sur un unique
terminal manipulé par plusieurs descripteurs dans plusieurs
processus. Attention donc aux conflits éventuels et faites attention à repositionner la ligne après usage.</B></FONT><FONT SIZE=5><BR>Les fonctions suivantes permettent de manipuler la structure termios.
</FONT><PRE><FONT SIZE=5><TT>
#include &lt;termios.h&gt;
int tcgetattr(int desc, struct termios *termios);
</TT></FONT></PRE><FONT SIZE=5> 
</FONT><FONT SIZE=5>appels systèmes!tcgetattr@</FONT><FONT SIZE=5><TT>tcgetattr</TT></FONT><FONT SIZE=5>

extraction des paramètres courants.<BR>
<BR>
</FONT><PRE><FONT SIZE=5><TT>
int tcsetattr(int desc, int option, struct termios *termios);
</TT></FONT></PRE><FONT SIZE=5> 
</FONT><FONT SIZE=5>appels systèmes!tcsetattr@</FONT><FONT SIZE=5><TT>tcsetattr</TT></FONT><FONT SIZE=5>

positionnement des paramètres.<BR>Le paramétre </FONT><FONT SIZE=5><TT>option</TT></FONT><FONT SIZE=5> permet de spécifier le comportement de
gestion des tampons d'entrée et de sortie de la ligne &nbsp;:
</FONT><DL COMPACT=compact>
<DT><FONT SIZE=5>
</FONT><FONT SIZE=5>TCSANOW</FONT><DD><FONT SIZE=5> changement immédiat des attributs
</FONT>
<DT><FONT SIZE=5>TCSADRAIN</FONT><DD><FONT SIZE=5> les sorties en cours sont réalisées avant
</FONT>
<DT><FONT SIZE=5>TCSAFLUSH</FONT><DD><FONT SIZE=5> idem et le tampon de lecture est vidé.
</FONT></DL><FONT SIZE=5>La primitive
</FONT><PRE><FONT SIZE=5><TT>
int tcdrain(int desc);
</TT></FONT></PRE><FONT SIZE=5> 
</FONT><FONT SIZE=5>appels systèmes!tcdrain@</FONT><FONT SIZE=5><TT>tcdrain</TT></FONT><FONT SIZE=5>

bloque le processus jusqu'à ce que tous les caractères à destination du terminal de descripteur </FONT><FONT SIZE=5><TT>desc</TT></FONT><FONT SIZE=5> aient été transmis.
</FONT><PRE><FONT SIZE=5><TT>
int tcflush(int desc, int option);
</TT></FONT></PRE><FONT SIZE=5> 
</FONT><FONT SIZE=5>appels systèmes!tcflush@</FONT><FONT SIZE=5><TT>tcflush</TT></FONT><FONT SIZE=5>

vidange des tampons.<BR>valeur de </FONT><FONT SIZE=5><TT>option</TT></FONT><FONT SIZE=5>&nbsp;:
</FONT><DL COMPACT=compact>
<DT><FONT SIZE=5>
</FONT><FONT SIZE=5>TCIFLUSH</FONT><DD><FONT SIZE=5> tampon d'entrée
</FONT>
<DT><FONT SIZE=5>TCOFLUSH</FONT><DD><FONT SIZE=5> tampon de sortie
</FONT>
<DT><FONT SIZE=5>TCIOFLUSH</FONT><DD><FONT SIZE=5> les deux tampons.
</FONT></DL><FONT SIZE=5>
</FONT><!--TOC subsection <FONT SIZE=5>Manipulation de la vitesse de transmission</FONT>-->

<H3><FONT SIZE=5>12.3.8&nbsp;&nbsp; Manipulation de la vitesse de transmission</FONT></H3><!--SEC END -->
<FONT SIZE=5>Le mode de codage de la vitesse étant complexe, elle se manipule en deux étapes, encodage/décode, positionnement/récupération.<BR>
<BR>
Encodage:
</FONT><PRE><FONT SIZE=5><TT>
speed_t cfgetispeed(const struct termios *termios);
speed_t cfgetospeed(const struct termios *termios);
</TT></FONT></PRE><FONT SIZE=5> 
</FONT><FONT SIZE=5>appels systèmes!cfgetispeed@</FONT><FONT SIZE=5><TT>cfgetispeed</TT></FONT><FONT SIZE=5>

</FONT><FONT SIZE=5>appels systèmes!cfgetospeed@</FONT><FONT SIZE=5><TT>cfgetospeed</TT></FONT><FONT SIZE=5>

Permet de lire la vitesse dans la structure termios.<BR></FONT><PRE><FONT SIZE=5><TT>
int cfsetispeed(const struct *termios, speed_t vitesse);
int cfsetospeed(const struct *termios, speed_t vitesse);
</TT></FONT></PRE><FONT SIZE=5> 
</FONT><FONT SIZE=5>appels systèmes!cfsetispeed@</FONT><FONT SIZE=5><TT>cfsetispeed</TT></FONT><FONT SIZE=5>

</FONT><FONT SIZE=5>appels systèmes!cfsetospeed@</FONT><FONT SIZE=5><TT>cfsetospeed</TT></FONT><FONT SIZE=5>

permet de positionner la vitesse dans la structure termios.<BR>
<BR>
Positionnement/récupération de la structure termios par les primitives </FONT><FONT SIZE=5><TT>tcgetattr </TT></FONT><FONT SIZE=5> et </FONT><FONT SIZE=5><TT>tcsetattr</TT></FONT><FONT SIZE=5>.<BR>
<BR>

</FONT><!--TOC section <FONT SIZE=5>Pseudo-terminaux</FONT>-->

<H2><FONT SIZE=5>12.4&nbsp;&nbsp; Pseudo-terminaux</FONT></H2><!--SEC END -->
<FONT SIZE=5>Les pseudo-terminaux sont un mécanisme permettant une connection entre processus, qui prend les attributs définis dans la communication pour des terminaux physiques. D'où le nom de pseudo-terminaux. 
Un pseudo-terminal est composé de deux entités appelées pseudo-terminal maître et pseudo-terminal esclave, qui forment les deux extrémités de la connexion.
</FONT><FONT SIZE=5>/dev/pty</FONT><FONT SIZE=5>
</FONT><FONT SIZE=5>pseudo-terminaux</FONT><FONT SIZE=5>
L'ouverture des deux extrémités suit les règles suivantes &nbsp;:
Le maître </FONT><FONT SIZE=5><TT>/dev/pty</TT></FONT><FONT SIZE=5><TT><EM>xy</EM></TT></FONT><FONT SIZE=5> ne peut être ouvert qu'une seule fois.
L'esclave </FONT><FONT SIZE=5><TT>/dev/tty</TT></FONT><FONT SIZE=5><TT><EM>xy</EM></TT></FONT><FONT SIZE=5> ne peut être ouvert que si le maître correspondant est ouvert.<BR>
<BR>
Les pseudo-terminaux ont des noms où </FONT><FONT SIZE=5><TT>x </TT></FONT><FONT SIZE=5><TT><FONT FACE=symbol>Î</FONT></TT></FONT><FONT SIZE=5><TT> [p-t]</TT></FONT><FONT SIZE=5> et </FONT><FONT SIZE=5><TT>y </TT></FONT><FONT SIZE=5><TT><FONT FACE=symbol>Î</FONT></TT></FONT><FONT SIZE=5><TT> [0-9a-f]</TT></FONT><FONT SIZE=5>. <BR>
<BR>
Dans la figure </FONT><A HREF="#pseudo"><FONT SIZE=5>12.2</FONT></A><FONT SIZE=5>, un </FONT><FONT SIZE=5> <B>pseudo-terminal</B></FONT><FONT SIZE=5> est utilisé pour faire communiquer deux processus. Toutes les écritures de A sur le maître sont lisibles sur l'esclave par le processus B et réciproquement. Exactement comme si l'on avait utilisé deux tubes. De plus, pour le processus B l'entrée et la sortie standard sont perçues comme un terminal qui se comporte normalement à l'appel des fonctions de manipulation du driver de terminaux comme </FONT><FONT SIZE=5><TT>tcsetattr</TT></FONT><FONT SIZE=5>. Et les caractères de contrôle sont effectivement transformés en signaux.<BR>
<BR>


</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML063.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 12.2&nbsp;: Un exemple d'utilisation d'un pseudo terminal</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="pseudo"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>


</FONT><!--TOC section <FONT SIZE=5>La primitive </FONT><FONT SIZE=5><TT>ioctl </TT></FONT>-->

<H2><FONT SIZE=5>12.5&nbsp;&nbsp; La primitive </FONT><FONT SIZE=5><TT>ioctl </TT></FONT></H2><!--SEC END -->
<FONT SIZE=5>La primitive </FONT><FONT SIZE=5><TT>ioctl </TT></FONT><FONT SIZE=5> permet de réaliser un certain nombre
d'opérations sur les fichiers spéciaux. A l'inverse de </FONT><FONT SIZE=5><TT>read</TT></FONT><FONT SIZE=5> et
</FONT><FONT SIZE=5><TT>write</TT></FONT><FONT SIZE=5> qui sont polymorphes et qui s'appliquent identiquement sur
tous les fichiers (spéciaux ou non), la primitive </FONT><FONT SIZE=5><TT>ioctl</TT></FONT><FONT SIZE=5> a des
argment différents pour chaque type de fichier spécial.<BR>
<BR>
</FONT><FONT SIZE=5><TT>#include&lt;sys/ioctl.h&gt;<BR><BR>int ioctl(int desc, int requete, ... /* args */);<BR></TT></FONT><FONT SIZE=5> 
</FONT><FONT SIZE=5>appels systèmes!ioctl@</FONT><FONT SIZE=5><TT>ioctl</TT></FONT><FONT SIZE=5>


</FONT><!--TOC chapter <FONT SIZE=5>Les signaux</FONT>-->

<H1><FONT SIZE=5>Chapitre&nbsp;13&nbsp;&nbsp; Les signaux</FONT></H1><!--SEC END -->
<FONT SIZE=5>signaux</FONT><FONT SIZE=5>
Les signaux sont un mécanisme asynchrone de communication inter-processus. <BR>Intuitivement, il sont comparables à des sonneries, les differentes
sonneries indiquant des évènements différents. Les signaux sont
envoyés à un ou plusieurs processus. Ce signal est en général
associé à un évènement.<BR>
<BR>
Peu portables entre BSD et ATT, ils deviennent plus commodes à
utiliser et portables avec la norme POSIX qui utilise la notion utile
de vecteur de signaux et qui fournit un mécanisme de masquage
automatique pendant les procédures de traitement (comme BSD).<BR>
<BR>
Un signal est envoyé à un processus en utilisant l'appel système&nbsp;:
</FONT><PRE><FONT SIZE=5><TT>
 kill(int pid, int signal); 
</TT></FONT></PRE><FONT SIZE=5> 
</FONT><FONT SIZE=5>appels systèmes!kill@</FONT><FONT SIZE=5><TT>kill</TT></FONT><FONT SIZE=5>
 </FONT><FONT SIZE=5>signaux!kill</FONT><FONT SIZE=5>
</FONT><FONT SIZE=5><TT>signal</TT></FONT><FONT SIZE=5> est un numéro compris entre 1 et </FONT><FONT SIZE=5><TT>NSIG</TT></FONT><FONT SIZE=5> (défini dans </FONT><CODE><FONT SIZE=5><TT>&lt;signal.h&gt;</TT></FONT></CODE><FONT SIZE=5>) et </FONT><FONT SIZE=5><TT>pid</TT></FONT><FONT SIZE=5> le numéro du processus.<BR>Le processus visé reçoit le signal sous forme d'un drapeau positionné dans son bloc de contrôle.<BR>Le processus est interrompu et réalise éventuellement un traitement de ce signal.<BR>On peut considérer les signaux comme des interruptions logicielles, ils interrompent le flot normal d'un processus mais ne sont pas traités de façon synchrone comme les interruptions matérielles.<BR></FONT><!--TOC subsection <FONT SIZE=5>Provenance des signaux</FONT>-->

<H3><FONT SIZE=5>13.0.1&nbsp;&nbsp; Provenance des signaux</FONT></H3><!--SEC END -->
<FONT SIZE=5>Certains signaux peuvent être lancés à partir d'un terminal grâce aux
caractères spéciaux comme </FONT><FONT SIZE=5><TT>intr</TT></FONT><FONT SIZE=5>, </FONT><FONT SIZE=5><TT>quit</TT></FONT><FONT SIZE=5> dont la frappe est
transformée en l'envoi des signaux </FONT><FONT SIZE=5><TT>SIGINT</TT></FONT><FONT SIZE=5> et </FONT><FONT SIZE=5><TT>SIGQUIT</TT></FONT><FONT SIZE=5>.
</FONT><FONT SIZE=5>intr</FONT><FONT SIZE=5>quit</FONT><FONT SIZE=5>susp</FONT><FONT SIZE=5> </FONT><FONT SIZE=5>SIGINT</FONT><FONT SIZE=5>
D'autres sont dûs à des causes internes au processus, par exemple&nbsp;:
</FONT><FONT SIZE=5><TT>SIGSEGV</TT></FONT><FONT SIZE=5> qui est envoyé en cas d'erreur d'adressage, </FONT><FONT SIZE=5><TT>SIGFPE</TT></FONT><FONT SIZE=5>
division par zéro (Floating Point Exception).<BR>
<BR>
Enfin certains sont dûs à des évènements comme la déconnection de la
ligne (le terminal) utilisé&nbsp;: si le processus leader d'un groupe de
processus est déconnecté, il envoie à l'ensemble des processus de son
groupe le signal </FONT><FONT SIZE=5><TT>SIGHUP</TT></FONT><FONT SIZE=5> (Hangup = raccrocher).
</FONT><FONT SIZE=5>SIGHUP</FONT><BR>
<BR>
<!--TOC subsection <FONT SIZE=5>Gestion interne des signaux</FONT>-->

<H3><FONT SIZE=5>13.0.2&nbsp;&nbsp; Gestion interne des signaux</FONT></H3><!--SEC END -->
<FONT SIZE=5>
C'est dans le bloc de contrôle (BCP) de chaque processus que l'on trouve la table de gestion des signaux (attention, sous System V </FONT><FONT SIZE=5>&lt;</FONT><FONT SIZE=5> V.4, la table de gestion des processus est dans la </FONT><FONT SIZE=5><TT>zone u</TT></FONT><FONT SIZE=5>, c'est à dire dans l'espace-mémoire du processus).<BR>
<BR>
Cette table contient, pour chaque signal défini sur la machine, une structure </FONT><FONT SIZE=5><TT>sigvec</TT></FONT><FONT SIZE=5> suivante&nbsp;: 
</FONT><PRE><FONT SIZE=5><TT>
   {
       bit pendant;
       void (*traitement)(int);
   } 
</TT></FONT></PRE><FONT SIZE=5> </FONT><FONT SIZE=5>handler</FONT><FONT SIZE=5>
</FONT><FONT SIZE=5>pendant</FONT><FONT SIZE=5>
En BSD et POSIX, on a un champ supplémentaire&nbsp;: </FONT><FONT SIZE=5><TT>bit masque;</TT></FONT><FONT SIZE=5><BR>Le drapeau </FONT><FONT SIZE=5><TT>pendant</TT></FONT><FONT SIZE=5> indique que le processus a reçu un signal, mais n'a pas encore eu l'occasion de prendre en compte ce signal.<BR>Remarque&nbsp;: comme </FONT><FONT SIZE=5><TT>pendant</TT></FONT><FONT SIZE=5> est un unique bit, si un processus reçoit plusieurs fois le même signal avant de le prendre en compte, alors il n'y a pas mémorisation des réceptions successives, un seul traitement sera donc réalisé.<BR>
<BR>
Comme nous l'avons vu dans le graphe d'état des processus, la prise en compte des signaux se fait au passage de l'état actif noyau à l'état actif utilisateur. Pourquoi la prise en compte de signaux se fait-elle uniquement à ce moment là ?<BR></FONT><FONT SIZE=5><B>Parce que</B></FONT><FONT SIZE=5><BR>Une sauvegarde de la pile utilisateur et du contexte a été effectuée quand le processus est passé en mode noyau.
Il n'est pas nécessaire de faire un nouveau changement de contexte.
Il est facile pour traiter le signal de réaliser immédiatement une nouvelle augmentation de pile pour le traitement du signal, de plus la pile noyau est vide (remarque &nbsp;: en POSIX, il devient possible de créer une pile spéciale pour les fonctions de traitement de signaux).<BR>
<BR>
L'appel à la fonction de traitement est réalisé de façon à ce qu'au retour de la fonction, le processus continue son exécution normalement en poursuivant ce qui était en cours de réalisation avant la réception du signal. Si l'on veut que le processus se poursuive dans un autre contexte (de pile), il doit gérer lui-même la restauration de ce contexte.<BR>
<BR>
La primitive </FONT><FONT SIZE=5><TT>longjmp</TT></FONT><FONT SIZE=5> peut permettre de réaliser des changements de contexte interne au processus, grâce à un désempilement brutal.
</FONT><FONT SIZE=5>longjmp</FONT><BR>
<BR>
<FONT SIZE=5> Pendant ce changement d'état, la table de gestion des signaux du processus est testée pour la présence d'un signal reçu mais non traité (c'est un simple vecteur de bit pour le bit pendant, et donc testable en une seule instruction, ceci doit être fait rapidement comme le test de réception d'un signal est souvent réalisé).<BR>Si un signal a été reçu ( et qu'il n'est pas masqué), alors la fonction de traitement associée est réalisée.
Le masquage permet au processus de temporiser la mise en ø</FONT><FONT SIZE=5>e</FONT><FONT SIZE=5>uvre du traitement.<BR>
<BR>
</FONT><!--TOC subsection <FONT SIZE=5>L'envoi de signaux &nbsp;: la primitive kill</FONT>-->

<H3><FONT SIZE=5>13.0.3&nbsp;&nbsp; L'envoi de signaux &nbsp;: la primitive kill</FONT></H3><!--SEC END -->
<PRE><FONT SIZE=5><TT>
     kill(int pid, int sig)
</TT></FONT></PRE><FONT SIZE=5> 
</FONT><FONT SIZE=5>appels systèmes!kill@</FONT><FONT SIZE=5><TT>kill</TT></FONT><FONT SIZE=5>
<BR>
<BR>
Il y a NSIG signaux sur une machine, déclarés dans le fichier /usr/include/signal.h.<BR>La valeur de </FONT><FONT SIZE=5><TT>pid</TT></FONT><FONT SIZE=5> indique le </FONT><FONT SIZE=5><TT>PID</TT></FONT><FONT SIZE=5> du processus auquel le signal est envoyé.
</FONT><DL COMPACT=compact>
<DT><FONT SIZE=5>
</FONT><FONT SIZE=5>0</FONT><DD><FONT SIZE=5> Tous les processus du </FONT><FONT SIZE=5><B>groupe</B></FONT><FONT SIZE=5> du processus réalisant l'appel
 </FONT><FONT SIZE=5><TT>kill</TT></FONT><FONT SIZE=5>
</FONT>
<DT><FONT SIZE=5>1</FONT><DD><FONT SIZE=5> En système V.4 tous les processus du système sauf 0 et 1
</FONT>
<DT><FONT SIZE=5>pid positif</FONT><DD><FONT SIZE=5> le processus du pid indiqué
</FONT>
<DT><FONT SIZE=5>pid négatif</FONT><DD><FONT SIZE=5> tous les processus du groupe </FONT><FONT SIZE=5>|</FONT><FONT SIZE=5> pid </FONT><FONT SIZE=5>|</FONT><FONT SIZE=5>
</FONT></DL><FONT SIZE=5>
le paramètre </FONT><FONT SIZE=5><TT>sig</TT></FONT><FONT SIZE=5> est interprété comme un signal si </FONT><FONT SIZE=5><TT>sig</TT></FONT><FONT SIZE=5> </FONT><FONT SIZE=5><FONT FACE=symbol>Î</FONT></FONT><FONT SIZE=5> [0-NSIG],
ou comme une demande d'information si </FONT><FONT SIZE=5><TT>sig</TT></FONT><FONT SIZE=5> = 0 (suis-je autorisé à envoyer
un signal à ce(s) processus ?). Comme un paramètre erroné sinon.<BR>La fonction </FONT><FONT SIZE=5><TT>raise(int signal)</TT></FONT><FONT SIZE=5> est un raccourci pour </FONT><FONT SIZE=5><TT>kill(getpid(), signal)</TT></FONT><FONT SIZE=5>, le processus s'envoie à lui-même un signal.<BR>Remarquez que l'on peut réécrire </FONT><FONT SIZE=5><TT>kill(0, signal)</TT></FONT><FONT SIZE=5> par </FONT><FONT SIZE=5><TT>kill(-getpid(), signal)</TT></FONT><FONT SIZE=5>. Rappel&nbsp;: les PID sont toujours positifs.<BR></FONT><!--TOC section <FONT SIZE=5>La gestion simplifiée avec la fonction </FONT><FONT SIZE=5><TT>signal</TT></FONT>-->

<H2><FONT SIZE=5>13.1&nbsp;&nbsp; La gestion simplifiée avec la fonction </FONT><FONT SIZE=5><TT>signal</TT></FONT></H2><!--SEC END -->
<FONT SIZE=5>ZZZ&nbsp;: cette section est historique, utiliser la norme POSIX décrite
plus loin.
</FONT><PRE><FONT SIZE=5><TT>
ancien C : (*signal(sig, func))()
           int sig;
           int (*func)();
 
ANSI C :   void (*signal(int sig, void (*action)(int)))(int);
</TT></FONT></PRE><FONT SIZE=5> 
</FONT><FONT SIZE=5>appels systèmes!signal@</FONT><FONT SIZE=5><TT>signal</TT></FONT><FONT SIZE=5>

La fonction </FONT><FONT SIZE=5><TT>signal</TT></FONT><FONT SIZE=5> permet de spécifier ou de connaître le comportement du processus à la réception d'un signal donné, il faut donner en paramètre à la fonction le numéro du signal </FONT><FONT SIZE=5><TT>sig</TT></FONT><FONT SIZE=5> que l'on veut détourner et la fonction de traitement </FONT><FONT SIZE=5><TT>action</TT></FONT><FONT SIZE=5> à réaliser à la réception du signal.<BR>Trois possibilités pour ce paramètre </FONT><FONT SIZE=5><TT>action</TT></FONT><FONT SIZE=5>
</FONT><DL COMPACT=compact>
<DT><FONT SIZE=5>
</FONT><FONT SIZE=5>SIG_DFL</FONT><DD><FONT SIZE=5> Comportement par défaut, plusieurs possibilités
</FONT><FONT SIZE=5><B>exit</B></FONT><FONT SIZE=5> Le processus se termine (avec si possible la réalisation d'un core)
</FONT><FONT SIZE=5><B>ignore</B></FONT><FONT SIZE=5> Le processus ignore le signal
</FONT><FONT SIZE=5><B>pause</B></FONT><FONT SIZE=5> Suspension du processus
</FONT><FONT SIZE=5><B>continue</B></FONT><FONT SIZE=5> Reprise du processus si il était suspendu.
</FONT>
<DT><FONT SIZE=5>SIG_IGN</FONT><DD><FONT SIZE=5> le signal est ignoré.<BR>Remarque&nbsp;: les signaux SIGKILL, SIGSTOP ne peuvent pas être ignorés. 
</FONT>
<DT><FONT SIZE=5>HANDLER</FONT><DD><FONT SIZE=5> Une fonction de votre cru.
</FONT></DL><!--TOC subsection <FONT SIZE=5>Un exemple</FONT>-->

<H3><FONT SIZE=5>13.1.1&nbsp;&nbsp; Un exemple</FONT></H3><!--SEC END -->
<FONT SIZE=5>Exemple pour rendre un programme insensible à la frappe du caractère de contrôle intr sur le terminal de contrôle du processus. 
</FONT><PRE><FONT SIZE=5><TT>
void got_the_blody_signal(int n) {
    signal(SIGINT, got_the_blody_signal);
    printf(" gotcha!!  your  (%d) signal is useless \n");
}

main() {
    signal(SIGINT, got_the_blody_signal);
    printf(" kill me now !! \n");
    for(;;);
}
</TT></FONT></PRE><FONT SIZE=5> une version plus élégante et plus fiable&nbsp;:
</FONT><PRE><FONT SIZE=5><TT>
    signal(SIGINT, SIG_IGN);
</TT></FONT></PRE><FONT SIZE=5> </FONT><!--TOC section <FONT SIZE=5>Problèmes de la gestion de signaux ATT</FONT>-->

<H2><FONT SIZE=5>13.2&nbsp;&nbsp; Problèmes de la gestion de signaux ATT</FONT></H2><!--SEC END -->
<FONT SIZE=5>Les phénomènes suivants sont décrits comme des problèmes mais la norme
POSIX permet d'en conserver certains, mais fournit aussi les moyens
de les éviter.
</FONT><OL type=1>
<LI><FONT SIZE=5> un signal est repositionné à sa valeur par défaut au début de son traitement (handler).<BR>
<BR>
</FONT><PRE><FONT SIZE=5><TT>
#include &lt;signal.h&gt;

traitement()  {
    printf("PID %d en a capture un \n", getpid());
-&gt;     reception du deuxieme signal, realisation d'un exit 
    signal(SIGINT, traitement);
}

main() {
    int ppid;
    signal(SIGINT,traitement);
    if (fork()==0)
    {/* attendre que pere ait realise son nice() */
        sleep(5);
        ppid = getppid(); /* numero de pere */
        for(;;)
            if (kill(ppid,SIGINT) == -1)
                exit();
    }
/* pere ralenti pour un conflit plus sur */
    nice(10);
    for(;;) pause();  &lt;- reception du premier signal  
/* pause c'est mieux qu'une attente active */
}
</TT></FONT></PRE><FONT SIZE=5> Si l'on cherche à corriger ce défaut, on repositionne la fonction </FONT><FONT SIZE=5><TT>traitement</TT></FONT><FONT SIZE=5> au début du traitement du signal. Ceci risque de nous placer dans une situation de dépassement de pile&nbsp;: en effet, dans le programme précédent, nous pouvons imaginer que le père peut recevoir un nombre de signaux arbitrairement grand pendant le traitement d'un seul signal, d'où une explosion assurée de la pile (il suffit en effet que chaque empilement de la fonction </FONT><FONT SIZE=5><TT>traitement</TT></FONT><FONT SIZE=5> soit interrompu par un signal)
</FONT><PRE><FONT SIZE=5><TT>
traitement(){
    signal(SIGINT,traitement);
-&gt;   signal SIGINT
    printf("PID %d en a capture un \n",getpid());
}
</TT></FONT></PRE><FONT SIZE=5> On peut aussi ignorer les signaux pendant leur traitement, mais cela peut créer des pertes de réception.<BR>Enfin, la solution BSD/POSIX où l'on peut bloquer et débloquer la réception de signaux à l'aide du vecteur de masquage (sans pour autant nous assurer de la réception de tous les signaux !!).
De plus, en POSIX, le traitement d'un signal comporte une clause de blocage automatique. On indique quels signaux doivent être bloqués pendant le traitement du signal, grâce à un vecteur de masquage dans la structure </FONT><FONT SIZE=5><TT>sigaction</TT></FONT><FONT SIZE=5>.<BR>
<BR>
 Ceci est le comportement naturel de gestion des interruptions
 matérielles&nbsp;: on bloque les interruptions de priorité inférieure
 pendant le traitement d'un interruption.</FONT><BR>
<BR>

<LI><FONT SIZE=5> Seconde anomalie des signaux sous System V </FONT><FONT SIZE=5>&lt;</FONT><FONT SIZE=5> V4&nbsp;: certains
 appels systèmes peuvent être interrompus et dans ce cas la
 valeur de retour de l'appel système est -1 (échec). Il faudrait,
 pour réaliser correctement le modèle d'une interruption
 logicielle, relancer l'appel système en fin de traitement du
 signal. (Sous BSD ou POSIX, il est possible de choisir le
 comportement en cas d'interruption d'un appel système grâce à la
 fonction </FONT><FONT SIZE=5><TT>siginterrupt</TT></FONT><FONT SIZE=5>, c-a-d relancer ou non l'appel système, un appel à </FONT><FONT SIZE=5><TT>read</TT></FONT><FONT SIZE=5>, par exemple, peut facilement être interrompu si il nécessite un accès disque).</FONT><BR>
<BR>

<LI><FONT SIZE=5> Troisième anomalie des signaux sous ATT&nbsp;: si un signal est
 ignoré par un processus endormi, celui-ci sera réveillé par le
 système uniquement pour apprendre qu'il ignore le signal et doit
 donc être endormi de nouveau. Cette perte de temps est dûe au
 fait que le vecteur des signaux est dans la zone u et non pas
 dans le bloc de contrôle du processus.</FONT></OL><!--TOC subsection <FONT SIZE=5>Le signal SIGCHLD</FONT>-->

<H3><FONT SIZE=5>13.2.1&nbsp;&nbsp; Le signal SIGCHLD</FONT></H3><!--SEC END -->
<FONT SIZE=5>Le signal SIGCHLD (anciennement SIGCLD) est un signal utilisé pour réveiller un processus
dont un des fils vient de mourir. C'est pourquoi il est traité
différemment des autres signaux. La réaction à la réception d'un
signal SIGCHLD est de repositionner le bit pendant à zéro, et d'ignorer
le signal, mais le processus a quand même été réveillé pour
cela. L'effet d'un signal SIGCHLD est donc uniquement de réveiller un
processus endormi en priorité interruptible.<BR> Si le processus capture les signaux SIGCHLD, il invoque alors la procédure de
 traitement définie par l'utilisateur comme il le fait pour les autres signaux,
 ceci en plus du traitement par défaut.<BR>Le traitement normal est lié à la primitive </FONT><FONT SIZE=5><TT>wait</TT></FONT><FONT SIZE=5> qui permet de
récupérer la valeur de retour (exit status) d'un processus fils. En
effet, la primitive </FONT><FONT SIZE=5><TT>wait</TT></FONT><FONT SIZE=5> est bloquante et c'est la réception du signal
qui va réveiller le processus, et permettre la fin de l'exécution de
la primitive </FONT><FONT SIZE=5><TT>wait</TT></FONT><FONT SIZE=5>.<BR>Un des problèmes de la gestion de signaux System V est le fait que le signal
 SIGCHLD est reçu (raised) au moment de la pose d'une fonction de traitement.<BR>Ces propriétés du signal SIGCHLD peuvent induire un bon nombre d'erreurs.<BR>
<BR>
Par exemple, dans le programme suivant nous positionnons une fonction de traitement dans laquelle nous repositionnons la fonction de traitement.
 Comme sous System V, le comportement par défaut est repositionné pendant le traitement d'un signal.
 Or le signal est levé à la pose de la fonction de traitement, d'où une explosion de la pile.
</FONT><PRE><FONT SIZE=5><TT>
#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt; /* ancienne norme */
#include &lt;signal.h&gt;

void hand(int sig) { 
    signal(sig, hand);
    printf("message qui n'est pas affiche\n");
}

main() {
    if (fork()) { exit(0); /* creation d'un zombi */ } 
    signal(SIGCHLD, hand);
    printf("ce printf n'est pas execute\n");
}
</TT></FONT></PRE><FONT SIZE=5> Sur les HP, un message d'erreur vous informe que la pile est pleine &nbsp;: </FONT><FONT SIZE=5><TT>stack growth failure</TT></FONT><FONT SIZE=5>.<BR>
<BR>
Deuxième exemple &nbsp;:
</FONT><PRE><FONT SIZE=5><TT>
#include &lt;signal.h&gt;
#include &lt;sys/wait.h&gt;

int pid, status;

void hand(int sig) {
    printf(" Entree dans le handler \n");
    system("ps -l");                 /* affichage avec etat zombi du fils */
    if ((pid = wait(&amp;status)) == -1) /* suppression du fils zombi */
    {
         perror("wait handler ");
         return ;
    }
    printf(" wait handler  pid: %d    status %d \n", pid, status);
    return;
}

main() {
    signal(SIGCHLD,hand);  /* installation du handler */
    if (fork() ==  0)
    {   /* dans le fils */
        sleep(5);
        exit(2);
    } 
/* dans le pere */
    if ((pid = wait(&amp;status)) == -1) /* attente de terminaison du fils */
    {
        perror("wait main ");
        return ;
    }
    printf(" wait main  pid: %d    status %d \n", pid, status);
}
</TT></FONT></PRE><FONT SIZE=5>
résultat&nbsp;:
</FONT><PRE><FONT SIZE=5><TT>
 Entree dans le handler 
F S  UID   PID  PPID  C PRI NI     ADDR   SZ  WCHAN    TTY  TIME COMD
1 S  121  6792  6667  0 158 20  81ac180    6  49f5fc  ttys1 0:00 sigchld
1 S  121  6667  6666  0 168 20  81ac700  128 7ffe6000 ttys1 0:00 tcsh
1 Z  121  6793  6792  0 178 20  81bda80    0          ttys1 0:00 sigchld
1 S  121  6794  6792  0 158 20  81ac140   78  4a4774  ttys1 0:00 sh
1 R  121  6795  6794  4 179 20  81bd000   43          ttys1 0:00 ps
wait handler  pid: 6793    status 512     (2 * 256)
wait main: Interrupted system call

</TT></FONT></PRE><FONT SIZE=5> A la mort du fils, Le père reçoit le signal SIGCHLD (alors qu'il était dans le
</FONT><FONT SIZE=5><TT>wait</TT></FONT><FONT SIZE=5> du main), puis le handler est executé,
et </FONT><FONT SIZE=5><TT>ps</TT></FONT><FONT SIZE=5> affiche bien le fils zombi. Ensuite c'est le </FONT><FONT SIZE=5><TT>wait</TT></FONT><FONT SIZE=5> du handler qui prend en
compte la terminaison du fils. Au retour du handler, l'appel a </FONT><FONT SIZE=5><TT>wait</TT></FONT><FONT SIZE=5> du main
retourne -1, puisqu'il avait été interrompu par SIGCHLD.<BR>
<BR>
</FONT><!--TOC section <FONT SIZE=5>Manipulation de la pile d'exécution</FONT>-->

<H2><FONT SIZE=5>13.3&nbsp;&nbsp; Manipulation de la pile d'exécution</FONT></H2><!--SEC END -->
<FONT SIZE=5>La primitive
</FONT><PRE><FONT SIZE=5><TT>
#include &lt;setjmp.h&gt;
int sigsetjmp(sigjmp_buf env, int indicateur);
</TT></FONT></PRE><FONT SIZE=5> 
</FONT><FONT SIZE=5>appels systèmes!sigsetjmp@</FONT><FONT SIZE=5><TT>sigsetjmp</TT></FONT><FONT SIZE=5>

 sauvegarde un environnement d'exécution, c'est à dire un état de la pile, et si </FONT><FONT SIZE=5><EM>indicateur</EM></FONT><FONT SIZE=5> est non nul, sauvegarde le masque de signaux courant.
La valeur de retour de cette fonction est zéro quand on fait une sauvegarde, et sinon dépend du paramètre </FONT><FONT SIZE=5><EM>valeur</EM></FONT><FONT SIZE=5> de la fonction </FONT><FONT SIZE=5><TT>siglongjmp</TT></FONT><FONT SIZE=5>.
</FONT><PRE><FONT SIZE=5><TT>
int siglongjmp(sigjmp_buf env, int valeur);
</TT></FONT></PRE><FONT SIZE=5> 
</FONT><FONT SIZE=5>appels systèmes!siglongjmp@</FONT><FONT SIZE=5><TT>siglongjmp</TT></FONT><FONT SIZE=5>

La primitive </FONT><FONT SIZE=5><TT>siglongjmp</TT></FONT><FONT SIZE=5> permet de reprendre l'exécution à l'endroit sauvegardé par </FONT><FONT SIZE=5><TT>sigsetjmp</TT></FONT><FONT SIZE=5> dans la variable </FONT><FONT SIZE=5><EM>env</EM></FONT><FONT SIZE=5>.<BR>
<BR>
Deux remarques&nbsp;:
</FONT><FONT SIZE=5><TT>env</TT></FONT><FONT SIZE=5> doit avoir été initialisé par </FONT><FONT SIZE=5><TT>sigsetjmp</TT></FONT><FONT SIZE=5>, les valeurs de pile placées au-dessus de l'environnement repris sont perdues.
L'environnement de pile doit encore exister dans la pile au moment de l'appel, sinon le résultat est indéterminé.<BR>
<BR>
</FONT><!--TOC section <FONT SIZE=5>Quelques exemples d'utilisation</FONT>-->

<H2><FONT SIZE=5>13.4&nbsp;&nbsp; Quelques exemples d'utilisation</FONT></H2><!--SEC END -->
<FONT SIZE=5>
</FONT><PRE><FONT SIZE=5><TT>
/*un exemple de signaux BSD */
#include &lt;stdio.h&gt;
#include &lt;signal.h&gt;
void gots1(int n)   { raise(SIGUSR2);  printf("got  s1(%d) ", n); }
void gots2(int n)   { printf("got  s2(%d) ", n); }

main()
{
    int mask ;
    struct sigvec s1,s2;

    s1.sv_handler = gots1;
    s1.sv_mask = sigmask(SIGUSR1);
    sigvec(SIGUSR1, &amp;s1, NULL);

    s2.sv_handler = gots2;
    s2.sv_mask = sigmask(SIGUSR2);
    sigvec(SIGUSR2, &amp;s2, NULL);

    printf(" sans masquage de SIGUSR2: ")
    raise(SIGUSR1);

    printf(" \n avec masquage de SIGUSR2: " );
    s1.sv_mask = sigmask(SIGUSR2);
    sigvec(SIGUSR1, &amp;s1, NULL);

    raise(SIGUSR1);
}
</TT></FONT></PRE><FONT SIZE=5> 
Nous donne les affichages suivant&nbsp;:
</FONT><PRE><FONT SIZE=5>
 sans masquage de SIGUSR2: got  s2(31) got  s1(30)
 avec masquage de SIGUSR2: got  s1(30) got  s2(31)
</FONT></PRE><FONT SIZE=5>Sous BSD, pas de fonction de manipulation propre des groupes de signaux (on regroupe les signaux par des conjonctions de masques).<BR>
<BR>
Le problème de "l'interruption" des appels système par les signaux est corrigé par la fonction&nbsp;:
</FONT><PRE><FONT SIZE=5><TT>
int  siginterrupt(int sig, int flag);
</TT></FONT></PRE><FONT SIZE=5>
</FONT><FONT SIZE=5>appels systèmes!siginterrupt@</FONT><FONT SIZE=5><TT>siginterrupt</TT></FONT><FONT SIZE=5>

le drapeau </FONT><FONT SIZE=5><TT>flag</TT></FONT><FONT SIZE=5> prend comme valeur 0 ou 1, ce qui signifie que les appels systèmes interrompus par un signal seront&nbsp;:<BR>soit relancés avec les mêmes paramètres. <BR>soit retourneront la valeur -1, et dans ce cas la valeur de </FONT><FONT SIZE=5><TT>errno</TT></FONT><FONT SIZE=5> est positionnée à </FONT><FONT SIZE=5><TT>EINTR</TT></FONT><FONT SIZE=5>.<BR>Certaines fonctions comme </FONT><FONT SIZE=5><TT>readdir</TT></FONT><FONT SIZE=5> utilisent des variables
statiques, ces fonctions sont dites non réentrantes. Il faut éviter
d'appeler ce type de fonctions dans un handler de signal, dans le cas
où l'on fait déjà appel à la fonction dans le reste du processus. De
la même façon la variable </FONT><FONT SIZE=5><TT>errno</TT></FONT><FONT SIZE=5> est unique. Si celle-ci est
positionnée dans le </FONT><FONT SIZE=5><TT>main</TT></FONT><FONT SIZE=5> mais qu'un signal arrive avant son
utilisation, une primitive appelée dans le handler peut en changer la
valeur! (ce problème de réentrance sera vu plus en détail avec les processus multi-activités).<BR>
<BR>
</FONT><!--TOC subsection <FONT SIZE=5>L'appel pause</FONT>-->

<H3><FONT SIZE=5>13.4.1&nbsp;&nbsp; L'appel pause</FONT></H3><!--SEC END -->
<FONT SIZE=5>
Fonction de mise en attente de réception d'un signal&nbsp;:
</FONT><PRE><FONT SIZE=5><TT>
pause(void);
</TT></FONT></PRE><FONT SIZE=5> 
</FONT><FONT SIZE=5>appels systèmes!pause@</FONT><FONT SIZE=5><TT>pause</TT></FONT><FONT SIZE=5>

cette primitive est le standard UNIX d'attente de la réception d'un signal quelconque, BSD propose la primitive suivante&nbsp;:
</FONT><PRE><FONT SIZE=5><TT>
sigpause(int sigmask)
</TT></FONT></PRE><FONT SIZE=5>
</FONT><FONT SIZE=5>appels systèmes!sigpause@</FONT><FONT SIZE=5><TT>sigpause</TT></FONT><FONT SIZE=5>

qui permet l'attente d'un groupe spécifique de signaux, attention les signaux du masque sont débloqués (c.f. </FONT><FONT SIZE=5><TT>sigprocmask</TT></FONT><FONT SIZE=5>).<BR>
<BR>
</FONT><!--TOC section <FONT SIZE=5>La norme POSIX</FONT>-->

<H2><FONT SIZE=5>13.5&nbsp;&nbsp; La norme POSIX</FONT></H2><!--SEC END -->
<FONT SIZE=5>La norme POSIX ne définit pas le comportement d'interruption des appels systèmes, il faut le spécifier dans la structure de traitement du signal.<BR></FONT><!--TOC paragraph <FONT SIZE=5>Les ensembles de signaux</FONT>-->

<H5><FONT SIZE=5> Les ensembles de signaux</FONT></H5><!--SEC END -->
<FONT SIZE=5>La norme POSIX introduit les ensembles de signaux&nbsp;:<BR>ces ensembles de signaux permettent de dépasser la contrainte classique qui veut que le nombre de signaux soit inférieur ou égal au nombre de bits des entiers de la machine. D'autre part, des fonctions de manipulation de ces ensembles sont fournies et permettent de définir simplement des masques.
 Ces ensembles de signaux sont du type sigset_t et sont manipulables grâce aux fonctions suivantes&nbsp;:<BR></FONT><PRE><FONT SIZE=5><TT>
int sigemptyset(sigset_t *ens)           /* raz */
int sigfillset(sigset_t *ens)            /* ens = { 1,2,...,NSIG} */
int sigaddset(sigset_t *ens, int sig)    /* ens = ens + {sig} */
int sigdelset(sigset_t *ens, int sig)     /* ens = ens - {sig } */
</TT></FONT></PRE><FONT SIZE=5>
 Ces fonctions retournent -1 en cas d'échec et 0 sinon.
</FONT><PRE><FONT SIZE=5><TT>
int sigismember(sigset_t *ens, int sig);   /* sig appartient à ens ?*/
</TT></FONT></PRE><FONT SIZE=5>
retourne vrai si le signal appartient à l'ensemble.<BR>
<BR>
</FONT><!--TOC subsection <FONT SIZE=5>Le blocage des signaux</FONT>-->

<H3><FONT SIZE=5>13.5.1&nbsp;&nbsp; Le blocage des signaux</FONT></H3><!--SEC END -->
<FONT SIZE=5>La fonction suivante permet de manipuler le masque de signaux du processus&nbsp;:
</FONT><PRE><FONT SIZE=5><TT>
#include &lt;signal.h&gt;
int sigprocmask(int op, const sigset_t  *nouv, sigset_t *anc);
</TT></FONT></PRE><FONT SIZE=5> 
</FONT><FONT SIZE=5>appels systèmes!sigprocmask@</FONT><FONT SIZE=5><TT>sigprocmask</TT></FONT><FONT SIZE=5>
<BR>
<BR>
L'opération </FONT><FONT SIZE=5><TT>op</TT></FONT><FONT SIZE=5>&nbsp;:
</FONT><DL COMPACT=compact>
<DT><FONT SIZE=5>
</FONT><FONT SIZE=5>SIG_SETMASK</FONT><DD><FONT SIZE=5> affectation du </FONT><FONT SIZE=5><TT>nouv</TT></FONT><FONT SIZE=5>eau masque, recupération de la valeur de l'</FONT><FONT SIZE=5><TT>anc</TT></FONT><FONT SIZE=5>ien masque.
</FONT>
<DT><FONT SIZE=5>SIG_BLOCK</FONT><DD><FONT SIZE=5> union des deux ensembles </FONT><FONT SIZE=5><TT>nouv</TT></FONT><FONT SIZE=5> et </FONT><FONT SIZE=5><TT>anc</TT></FONT><FONT SIZE=5>
</FONT>
<DT><FONT SIZE=5>SIG_UNBLOCK</FONT><DD><FONT SIZE=5> soustraction </FONT><FONT SIZE=5><TT>anc</TT></FONT><FONT SIZE=5> - </FONT><FONT SIZE=5><TT>nouv</TT></FONT><FONT SIZE=5>
</FONT></DL><FONT SIZE=5>On peut savoir si un signal est </FONT><FONT SIZE=5><EM>pendant</EM></FONT><FONT SIZE=5> et donc </FONT><FONT SIZE=5><EM>bloqué</EM></FONT><FONT SIZE=5> grâce à la fonction&nbsp;:
</FONT><PRE><FONT SIZE=5><TT>
int sigpending(sigset_t *ens);
</TT></FONT></PRE><FONT SIZE=5>
retourne -1 en cas d'échec et 0 sinon et l'ensemble des signaux
pendants est stocké à l'adresse </FONT><FONT SIZE=5><TT>ens</TT></FONT><FONT SIZE=5>.<BR></FONT><!--TOC subsection <FONT SIZE=5>sigaction</FONT>-->

<H3><FONT SIZE=5>13.5.2&nbsp;&nbsp; sigaction</FONT></H3><!--SEC END -->
<FONT SIZE=5>La structure </FONT><FONT SIZE=5><TT>sigaction</TT></FONT><FONT SIZE=5> décrit le comportement utilisé pour le traitement d'un signal&nbsp;:
</FONT><PRE><FONT SIZE=5><TT>
struct sigaction { 
        void (*sa_handler) ();  
        sigset_t sa_mask;
        int sa_flags;}
</TT></FONT></PRE><FONT SIZE=5> 
</FONT><FONT SIZE=5>appels systèmes!sigaction@</FONT><FONT SIZE=5><TT>sigaction</TT></FONT><FONT SIZE=5>

</FONT><DL COMPACT=compact>
<DT><FONT SIZE=5>
</FONT><FONT SIZE=5>sa_handler</FONT><DD><FONT SIZE=5> fonction de traitement (ou </FONT><FONT SIZE=5><TT>SIG_DFL</TT></FONT><FONT SIZE=5> et </FONT><FONT SIZE=5><TT>SIG_IGN</TT></FONT><FONT SIZE=5>)
</FONT>
<DT><FONT SIZE=5>sa_mask</FONT><DD><FONT SIZE=5> ensemble de signaux supplémentaires à bloquer pendant le traitement
</FONT>
<DT><FONT SIZE=5>sa_flags</FONT><DD><FONT SIZE=5> différentes options
</FONT></DL><FONT SIZE=5>
</FONT><BLOCKQUOTE><FONT SIZE=5>
</FONT><DL COMPACT=compact>
<DT><FONT SIZE=5>
</FONT><FONT SIZE=5>SA_NOCLDSTOP</FONT><DD><FONT SIZE=5> le signal SIGCHLD n'est pas envoyé à un processus lorsque l'un de ses fils est stoppé.
</FONT>
<DT><FONT SIZE=5>SA_RESETHAND</FONT><DD><FONT SIZE=5> simulation de l'ancienne méthode de gestion des signaux, pas de blocage du signal pendant le handler et repositionnement du handler par défaut au lancement du handler.
</FONT>
<DT><FONT SIZE=5>SA_RESTART</FONT><DD><FONT SIZE=5> les appels système interrompus par un signal capté sont relancés au lieu de renvoyer -1. Cet indicateur joue le rôle de l'appel </FONT><FONT SIZE=5><TT>siginterrupt(sig,0)</TT></FONT><FONT SIZE=5> des versions BSD.
</FONT>
<DT><FONT SIZE=5>SA_NOCLDWAIT</FONT><DD><FONT SIZE=5> si le signal est SIGCHLD, ses fils qui se terminent ne deviennent pas zombis. Cet indicateur correspond au comportement des processus pour SIG_IGN dans les versions ATT.
</FONT></DL><FONT SIZE=5>
</FONT></BLOCKQUOTE><FONT SIZE=5>
Le positionnement du comportement de reception d'un signal se fait par la primitive </FONT><FONT SIZE=5><TT>sigaction</TT></FONT><FONT SIZE=5>.<BR>L'installation d'une fonction de traitement du signal SIGCHLD peut avoir pour effet d'envoyer un signal au processus, ceci dans le cas où le processus a des fils zombis, c'est toujours le problème lié à ce signal qui n'a pas le même comportement que les autres signaux.<BR>Un handler positionné par </FONT><FONT SIZE=5><TT>sigaction</TT></FONT><FONT SIZE=5> reste jusqu'à ce qu'un autre handler soit positionné, à la différence des versions ATT où le handler par défaut est repositionné automatiquement au début du traitement du signal.<BR>
<BR>
</FONT><PRE><FONT SIZE=5><TT>
        #include &lt;signal.h&gt;
        int sigaction(int sig,
                      const struct sigaction *paction,
                      struct sigaction       *paction_precedente);
</TT></FONT></PRE><FONT SIZE=5> 
</FONT><FONT SIZE=5>appels systèmes!sigaction@</FONT><FONT SIZE=5><TT>sigaction</TT></FONT><FONT SIZE=5>

Cette fonction réalise soit une demande d'information. Si le pointeur </FONT><FONT SIZE=5><TT>paction</TT></FONT><FONT SIZE=5> est null, on obtient la structure </FONT><FONT SIZE=5><TT>sigaction</TT></FONT><FONT SIZE=5> courante. Sinon c'est une demande de modification du comportement.<BR>
<BR>
</FONT><!--TOC subsection <FONT SIZE=5>L'attente d'un signal</FONT>-->

<H3><FONT SIZE=5>13.5.3&nbsp;&nbsp; L'attente d'un signal</FONT></H3><!--SEC END -->
<FONT SIZE=5>
</FONT><FONT SIZE=5>appels systèmes!pause@</FONT><FONT SIZE=5><TT>pause</TT></FONT><FONT SIZE=5>

En plus de l'appel </FONT><FONT SIZE=5><TT>pause</TT></FONT><FONT SIZE=5>, on trouve sous POSIX l'appel </FONT><FONT SIZE=5><TT>int sigsuspend(const sigset_t *ens);</TT></FONT><FONT SIZE=5> qui permet de réaliser de façons </FONT><FONT SIZE=5><TT>atomique</TT></FONT><FONT SIZE=5> les actions suivantes&nbsp;:
</FONT><UL>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5> l'installation du masque de blocage défini par </FONT><FONT SIZE=5><TT>ens</TT></FONT><FONT SIZE=5> (qui sera repositionné à sa valeur d'origine) à la fin de l'appel,
</FONT>
<LI><FONT SIZE=5> mise en attente de la réception d'un signal non bloqué.
</FONT></UL><FONT SIZE=5>
</FONT><!--TOC chapter <FONT SIZE=5>Les verrous de fichiers</FONT>-->

<H1><FONT SIZE=5>Chapitre&nbsp;14&nbsp;&nbsp; Les verrous de fichiers</FONT></H1><!--SEC END -->
<FONT SIZE=5>Mécanismes de contrôle d'accès concurrents à un fichier, les verrous sont d'une grande utilité dans les applications de gestion et dans l'élaboration de bases de données partagées.<BR>Les verrous sont rattachés aux </FONT><FONT SIZE=5><B>inoeuds</B></FONT><FONT SIZE=5>. Ainsi toutes les ouvertures d'un même fichier, et à fortiori tous les descripteurs sur ces ouvertures, "voient" le verrou.<BR>La protection réalisée par le verrou a donc lieu sur le fichier physique.<BR>Un verrou est la </FONT><FONT SIZE=5><B>propriété</B></FONT><FONT SIZE=5> d'un seul </FONT><FONT SIZE=5><B>processus</B></FONT><FONT SIZE=5>, et seul le processus propriétaire du verrou peut le modifier ou l'enlever, attention le verrou ne protège pas contre les accès du processus propriétaire (attention à une situation multi-thread).<BR></FONT><!--TOC section <FONT SIZE=5>Caractéristiques d'un verrou</FONT>-->

<H2><FONT SIZE=5>14.1&nbsp;&nbsp; Caractéristiques d'un verrou</FONT></H2><!--SEC END -->
<FONT SIZE=5>Les verrous sont définis par deux caractéristiques&nbsp;:<BR></FONT><FONT SIZE=5><TT><B>La portée</B></TT></FONT><FONT SIZE=5>&nbsp;: Ensemble des positions du fichier auxquelles le verrou s'applique. Cet ensemble est un intervalle, soit une portion du fichier<BR></FONT><DIV ALIGN=center><FONT SIZE=5> </FONT><FONT SIZE=5><TT>[position1, position2] </TT></FONT></DIV><FONT SIZE=5><BR>soit jusqu'à la fin du fichier <BR></FONT><DIV ALIGN=center><FONT SIZE=5><TT>[position1, fin de fichier[</TT></FONT></DIV><FONT SIZE=5><BR>dans ce dernier cas si le fichier augmente, le verrou protège les nouvelles positions.<BR></FONT><FONT SIZE=5><TT><B>Le type</B></TT></FONT><FONT SIZE=5>&nbsp;: qui décrit les possibilités de cohabitation des différents verrous.<BR></FONT><DL COMPACT=compact>
<DT><FONT SIZE=5>
</FONT><FONT SIZE=5>F_RDLCK</FONT><DD><FONT SIZE=5> partagé, plusieurs verrous de ce type peuvent avoir des portées non disjointes, par exemple les verrous </FONT><FONT SIZE=5>[80,150]</FONT><FONT SIZE=5> et </FONT><FONT SIZE=5>[100,123]</FONT><FONT SIZE=5> 
</FONT>
<DT><FONT SIZE=5>F_WRLCK</FONT><DD><FONT SIZE=5> exclusif, pas de cohabitation possible avec un autre verrou quelque soit son type.
</FONT></DL><!--TOC section <FONT SIZE=5>Le mode opératoire des verrous</FONT>-->

<H2><FONT SIZE=5>14.2&nbsp;&nbsp; Le mode opératoire des verrous</FONT></H2><!--SEC END -->
<FONT SIZE=5>Le mode opératoire joue sur le comportement des primitives </FONT><FONT SIZE=5><TT>read</TT></FONT><FONT SIZE=5>
et </FONT><FONT SIZE=5><TT>write</TT></FONT><FONT SIZE=5>. Les verrous d'un fichier sont soit </FONT><FONT SIZE=5><B>consultatifs</B></FONT><FONT SIZE=5>, soit </FONT><FONT SIZE=5><B>impératifs</B></FONT><FONT SIZE=5>.<BR>Dans le premier mode </FONT><FONT SIZE=5><B>advisory</B></FONT><FONT SIZE=5> (consultatif), la présence d'un verrou
n'est testée qu'à la pose d'un verrou, la pose sera refusée s'il existe un verrou de portée non disjointe et que l'un des deux verrous est exclusif.<BR>Dans le second mode </FONT><FONT SIZE=5><B>mandatory</B></FONT><FONT SIZE=5>, la présence de verrous est testée
pour la pose mais aussi pour les appels systèmes </FONT><FONT SIZE=5><TT>read</TT></FONT><FONT SIZE=5> et </FONT><FONT SIZE=5><TT>write</TT></FONT><FONT SIZE=5>. <BR>Dans le mode consultatif, les verrous n'ont d'effet que sur les processus jouant effectivement le jeu, c'est-à-dire, posant des verrous sur les zones du fichiers sur lesquels ils veulent réaliser une lecture (verrou partagé) ou une écriture (verrou exclusif).<BR>Dans le mode impératif, les verrous ont un impact sur les lectures/écritures de tous les processus&nbsp;:
</FONT><UL>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5> sur les verrous de type partagé (F_RDLCK), toute tentative d'écriture par un autre processus est bloquée;
</FONT>
<LI><FONT SIZE=5> sur les verrous de type exclusif (F_WRLCK), toute tentative de lecture ou d'écriture par un autre processus est bloquée.
</FONT></UL><!--TOC section <FONT SIZE=5>Manipulation des verrous</FONT>-->

<H2><FONT SIZE=5>14.3&nbsp;&nbsp; Manipulation des verrous</FONT></H2><!--SEC END -->
<FONT SIZE=5>La structure de verrou </FONT><FONT SIZE=5><TT>flock</TT></FONT><FONT SIZE=5>&nbsp;:
</FONT><PRE><FONT SIZE=5><TT>
struct flock  {          
      short    l_type;      /* F_RDLCK, F_WRLCK,F_UNLCK */
      short    l_whence;    /* SEEK_SET,SEEK_CUR,SEEK_END */
      off_t    l_start;     /* position relative a l_whence */
      off_t    l_len;       /* longueur de l'intervalle */
      pid_t    l_pid;       /* PID du processus propriétaire */
};
</TT></FONT></PRE><FONT SIZE=5>le champ </FONT><FONT SIZE=5><TT>l_type </TT></FONT><FONT SIZE=5>
</FONT><DL COMPACT=compact>
<DT><FONT SIZE=5>
 </FONT><FONT SIZE=5>F_RDLCK</FONT><DD><FONT SIZE=5> verrou partagé
 </FONT>
<DT><FONT SIZE=5>F_WRLCK</FONT><DD><FONT SIZE=5> verrou exclusif
 </FONT>
<DT><FONT SIZE=5>F_UNLCK</FONT><DD><FONT SIZE=5> déverrouillage
</FONT></DL><FONT SIZE=5>Les manipulations de verrous se font avec la primitive </FONT><FONT SIZE=5><TT>fcntl</TT></FONT><FONT SIZE=5>, c'est-à-dire par le biais d'un descripteur. Pour poser un verrou partagé, ce descripteur doit pointer sur une ouverture en lecture. De même, il faut un descripteur sur une ouverture en écriture pour un verrou de type exclusif<BR>.<BR>
<BR>
Pour décrire la portée du verrou que l'on veut poser, on utilise la même syntaxe que pour la primitive </FONT><FONT SIZE=5><TT>lseek</TT></FONT><FONT SIZE=5>, le début de l'intervalle est </FONT><FONT SIZE=5><B>whence+l_start</B></FONT><FONT SIZE=5>&nbsp;:<BR></FONT><FONT SIZE=5><TT>l_whence</TT></FONT><FONT SIZE=5> = SEEK_SET </FONT><FONT SIZE=5><FONT FACE=symbol>¾®</FONT></FONT><FONT SIZE=5> whence = 0<BR></FONT><FONT SIZE=5><TT>l_whence</TT></FONT><FONT SIZE=5> = SEEK_CUR </FONT><FONT SIZE=5><FONT FACE=symbol>¾®</FONT></FONT><FONT SIZE=5> whence = offset courrant<BR></FONT><FONT SIZE=5><TT>l_whence</TT></FONT><FONT SIZE=5> = SEEK_END </FONT><FONT SIZE=5><FONT FACE=symbol>¾®</FONT></FONT><FONT SIZE=5> whence = taille du fichier.<BR>La longueur du verrou est définie par le champ </FONT><FONT SIZE=5><TT>l_len</TT></FONT><FONT SIZE=5>. Si cette
valeur est nulle, le verrou va jusqu'à la fin du fichier (même si le
processus change cette fin). 
Remarque&nbsp;: il est possible de poser un verrou dont la portée est supérieure à la taille du fichier.<BR>Le champ </FONT><FONT SIZE=5><TT>l_pid</TT></FONT><FONT SIZE=5> contient le pid du processus propriétaire du
verrou, ce champ est rempli par </FONT><FONT SIZE=5><TT>fcntl</TT></FONT><FONT SIZE=5> dans le cas d'un appel consultatif (</FONT><FONT SIZE=5><TT>F_GETLK</TT></FONT><FONT SIZE=5>).<BR>
<BR>

</FONT><!--TOC section <FONT SIZE=5>Utilisation de </FONT><FONT SIZE=5><TT>fcntl</TT></FONT><FONT SIZE=5> pour manipuler les verrous</FONT>-->

<H2><FONT SIZE=5>14.4&nbsp;&nbsp; Utilisation de </FONT><FONT SIZE=5><TT>fcntl</TT></FONT><FONT SIZE=5> pour manipuler les verrous</FONT></H2><!--SEC END -->
<PRE><FONT SIZE=5><TT>
         #include &lt;sys/types.h&gt;
         #include &lt;unistd.h&gt;
         #include &lt;fcntl.h&gt;
         int fcntl(int desc, int commande, struct flock *verrou);
</TT></FONT></PRE><FONT SIZE=5><TT>fcntl</TT></FONT><FONT SIZE=5> retourne 0 en cas de succès, ou -1 en cas d'echec.<BR>Trois commandes possibles&nbsp;:
</FONT><DL COMPACT=compact>
<DT><FONT SIZE=5>
</FONT><FONT SIZE=5>F_SETLKW</FONT><DD><FONT SIZE=5> pose bloquante (Wait)
si il existe un verrou incompatible, </FONT><FONT SIZE=5><TT>errno</TT></FONT><FONT SIZE=5> a pour valeur
EAGAIN 
si l'on n'a pas les droits d'accès sur le fichier pour le type de verrou demandé, alors </FONT><FONT SIZE=5><TT>errno</TT></FONT><FONT SIZE=5> a pour valeur EACCES;
si la pose du verrou crée une situation d'interblocage, alors </FONT><FONT SIZE=5><TT>errno</TT></FONT><FONT SIZE=5> a pour valeur EDEADLK.
</FONT>
<DT><FONT SIZE=5>F_SETLK</FONT><DD><FONT SIZE=5> pose non bloquante
succès immédiat si il n'y a pas de verrou incompatible, ou une fois les verrous incompatibles levés.
si l'appel est interrompu, </FONT><FONT SIZE=5><TT>errno</TT></FONT><FONT SIZE=5> a pour valeur EINTR
si une situation d'interblocage est détectée, alors </FONT><FONT SIZE=5><TT>errno</TT></FONT><FONT SIZE=5> a pour valeur EDEADLK.
</FONT>
<DT><FONT SIZE=5>F_GETLK</FONT><DD><FONT SIZE=5> Test d'existence d'un verrou incompatible avec le verrou passé en paramètre (retour -1 sur des paramètres incorrects)
si il existe un tel verrou incompatible, alors la structure flock passée en paramètre est remplie avec les valeurs de ce verrou incompatible. Le champ </FONT><FONT SIZE=5><TT>l_pid</TT></FONT><FONT SIZE=5> indique alors l'identité du processus propriétaire de ce verrou incompatible.
sinon, la structure flock reste inchangée excepté le champ type qui contient F_UNLCK.</FONT></DL><FONT SIZE=5>Attention, après un test d'existence qui nous informe de l'absence de
verrou incompatible, nous ne sommes pas assuré qu'au prochain appel la pose de ce verrou soit possible, en effet un autre processus a peut-être posé un verrou incompatible entre-temps (cf. interblocages chapitre </FONT><A HREF="#interblocages"><FONT SIZE=5>15</FONT></A><FONT SIZE=5>).<BR>
<BR>

</FONT><!--TOC chapter <FONT SIZE=5>Algorithmes Distribués &amp; Interblocages</FONT>-->

<H1><FONT SIZE=5>Chapitre&nbsp;15&nbsp;&nbsp; Algorithmes Distribués &amp; Interblocages</FONT></H1><!--SEC END -->
<A NAME="interblocages"></A><FONT SIZE=5>Ce chapitre introduit les problèmes liés à la gestion de processus
concurrents. Le problème à resoudre est le partage de ressources entre
différents processus asynchrones. Les I.P.C. et les verrous
sont deux types d'outils permettant le partage asynchrone de ressources
entre processus. <BR>Prenons un exemple simple pour décrire les problèmes de partages.<BR><BR>
<BR>
Problème&nbsp;: il y a une rivière que l'on peut traverser par un gué fait de pierre alignées, où il n'est pas possible de se croiser, et il n'est pas possible de faire demi-tour. Comment doit-t-on organiser le passage ?<BR>Solutions&nbsp;:
</FONT><OL type=1>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5> regarder avant de traverser
</FONT>
<LI><FONT SIZE=5> si deux personnes arrivent en même temps sur chaque rive, 
si elles avancent en même temps </FONT><FONT SIZE=5><FONT FACE=symbol>¾®</FONT></FONT><FONT SIZE=5> interblocage
si elles attendent en même temps </FONT><FONT SIZE=5><FONT FACE=symbol>¾®</FONT></FONT><FONT SIZE=5> interblocage
</FONT>
<LI><FONT SIZE=5> Un remède&nbsp;: un côté prioritaire </FONT><FONT SIZE=5><FONT FACE=symbol>¾®</FONT></FONT><FONT SIZE=5> famine. 
En effet si le coté OUEST est prioritaire et qu'un flot continu de personnes arrive de ce côté, les personnes à l'EST sont bloquées indéfiniment.
</FONT>
<LI><FONT SIZE=5> Une solution&nbsp;: alterner les priorités.
</FONT></OL><FONT SIZE=5>Pour des ressources système comme les fichiers, le partage n'est pas
géré par le SGF. Il faut donc un mécanisme de partage &nbsp;: les verrous,
qui permettent un partage dynamique et partiel (portions de
fichiers). Pour un partage entre utilisateurs, on utilise plutôt des
outils comme </FONT><FONT SIZE=5><TT>SCCS, RCS</TT></FONT><FONT SIZE=5>.<BR></FONT><!--TOC subsection <FONT SIZE=5>Mode d'utilisation des ressources par un processus.</FONT>-->

<H3><FONT SIZE=5>15.0.1&nbsp;&nbsp; Mode d'utilisation des ressources par un processus.</FONT></H3><!--SEC END -->
<FONT SIZE=5>Formalisons les opérations réalisables sur une ressource.
</FONT><UL>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5> requête&nbsp;: demande bloquante de ressources</FONT><BR>
<BR>

<LI><FONT SIZE=5> utilisation&nbsp;: lecture/écriture sur la zone verrouillée</FONT><BR>
<BR>

<LI><FONT SIZE=5> libération&nbsp;: verrou L-type
</FONT></UL><!--TOC subsection <FONT SIZE=5>Définition de l'interblocage (deadlock)</FONT>-->

<H3><FONT SIZE=5>15.0.2&nbsp;&nbsp; Définition de l'interblocage (deadlock)</FONT></H3><!--SEC END -->
<FONT SIZE=5>Un ensemble de processus est en </FONT><FONT SIZE=5><B>interblocage</B></FONT><FONT SIZE=5> si et seulement si tout processus de l'ensemble est en attente d'un évènement qui ne peut être réalisé que par un autre processus de l'ensemble.<BR>Exemple&nbsp;:<BR>Le processus A possède un verrou de portée [0,400] sur un fichier f, et demande un verrou de portée [800,1000] sur ce même fichier, alors qu'un processus B possède un verrou de portée [600,900] sur le fichier f et demande un verrou de portée [0,33] sur f. Les deux processus sont en interblocage. 
Dans le cas de la pose de verrous sous UNIX, il y a détection de cet interblocage et la commande </FONT><FONT SIZE=5><TT>fcntl</TT></FONT><FONT SIZE=5> échoue.<BR>
<BR>
</FONT><!--TOC subsection <FONT SIZE=5>Quatre conditions nécessaires à l'interblocage.</FONT>-->

<H3><FONT SIZE=5>15.0.3&nbsp;&nbsp; Quatre conditions nécessaires à l'interblocage.</FONT></H3><!--SEC END -->
<FONT SIZE=5>Les conditions suivantes sont </FONT><FONT SIZE=5><B>nécessaires</B></FONT><FONT SIZE=5> pour avoir une
possibilité d'interblocage.<BR></FONT><DL COMPACT=compact>
<DT><FONT SIZE=5>
</FONT><FONT SIZE=5>Exclusion mutuelle</FONT><DD><FONT SIZE=5> 
les ressources ne sont pas partageables, un seul processus à la fois peut utiliser la ressource.</FONT><BR>
<BR>

<DT><FONT SIZE=5>Possession &amp; attente</FONT><DD><FONT SIZE=5> 
il doit exister un processus qui utilise une ressource et qui est en attente sur une requête.</FONT><BR>
<BR>

<DT><FONT SIZE=5>Sans préemption</FONT><DD><FONT SIZE=5>
les ressources ne sont pas préemptibles c'est-à-dire que les libérations sont faites volontairement par les processus. On ne peut pas forcer un processus à rendre une ressource. 
(Contre exemple : le CPU sous Unix est préemptible)<BR>
<BR>
 </FONT>
<DT><FONT SIZE=5>Attente circulaire</FONT><DD><FONT SIZE=5> 
il doit exister un ensemble de processus </FONT><FONT SIZE=5><I>P</I></FONT><SUB><FONT SIZE=4><I>i</I></FONT></SUB><FONT SIZE=5> tel que </FONT><FONT SIZE=5><I>P</I></FONT><SUB><FONT SIZE=4><I>i</I></FONT></SUB><FONT SIZE=5> attend une ressource possédée par </FONT><FONT SIZE=5><I>P</I></FONT><SUB><FONT SIZE=4><I>i</I>+1</FONT></SUB><FONT SIZE=5>.</FONT></DL><FONT SIZE=5>
Les quatre conditions sont nécessaires pour qu'une situation
d'interblocage ait lieu.<BR>Exercice&nbsp;: montrer que pour les verrous, les quatre conditions tiennent.<BR>Exercice&nbsp;: montrer que si l'une des condition n'est pas vérifiée
 alors il ne peut y avoir d'interblocage.<BR>
<BR>
</FONT><!--TOC subsection <FONT SIZE=5>Les graphes d'allocation de ressources</FONT>-->

<H3><FONT SIZE=5>15.0.4&nbsp;&nbsp; Les graphes d'allocation de ressources</FONT></H3><!--SEC END -->
<FONT SIZE=5>Les graphes d'allocation de ressources permettent de décrire simplement les problèmes d'interblocage.<BR>
<BR>
</FONT><CODE><FONT SIZE=5>G = (N,T)	N = P U R</FONT></CODE><FONT SIZE=5><BR>	P : ensemble des processus<BR>	R : ensemble des ressources<BR>T est inclus dans RXP U PXR <BR>Soit le couple (x,y) appartenant à T,<BR>si (x,y) appartient à RXP, cela signifie que la ressource x est utilisée par le processus y.<BR>si (x,y) appartient à PXR, cela signifie que le processus x demande la ressource y.<BR><BR>
<BR>


</FONT><!--TOC chapter <FONT SIZE=5> Inter Processus Communications (I.P.C.)</FONT>-->

<H1><FONT SIZE=5>Chapitre&nbsp;16&nbsp;&nbsp;  Inter Processus Communications (I.P.C.)</FONT></H1><!--SEC END -->
<A NAME="IPC"></A><FONT SIZE=5>Les mécanismes d'IPC permettent de faire communiquer et/ou de synchroniser n'importe quel couple de processus locaux (de la même machine).<BR>Les trois mécanismes d'IPC : files de messages, segments de mémoire partagée, sémaphores, sont purement mémoire. Ils n'ont pas de liens avec le système de fichiers, ce qui les sort de la philosophie UNIX. <BR>Ces mécanismes ne sont plus désignés localement dans les processus par des descripteurs standards, et de ce fait il n'est plus possible d'utiliser les mécanismes de lecture et d'écriture standards sur de tels objets.<BR>Le système prend en charge la gestion de ces objets. C'est lui qui tient à jour les tables qui les contiennent.<BR></FONT><!--TOC section <FONT SIZE=5>Références d'IPC</FONT>-->

<H2><FONT SIZE=5>16.1&nbsp;&nbsp; Références d'IPC</FONT></H2><!--SEC END -->
<FONT SIZE=5>Les objets sont référencés par deux noms : le numéro d'identification dans le processus, qui est retourné par les fonctions get : </FONT><FONT SIZE=5><TT>msgget, semget, shmget</TT></FONT><FONT SIZE=5>.<BR>
<BR>
Nous appellerons par la suite </FONT><FONT SIZE=5><TT>dipc</TT></FONT><FONT SIZE=5> ce descripteur d'IPC. L'autre référence de l'IPC est la clé (</FONT><FONT SIZE=5><TT>key</TT></FONT><FONT SIZE=5>) qui est utilisée dans l'appel de la fonction </FONT><FONT SIZE=5><TT>get</TT></FONT><FONT SIZE=5> pour identifier l'objet IPC (du système) auquel on cherche à accéder.<BR>
<BR>
La clé permet à plusieurs processus d'accéder au même objet IPC (ce qui est fondamental). Mais ce système de clé est d'une gestion délicate, et pose des problèmes.<BR>
<BR>
Comme les clés sont arbitraires (un entier long de la machine Hôte), des problèmes de droits et de choix de la clé se posent.<BR>
<BR>
Il n'est pas assuré à un système client/serveur qui démarre que sa clé privée n'est pas déjà utilisée par un autre processus ! Comme le client et le serveur doivent avoir la même clé, des complications surviennent.<BR>
<BR>
</FONT><!--TOC subsection <FONT SIZE=5>Création de clés</FONT>-->

<H3><FONT SIZE=5>16.1.1&nbsp;&nbsp; Création de clés</FONT></H3><!--SEC END -->
<FONT SIZE=5>
Pour résoudre ce problème, une fonction de création automatique de clé a été mise au point. Cette fonction </FONT><FONT SIZE=5><TT>ftock()</TT></FONT><FONT SIZE=5> utilise une référence de l'arborescence pour créer une clé unique.<BR>
<BR>
</FONT><PRE><FONT SIZE=5><TT>
key_t ftok(const char *, char);
</TT></FONT></PRE><FONT SIZE=5> Si tout le monde utilise de telles clés, le problème soulevé précédemment disparait.<BR>
<BR>
Malheureusement, cette fonction </FONT><FONT SIZE=5><TT>ftock</TT></FONT><FONT SIZE=5> utilise pour créer une clé le numéro de disque logique et d'inode de la référence donnée en paramètre (il faut que la référence passée en paramètre à </FONT><FONT SIZE=5><TT>ftock</TT></FONT><FONT SIZE=5> existe, sinon </FONT><FONT SIZE=5><TT>ftock</TT></FONT><FONT SIZE=5> renvoie -1). <BR>
<BR>
Ceci pose un autre type de problème : si l'on change l'inode associée à la référence, cela change la valeur de la clé, donc il n'est plus possible de retrouver la clé originale.<BR>
<BR>
Le conseil de tonton Doumé : utiliser un fichier verrouillé comme référence et faire le ménage ... comme pour les pseudo-terminaux, ou les tubes.<BR>
<BR>
</FONT><!--TOC subsection <FONT SIZE=5>La structure ipc_perm</FONT>-->

<H3><FONT SIZE=5>16.1.2&nbsp;&nbsp; La structure ipc_perm</FONT></H3><!--SEC END -->
<FONT SIZE=5>La structure </FONT><FONT SIZE=5><TT>ipc_perm</TT></FONT><FONT SIZE=5> est commune aux trois mécanismes d'ipc. Elle permet, comme le fait une inode, de stocker l'utilisateur créateur, l'utilisateur propriétaire ainsi que leurs groupes. On différencie pour les IPC, l'utilisateur créateur (qui a réalisé la fonction get) du propriétaire de l'IPC. Les droits d'accès sont limités à la lecture et l'écriture (l'exécution n'ayant pas de sens ...).<BR>
<BR>
La structure </FONT><FONT SIZE=5><TT>ipc_perm</TT></FONT><FONT SIZE=5> et les droits d'accès à un objet IPC &nbsp;:
</FONT><PRE><FONT SIZE=5><TT>
     typedef long key_t;    /* for ftok() function */
     typedef long uid_t;    /* Used for user IDs */
     typedef long gid_t;    /* Used for group IDs */

 /* Common IPC Access Structure */
   struct ipc_perm {
        uid_t           uid;    /* owner's user id */
        gid_t           gid;    /* owner's group id */
        uid_t           cuid;   /* creator's user id */
        gid_t           cgid;   /* creator's group id */
        unsigned short  mode;   /* access modes */
        unsigned short  seq;    /* slot usage sequence number */
        key_t           key;    /* key */
   };
</TT></FONT></PRE><FONT SIZE=5> </FONT><!--TOC subsection <FONT SIZE=5>Les options de la structure ipc_perm</FONT>-->

<H3><FONT SIZE=5>16.1.3&nbsp;&nbsp; Les options de la structure ipc_perm</FONT></H3><!--SEC END -->
<FONT SIZE=5>
</FONT><PRE><FONT SIZE=5><TT>
#  define  IPC_CREAT   0001000     /* create entry if key doesn't exist */
#  define  IPC_EXCL    0002000     /* fail if key exists */
#  define  IPC_NOWAIT  0004000     /* error if request must wait */

   /* Keys. */
#  define  IPC_PRIVATE  (key_t)0    /* private key */

   /* Control Commands. */
#  define  IPC_RMID    0           /* remove identifier */
#  define  IPC_SET     1           /* set options */
#  define  IPC_STAT    2           /* get options */

  /* Common IPC Definitions. */
   /* Mode bits. */
#  define  IPC_ALLOC   0100000     /* entry currently allocated */
#  define  IPC_LOCKED  0040000     /* structure is locked */
#  define  IPC_WANTED  0004000     /* process waiting for lock *
</TT></FONT></PRE><FONT SIZE=5> </FONT><!--TOC subsection <FONT SIZE=5>L'accès aux tables d'IPC par le shell</FONT>-->

<H3><FONT SIZE=5>16.1.4&nbsp;&nbsp; L'accès aux tables d'IPC par le shell</FONT></H3><!--SEC END -->
<FONT SIZE=5>La commande </FONT><FONT SIZE=5><TT>ipcs</TT></FONT><FONT SIZE=5> (IPC state ) permet de connaître l'état des IPC de la machine (comme la commande ps pour les processus). Par exemple sur fillmore &nbsp;: <BR></FONT><PRE><FONT SIZE=5><TT>
IPC status from /dev/kmem as of Mon Apr  5 18:23:31 1993
T     ID     KEY        MODE       OWNER    GROUP
Message Queues:
q      3 0x4917dfe1 --rw-rw-rw-     root     root
q      4 0xd5dcf701 --rw-rw-rw-     root     root
Shared Memory:
m      0 0x41440010 --rw-rw-rw-     root     root
m      1 0x414461bf --rw-rw-rw-     root     root
m      2 0x41460741 --rw-rw-rw-     root     root
m      3 0xff46df0e --rw-rw-rw-     root     root
m      4 0xfe46df0e --rw-rw-rw-     root     root
m    808 0x44446180 --rw-r-----     root  licence
Semaphores:
s      0 0x414461bf --ra-ra-ra-     root     root
s      1 0x41460741 --ra-ra-ra-     root     root
s      2 0x00446f6d --ra-r--r--     root     root
s      3 0x01090522 --ra-r--r--     root     root
s      4 0x054baa58 --ra-r--r--     root     root
s      5 0xff46df0e --ra-ra-ra-     root     root
s      6 0x00000000 --ra-ra----   oracle      dba
</TT></FONT></PRE><FONT SIZE=5> Où l'on a les informations suivantes &nbsp;:<BR></FONT><DL COMPACT=compact>
<DT><FONT SIZE=5>
</FONT><FONT SIZE=5>T</FONT><DD><FONT SIZE=5> type
</FONT>
<DT><FONT SIZE=5>ID</FONT><DD><FONT SIZE=5> identification interne de l'objet
</FONT>
<DT><FONT SIZE=5>KEY</FONT><DD><FONT SIZE=5> clé de l'objet (en hexa) avec 0x000000 mode IPC_PRIVATE
</FONT>
<DT><FONT SIZE=5>MODE</FONT><DD><FONT SIZE=5> droits d'accès
</FONT>
<DT><FONT SIZE=5>OWNER</FONT><DD><FONT SIZE=5> propriétaire
</FONT>
<DT><FONT SIZE=5>GROUP</FONT><DD><FONT SIZE=5> propriétaire
</FONT>
<DT><FONT SIZE=5>CREATOR</FONT><DD><FONT SIZE=5>
</FONT>
<DT><FONT SIZE=5>CGROUP</FONT><DD><FONT SIZE=5>
</FONT></DL><FONT SIZE=5>
D'autres options, -q -m -s -a -c <BR>L'autre commande </FONT><FONT SIZE=5><TT>ipcrm</TT></FONT><FONT SIZE=5> permet de détruire les ipc dont on donne soit
</FONT><DL COMPACT=compact>
<DT><FONT SIZE=5>
</FONT><FONT SIZE=5>l'identifiant</FONT><DD><FONT SIZE=5> avec -q -m et -s, soit par exemple, </FONT><FONT SIZE=5><TT>ipcrm -q 5</TT></FONT><FONT SIZE=5> détruit les files de messages d'identifiant 5.
</FONT>
<DT><FONT SIZE=5>la clé</FONT><DD><FONT SIZE=5> avec -Q -M -S, soit par exemple </FONT><FONT SIZE=5><TT>ipcrm -M 0x01090522</TT></FONT><FONT SIZE=5> détruit les segments de mémoire de clé 0x01090522
</FONT></DL><FONT SIZE=5>Ces options sont combinables.<BR>
<BR>
</FONT><FONT SIZE=5> <B>Attention</B></FONT><FONT SIZE=5> ne jamais utiliser les identifiants fournis par </FONT><FONT SIZE=5><TT>ipcs</TT></FONT><FONT SIZE=5> dans un programme. Ils ne sont pas totalement compatibles, c'est la clé qui est la seule référence solide.<BR>
<BR>
</FONT><!--TOC section <FONT SIZE=5>Les files de messages</FONT>-->

<H2><FONT SIZE=5>16.2&nbsp;&nbsp; Les files de messages</FONT></H2><!--SEC END -->
<FONT SIZE=5>
Utilise le principe des boîtes aux lettres &nbsp;: on dépose dans la boîte un message que d'autres processus pourront lire.<BR>Le mode de lecture/écriture se fait de manière groupée par une structure de taille donnée. Chaque instruction de lecture ou d'écriture se fait sur un message entier (toute la structure de message).
Pour que les lectures soient compatibles avec les écritures, les messages sont typés.
On utilisera une structure dont le premier champ est un entier long qui doit contenir le type du message.<BR></FONT><FONT SIZE=5><B>Règle d'or</B></FONT><FONT SIZE=5> &nbsp;: le type d'un message est un entier strictement positif.<BR>Le type du message permet aux applications d'effectuer les bons ordres de lecture, mais aussi permet de sélectionner le ou les messages dans la file d'attente.<BR>
<BR>
Le fichier </FONT><CODE><FONT SIZE=5><TT>&lt;sys/msg.h&gt;</TT></FONT></CODE><FONT SIZE=5><BR>Quelques macros permettant de paramètrer les appels&nbsp;:<BR></FONT><DL COMPACT=compact>
<DT><FONT SIZE=5>
</FONT><FONT SIZE=5>MSG_NOERROR</FONT><DD><FONT SIZE=5> l'extraction d'un message trop long n'entraine pas d'erreur (le message est tronqué).
</FONT>
<DT><FONT SIZE=5>MSG_R</FONT><DD><FONT SIZE=5> autorisation de lire dans la file.
</FONT>
<DT><FONT SIZE=5>MSG_W</FONT><DD><FONT SIZE=5> autorisation d'écrire dans la file.
</FONT>
<DT><FONT SIZE=5>MSG_RWAIT</FONT><DD><FONT SIZE=5> indication qu'un processus est bloqué en lecture.
</FONT>
<DT><FONT SIZE=5>MSG_WWAIT</FONT><DD><FONT SIZE=5> indication qu'un processus est bloqué en écriture.
</FONT></DL><!--TOC subsection <FONT SIZE=5>la structure ms</FONT><FONT SIZE=5><B>q</B></FONT><FONT SIZE=5>id_ds </FONT>-->

<H3><FONT SIZE=5>16.2.1&nbsp;&nbsp; la structure ms</FONT><FONT SIZE=5><B>q</B></FONT><FONT SIZE=5>id_ds </FONT></H3><!--SEC END -->
<PRE><FONT SIZE=5><TT>
 struct msqid_ds {
    struct ipc_perm    msg_perm;       /* opération permission struct */
    struct __msg       *msg_first;     /* ptr to first message on q */
    struct __msg       *msg_last;      /* ptr to last message on q */
    unsigned short int msg_qnum;       /* # of messages on q */
    unsigned short int msg_qbytes;     /* max # of bytes on q */
    pid_t              msg_lspid;      /* pid of last msgsnd */
    pid_t              msg_lrpid;      /* pid of last msgrcv */
    time_t             msg_stime;      /* last msgsnd time */
    time_t             msg_rtime;      /* last msgrcv time */
    time_t             msg_ctime;      /* last change time */
    unsigned short int msg_cbytes;     /* current # bytes on q */
    char               msg_pad[22];    /* room for future expansion */
   };
</TT></FONT></PRE><FONT SIZE=5> </FONT><!--TOC subsection <FONT SIZE=5>La structure générique d'un message </FONT>-->

<H3><FONT SIZE=5>16.2.2&nbsp;&nbsp; La structure générique d'un message </FONT></H3><!--SEC END -->
<FONT SIZE=5>La structure suivante est un modèle pour les messages &nbsp;:<BR>
<BR>
</FONT><PRE><FONT SIZE=5><TT>
struct msgbuf { 
    long mtype;    /* type du message */
    char mtext[1]; /* texte du message */
};
</TT></FONT></PRE><FONT SIZE=5> par exemple :
</FONT><PRE><FONT SIZE=5><TT>
struct msg_buffer {
    long toto; /* type */
    float a;
    char m[7];
};
</TT></FONT></PRE><FONT SIZE=5> </FONT><FONT SIZE=5><B>Attention</B></FONT><FONT SIZE=5> on ne peut pas échanger des adresses, en effet les adresses virtuelles utilisées
par les différents programmes qui échangent des messages sont à priori différentes,
de plus les zones de mémoire manipulables par deux processus sont disjointes.<BR>
<BR>
</FONT><FONT SIZE=5> <B>Important</B></FONT><FONT SIZE=5> : le premier champ doit être un entier long qui contiendra le type du message.
On trouvera d'autres structures dans le fichier sys/msg.h, mais elle ne sont pas utilisées par les applications utilisateur. <BR>
<BR>
Par exemple, la structure de file de message &nbsp;:
</FONT><PRE><FONT SIZE=5><TT>
struct __msg {
    struct __msg        *msg_next; 
    long                msg_type;
    unsigned short int  msg_ts;   /*  taille du texte */
    long                msg_spot; /* "adresse" du texte */
};
</TT></FONT></PRE><FONT SIZE=5> ou la structure </FONT><FONT SIZE=5><TT>msginfo</TT></FONT><FONT SIZE=5> utilisé par le noyau.<BR>
<BR>
</FONT><!--TOC subsection <FONT SIZE=5>Utilisation des files de messages</FONT>-->

<H3><FONT SIZE=5>16.2.3&nbsp;&nbsp; Utilisation des files de messages</FONT></H3><!--SEC END -->
<FONT SIZE=5>
La primitive 
</FONT><PRE><FONT SIZE=5><TT>
#include &lt;sys/msg.h&gt;
int msgget (key_t  cle, int options);
</TT></FONT></PRE><FONT SIZE=5> est une fonction proche de la fonction </FONT><FONT SIZE=5><TT>open</TT></FONT><FONT SIZE=5>.
Elle renvoie un descripteur d'IPC de file de messages de key = </FONT><FONT SIZE=5><TT>cle</TT></FONT><FONT SIZE=5>.
Avec création ou non de la file de messages en fonction de l'existence de celle-ci et du paramètre </FONT><FONT SIZE=5><TT>options</TT></FONT><FONT SIZE=5>.<BR>La valeur du paramètre </FONT><FONT SIZE=5><TT>options</TT></FONT><FONT SIZE=5> doit être construite avec une conjonction du mode d'accès et des constantes IPC_CREAT et IPC_EXCL.
</FONT><TABLE CELLSPACING=2 CELLPADDING=0>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=5>Si cle == IPC_PRIVATE</FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>une nouvelle file de messages privée est crée.</FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=5>Sinon</FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>Si la cle correspond à une file inexistante:</FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>SI IPC_CREAT est positionné (dans options), une nouvelle file est crée associé à cette clé,</FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>avec les droits définis dans options.</FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>Le créateur et le propriétaire sont positionnés</FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>aux valeurs de l'euid et du egid du processus réalisant l'appel,</FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>le dipc interne de la file est retourné.</FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>sinon erreur retour -1</FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>Sinon la cle correspond à une file déjà existante :</FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>Si les 2 indicateurs IPC_CREAT et IPC_EXCL sont positionnés dans options</FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>une erreur est détectée, retour -1, errno = EEXIST.</FONT></TD>
</TR>
<TR><TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5></FONT></TD>
<TD ALIGN=left NOWRAP><FONT SIZE=5>sinon l'identification de la file est retourné.
</FONT></TD>
</TR></TABLE><BR>
<FONT SIZE=5>En bref, IPC_EXCL nous permet de vérifier que la file n'existait pas.<BR>
<BR>
</FONT><!--TOC subsection <FONT SIZE=5>L'envoi de message</FONT>-->

<H3><FONT SIZE=5>16.2.4&nbsp;&nbsp; L'envoi de message</FONT></H3><!--SEC END -->
<PRE><FONT SIZE=5><TT>
#include &lt;sys/msg.h&gt;
int msgsnd (int dipc, const void *p_msg, int lg, int options);
</TT></FONT></PRE><FONT SIZE=5> Envoie dans la file </FONT><FONT SIZE=5><TT>dipc</TT></FONT><FONT SIZE=5> le message pointé par </FONT><FONT SIZE=5><TT>p_msg</TT></FONT><FONT SIZE=5>.<BR>
<BR>
</FONT><FONT SIZE=5> <B>lg</B></FONT><FONT SIZE=5> taille du message égale à </FONT><FONT SIZE=5><TT>sizeof(struct msgbuf)-sizeof(long)</TT></FONT><FONT SIZE=5>, le type du message n'étant pas compté dans cette longueur.<BR>
<BR>
Valeur de retour (0) succes (-1) échec.<BR>
<BR>
Valeur de </FONT><FONT SIZE=5><TT>errno</TT></FONT><FONT SIZE=5> en cas d'échec:
</FONT><DL COMPACT=compact>
<DT><FONT SIZE=5>
</FONT><FONT SIZE=5>EINVAL</FONT><DD><FONT SIZE=5> file inexistante
</FONT>
<DT><FONT SIZE=5>EPERM</FONT><DD><FONT SIZE=5> pas de droits d'écriture
</FONT>
<DT><FONT SIZE=5>EINVAL</FONT><DD><FONT SIZE=5> type de message incorrect
</FONT></DL><FONT SIZE=5>Si IPC_NOWAIT est positionné, l'envoi de messages sur une file pleine n'est plus bloquant,
alors dans le cas d'une file pleine, la fonction retourne -1 et </FONT><FONT SIZE=5><TT>errno</TT></FONT><FONT SIZE=5> est positionné à EAGAIN.<BR>
<BR>
Un appel de </FONT><FONT SIZE=5><TT>msgsnd</TT></FONT><FONT SIZE=5> bloqué peut être interrompu par un signal ou par la destruction de la file de message. Dans ce cas, elle renvoie (-1) et </FONT><FONT SIZE=5><TT>errno</TT></FONT><FONT SIZE=5> est positionné à [EINTR] ou [EIDRM].<BR>
<BR>
</FONT><!--TOC subsection <FONT SIZE=5>La primitive d'extraction</FONT>-->

<H3><FONT SIZE=5>16.2.5&nbsp;&nbsp; La primitive d'extraction</FONT></H3><!--SEC END -->
<FONT SIZE=5>
</FONT><PRE><FONT SIZE=5><TT>
#include &lt;sys/msg.h&gt;
int msgrcv(int dipc, void *p_msg, int taille, long type, int options);
</TT></FONT></PRE><FONT SIZE=5> est une demande de lecture dans la file </FONT><FONT SIZE=5><TT>dipc</TT></FONT><FONT SIZE=5> d'un message de longueur inférieure ou égale à </FONT><FONT SIZE=5><TT>taille</TT></FONT><FONT SIZE=5>, qui sera copié dans la zone pointée par </FONT><FONT SIZE=5><TT>p_msg</TT></FONT><FONT SIZE=5>.
</FONT><FONT SIZE=5><TT>options</TT></FONT><FONT SIZE=5> est une combinaison des constantes:
</FONT><DL COMPACT=compact>
<DT><FONT SIZE=5>
</FONT><FONT SIZE=5>IPC_NOWAIT</FONT><DD><FONT SIZE=5> si la file est vide, le message est non-bloquant.
</FONT>
<DT><FONT SIZE=5>MSG_NOERROR</FONT><DD><FONT SIZE=5> si le texte du message à extraire est de longueur supérieure à </FONT><FONT SIZE=5><TT>taille</TT></FONT><FONT SIZE=5>, alors le message est extrait tronqué sans signaler d'erreur.
</FONT></DL><FONT SIZE=5>Le paramètre </FONT><FONT SIZE=5><TT>type</TT></FONT><FONT SIZE=5> permet de spécifier le type du message à extraire:
</FONT><UL>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5> si type </FONT><FONT SIZE=5>&gt;</FONT><FONT SIZE=5> 0, le plus vieux message de ce type est extrait;</FONT><BR>
<BR>

<LI><FONT SIZE=5> si type == 0, le plus vieux message est extrait;</FONT><BR>
<BR>

<LI><FONT SIZE=5> si type </FONT><FONT SIZE=5>&lt;</FONT><FONT SIZE=5> 0, le message le plus vieux du type le plus petit, mais inférieur ou égal à </FONT><FONT SIZE=5>|</FONT><FONT SIZE=5> type </FONT><FONT SIZE=5>|</FONT><FONT SIZE=5>, est extrait.
 Ceci permet de définir des priorités entre les messages.
</FONT></UL><FONT SIZE=5>Dans tous les cas, l'appel est bloquant si il n'y a pas de message du type voulu en attente.<BR>
<BR>
Les causes d'échec :
</FONT><DL COMPACT=compact>
<DT><FONT SIZE=5>
</FONT><FONT SIZE=5>EINVAL</FONT><DD><FONT SIZE=5> file inexistante
</FONT>
<DT><FONT SIZE=5>EINVAL</FONT><DD><FONT SIZE=5> taille négative
</FONT>
<DT><FONT SIZE=5>E2BIG</FONT><DD><FONT SIZE=5> taille message </FONT><FONT SIZE=5>&gt;</FONT><FONT SIZE=5> taille, et pas de MSG_NOERROR
</FONT>
<DT><FONT SIZE=5>ENOMSG</FONT><DD><FONT SIZE=5> pas de message et IPC_NOWAIT
</FONT></DL><FONT SIZE=5>
et les mêmes codes d'interruptions que </FONT><FONT SIZE=5><TT>msgsnd</TT></FONT><FONT SIZE=5>.<BR>
<BR>
</FONT><!--TOC subsection <FONT SIZE=5>La primitive de contrôle</FONT>-->

<H3><FONT SIZE=5>16.2.6&nbsp;&nbsp; La primitive de contrôle</FONT></H3><!--SEC END -->
<FONT SIZE=5>
</FONT><PRE><FONT SIZE=5><TT>
#include &lt;sys/msg.h&gt;
int msgctl (int dipc, int options, struct msqid *pmsqid);
</TT></FONT></PRE><FONT SIZE=5> permet de travailler sur la structure </FONT><FONT SIZE=5><TT>msqid</TT></FONT><FONT SIZE=5> pointée par </FONT><FONT SIZE=5><TT>pmsqid</TT></FONT><FONT SIZE=5> de la file de message </FONT><FONT SIZE=5><TT>dipc</TT></FONT><FONT SIZE=5>. 
Valeur de </FONT><FONT SIZE=5><TT>options</TT></FONT><FONT SIZE=5> &nbsp;:
</FONT><DL COMPACT=compact>
<DT><FONT SIZE=5>
</FONT><FONT SIZE=5>IPC_STAT</FONT><DD><FONT SIZE=5> lecture de la structure
</FONT>
<DT><FONT SIZE=5>IPC_SET</FONT><DD><FONT SIZE=5> positionnement, seuls les champs uid,gid et perm sont modifiables
</FONT>
<DT><FONT SIZE=5>IPC_RMID</FONT><DD><FONT SIZE=5> permet de détruire la file de messages (super-utilisateur, ou créateur de la file de messages)
</FONT></DL><!--TOC section <FONT SIZE=5>Les sémaphores</FONT>-->

<H2><FONT SIZE=5>16.3&nbsp;&nbsp; Les sémaphores</FONT></H2><!--SEC END -->
<FONT SIZE=5>Les sémaphores permettent de réaliser l'accès en exclusion mutuelle à une ressource (par exemple une zone de mémoire partagée).<BR>
<BR>
Un peu de théorie &nbsp;:<BR>Les sémaphores garantissent l'accès d'un nombre borné de processus à une donnée. Ils permettent de placer en exclusion mutuelle une ressource (par exemple la mémoire).<BR>
<BR>
Dijkstra a écrit de nombreux algorithmes d'exclusion mutuelle, et a défini les sémaphores pour faciliter l'écriture de ces algorithmes. Les sémaphores sont des variables partagées, dont l'accès ne se fait que grâce aux deux opérations atomiques P et V.<BR>On appelle </FONT><FONT SIZE=5><EM>section critique</EM></FONT><FONT SIZE=5> la partie de programme qui doit être réalisée en exclusion.<BR>P(S)<BR></FONT><UL>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5> Soit la valeur du sémaphore S est positive, il y a donc encore au moins une place en section critique pour le processus qui réalise le P, le sémaphore est alors décrémenté (une place de moins) et le processus utilise la ressource.<BR></FONT>
<LI><FONT SIZE=5> Soit la valeur de S est nulle (plus de place), le processus est mis en attente.
</FONT></UL><FONT SIZE=5>
V(S)<BR></FONT><UL>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5> Si un ou plusieurs processus sont en attente du sémaphore, ils sont réveillés et l'un d'eux rentre en section critique. Les autres sont remis en attente.
</FONT>
<LI><FONT SIZE=5> Sinon le sémaphore est incrémenté (libération d'une place en section critique).
</FONT></UL><FONT SIZE=5>Ces opérations sont </FONT><FONT SIZE=5><B>atomiques</B></FONT><FONT SIZE=5> : totalement ininterruptibles, ont toujours lieu séquentiellement même sur une machine multi-processeurs.
<BR>Le fichier </FONT><CODE><FONT SIZE=5><TT>&lt;sys/sem.h&gt;</TT></FONT></CODE><FONT SIZE=5> &nbsp;:<BR>
<BR>
Pour chaque sémaphore :
</FONT><PRE><FONT SIZE=5><TT>
  struct __sem {
      unsigned short int semval;    /* adresse */
      unsigned short int sempid;    /* pid de dernière opération */
      unsigned short int semncnt;   /* # de Proc. en attente de V */
      unsigned short int semzcnt;   /* # en attente de S = 0 */
  };
</TT></FONT></PRE><FONT SIZE=5> Pour chaque dipc de sémaphore:
 </FONT><PRE><FONT SIZE=5><TT>
 struct semid_ds {
     struct ipc_perm    sem_perm;   /* droits  */
     struct __sem       *sem_base;  /* premier élément de l'ensemble*/
     time_t             sem_otime;  /* last semop time */
     time_t             sem_ctime;  /* last change time */
     unsigned short int sem_nsems;  /* taille de l'ensemble */
 };
</TT></FONT></PRE><FONT SIZE=5> </FONT><!--TOC subsection <FONT SIZE=5>La primitive de manipulation </FONT><FONT SIZE=5><TT>semop()</TT></FONT><FONT SIZE=5> </FONT>-->

<H3><FONT SIZE=5>16.3.1&nbsp;&nbsp; La primitive de manipulation </FONT><FONT SIZE=5><TT>semop()</TT></FONT><FONT SIZE=5> </FONT></H3><!--SEC END -->
<FONT SIZE=5>La primitive 
</FONT><PRE><FONT SIZE=5><TT>
#include &lt;sys/sem.h&gt;
int semop(int dipc, struct sembuf *sops, unsigned int nsops);
</TT></FONT></PRE><FONT SIZE=5> est utilisée pour réaliser un tableau d'opérations de sémaphores sur un ensemble de sémaphores indiqué par </FONT><FONT SIZE=5><TT>dipc</TT></FONT><FONT SIZE=5>.
</FONT><FONT SIZE=5><EM>sops</EM></FONT><FONT SIZE=5> est un pointeur sur tableau de structures </FONT><FONT SIZE=5><TT>sembuf</TT></FONT><FONT SIZE=5>, et </FONT><FONT SIZE=5><EM>nsops</EM></FONT><FONT SIZE=5> indique le nombre d'éléments du tableau. <BR>
<BR>
La structure </FONT><FONT SIZE=5><TT>sembuf</TT></FONT><FONT SIZE=5> 
</FONT><PRE><FONT SIZE=5><TT>
  struct sembuf {
      unsigned short int sem_num;    /* # sémaphore */
      short              sem_op;     /* opération du sémaphore */
      short              sem_flg;    /* flags de l'opération */
  };
</TT></FONT></PRE><FONT SIZE=5> Nature de l'opération dans la structure </FONT><FONT SIZE=5><TT>sembuf</TT></FONT><BR>
<BR>
<FONT SIZE=5>Si sem_num </FONT><FONT SIZE=5>&gt;</FONT><FONT SIZE=5> 0 <BR></FONT><FONT SIZE=5><FONT FACE=symbol>¾®</FONT></FONT><FONT SIZE=5> une opération V est effectuée sur le sémaphore sem_num<BR>Si sem_num </FONT><FONT SIZE=5>&lt;</FONT><FONT SIZE=5> 0 <BR></FONT><FONT SIZE=5><FONT FACE=symbol>¾®</FONT></FONT><FONT SIZE=5> une opération P est effectuée sur le sémaphore </FONT><FONT SIZE=5>|</FONT><FONT SIZE=5>sem_num</FONT><FONT SIZE=5>|</FONT><FONT SIZE=5><BR>Si sem_num == 0 <BR>c'est une opération d'attente qui se termine quand l'ensemble des sémaphores désignés par </FONT><FONT SIZE=5><TT>dipc</TT></FONT><FONT SIZE=5> sont à zéro.<BR>La primitive <BR>
<BR>
</FONT><PRE><FONT SIZE=5><TT>
#include &lt;sys/sem.h&gt;
int semop (int dipc, struct sembuf *tab_op, int nb_op);
</TT></FONT></PRE><FONT SIZE=5> Les </FONT><FONT SIZE=5><TT>nb_op</TT></FONT><FONT SIZE=5> opérations placées à l'adresse </FONT><FONT SIZE=5><TT>tab_op</TT></FONT><FONT SIZE=5> sont réalisées atomiquement, c'est à dire toutes réalisées ou aucune !!
Le noyau gérant l'atomicité.
Si la i-ème opération ne peut être réalisée, les (i-1) premières sont annulées.<BR>
<BR>
Chaque opération du tableau peut être rendue non bloquante.<BR>
<BR>
Le fait d'avoir un appel bloquant on non bloquant va donc dépendre de l'ordre dans lequel on place les opérations à effectuer dans le tableau ...<BR>
<BR>
Les cas d'échec
</FONT><DL COMPACT=compact>
<DT><FONT SIZE=5>
</FONT><FONT SIZE=5>EINVAL</FONT><DD><FONT SIZE=5> identification invalide 
</FONT>
<DT><FONT SIZE=5>EACCESS</FONT><DD><FONT SIZE=5> accès interdit 
</FONT>
<DT><FONT SIZE=5>E2BIG</FONT><DD><FONT SIZE=5> trop d'opérations 
</FONT>
<DT><FONT SIZE=5>EFBIG</FONT><DD><FONT SIZE=5> numéro de sémaphore incorrect 
</FONT>
<DT><FONT SIZE=5>EAGAIN</FONT><DD><FONT SIZE=5> Non réalisable + non bloquant 
</FONT>
<DT><FONT SIZE=5>EINVAL,ENOSPC</FONT><DD><FONT SIZE=5> trop d'opérations ou de SEM_UNDO 
</FONT>
<DT><FONT SIZE=5>ERANGE</FONT><DD><FONT SIZE=5> valeur du sémaphore trop grande !! 
</FONT>
<DT><FONT SIZE=5>EINTR</FONT><DD><FONT SIZE=5> interruption 
</FONT>
<DT><FONT SIZE=5>EIDRM</FONT><DD><FONT SIZE=5> sem supprimé 
</FONT></DL><!--TOC subsection <FONT SIZE=5>La primitive de contrôle des sémaphores</FONT>-->

<H3><FONT SIZE=5>16.3.2&nbsp;&nbsp; La primitive de contrôle des sémaphores</FONT></H3><!--SEC END -->
<PRE><FONT SIZE=5><TT>
#include &lt;sys/sem.h&gt;
int semctl(int dipc, int semnum, int op, ... /* arg variables */);
</TT></FONT></PRE><FONT SIZE=5> En fonction de </FONT><FONT SIZE=5><TT>op</TT></FONT><FONT SIZE=5> la fonction réalise :
</FONT><DL COMPACT=compact>
<DT><FONT SIZE=5>
</FONT><FONT SIZE=5>GETNCNT</FONT><DD><FONT SIZE=5> renvoi de la valeur de semncnt
</FONT>
<DT><FONT SIZE=5>GETZCNT</FONT><DD><FONT SIZE=5> renvoi de la valeur de semzcnt
</FONT>
<DT><FONT SIZE=5>GETVAL</FONT><DD><FONT SIZE=5> renvoi de la valeur du sémaphore
</FONT>
<DT><FONT SIZE=5>GETPID</FONT><DD><FONT SIZE=5> renvoi du pid du dernier processus ayant réalisé une opération.
</FONT></DL><FONT SIZE=5>
</FONT><FONT SIZE=5><TT>semnum</TT></FONT><FONT SIZE=5> est pour les commandes suivantes interprété comme un nombre de sémaphores<BR>
<BR>
</FONT><DL COMPACT=compact>
<DT><FONT SIZE=5>
</FONT><FONT SIZE=5>GETALL</FONT><DD><FONT SIZE=5> récupération du tableau des valeurs des </FONT><FONT SIZE=5><TT>semnum</TT></FONT><FONT SIZE=5> premiers sémaphores
</FONT>
<DT><FONT SIZE=5>SETALL</FONT><DD><FONT SIZE=5> positionnement des </FONT><FONT SIZE=5><TT>semnum</TT></FONT><FONT SIZE=5> premières valeurs du tableau
</FONT></DL><FONT SIZE=5>Et les commandes de manipulation de l'IPC&nbsp;:
</FONT><DL COMPACT=compact>
<DT><FONT SIZE=5>
</FONT><FONT SIZE=5>IPC_STAT</FONT><DD><FONT SIZE=5> lecture de la structure </FONT><FONT SIZE=5><TT>semid_ds</TT></FONT><FONT SIZE=5>
</FONT>
<DT><FONT SIZE=5>IPC_SET</FONT><DD><FONT SIZE=5> positionnement de la structure </FONT><FONT SIZE=5><TT>semid_ds</TT></FONT><FONT SIZE=5>
</FONT>
<DT><FONT SIZE=5>IPC_RMID</FONT><DD><FONT SIZE=5> permet de détruire le tableau de sémaphores (super-utilisateur, ou créateur du sémaphore)
</FONT></DL><!--TOC section <FONT SIZE=5>Les segments de mémoire partagée</FONT>-->

<H2><FONT SIZE=5>16.4&nbsp;&nbsp; Les segments de mémoire partagée</FONT></H2><!--SEC END -->
<FONT SIZE=5> Avec les segments de mémoire partagée, des processus vont partager des pages physiques par l'intermédiaire de leur espace d'adressage.
 Il n'y aura plus de copie d'information. Cette mémoire partagée devient un espace critique. Il faudra sans doute en protéger les accès avec des sémaphores par exemple...<BR>
<BR>
Un segment de mémoire est indépendant de tout processus. Il peut exister sans qu'aucun processus n'y accède.<BR>
<BR>
Un processus rattachera le segment à son espace d'adressage, puis pourra manipuler cette mémoire de la même façon qu'il peut manipuler sa propre mémoire.<BR>
<BR>
Le fichier </FONT><CODE><FONT SIZE=5>&lt;sys/shm.h&gt;</FONT></CODE><FONT SIZE=5> &nbsp;:<BR>
<BR>
</FONT><PRE><FONT SIZE=5><TT>
struct shmid_ds {
     struct ipc_perm  shm_perm;       /* operation permission struct */
     int              shm_segsz;      /* size of segment in bytes */
     struct vas       *shm_vas;       /* virtual address space this entry */
     pid_t            shm_lpid;       /* pid of last shmop */
     pid_t            shm_cpid;       /* pid of creator */
     unsigned short int shm_nattch;   /* current # attached  */
     unsigned short int shm_cnattch;  /* in memory # attached */
     time_t           shm_atime;      /* last shmat time */
     time_t           shm_dtime;      /* last shmdt time */
     time_t           shm_ctime;      /* last change time */
     char             shm_pad[24];    /* room for future expansion */
};
</TT></FONT></PRE><!--TOC subsection <FONT SIZE=5>Utilisation des segments de mémoire partagée</FONT>-->

<H3><FONT SIZE=5>16.4.1&nbsp;&nbsp; Utilisation des segments de mémoire partagée</FONT></H3><!--SEC END -->
<FONT SIZE=5>La primitive </FONT><FONT SIZE=5><TT>shmget</TT></FONT><FONT SIZE=5>&nbsp;:
</FONT><PRE><FONT SIZE=5><TT>
#include &lt;sys/shm.h&gt;
int shmget(key_t cle, int taille, int options);
</TT></FONT></PRE><FONT SIZE=5>Création/ouverture d'un segment de </FONT><FONT SIZE=5><TT>taille</TT></FONT><FONT SIZE=5> octets, si le segment existe déjà il faut que la </FONT><FONT SIZE=5><TT>taille</TT></FONT><FONT SIZE=5> soit inférieure ou égale à celle du segment que l'on veut ouvrir.<BR>La primitive d'attachement </FONT><FONT SIZE=5><TT>shmat</TT></FONT><FONT SIZE=5>&nbsp;:
</FONT><PRE><FONT SIZE=5><TT>
#include &lt;sys/shm.h&gt;
void  *shmat(int dipc, const void *adr, int option);
</TT></FONT></PRE><FONT SIZE=5> Cette primitive est une demande d'attachement du segment </FONT><FONT SIZE=5><TT>dipc</TT></FONT><FONT SIZE=5> à l'adresse </FONT><FONT SIZE=5><TT>adr</TT></FONT><FONT SIZE=5> de l'espace d'adressage du processus.
La valeur de retour est l'adresse où l'attachement a été efffectivement réalisé, c'est-à-dire celle attribuée au premier octet du segment (ou -1 en cas d'échec).<BR>
<BR>
Le choix du paramètre </FONT><FONT SIZE=5><TT>adr</TT></FONT><FONT SIZE=5> est délicat. Il faut en effet respecter un certain nombre de conditions, variables d'une machine à l'autre&nbsp;: l'alignement, la plage d'adresses autorisées aux segments de mémoire partagée, les adresses de pages virtuelles et physiques etc. On utilisera de preférence </FONT><FONT SIZE=5><TT>adr = NULL</TT></FONT><FONT SIZE=5>, c'est-à-dire qu'on laisse le soin au système de sélectionner l'adresse.<BR>
<BR>
Si l'on veut quand même positionner le segment dans une certaine zone de l'espace d'adressage, on utilise l'indicateur </FONT><FONT SIZE=5><TT>SHM_RND</TT></FONT><FONT SIZE=5> dans le paramètre </FONT><FONT SIZE=5><TT>options</TT></FONT><FONT SIZE=5> pour que le système choisisse une adresse valable la plus proche possible de </FONT><FONT SIZE=5><TT>adr</TT></FONT><FONT SIZE=5>. <BR>
<BR>
Remarques&nbsp;: l'attachement multiple par un même processus n'est pas autorisé sur tous les systèmes.<BR>L'attachement n'est valable que dans un seul processus, l'adresse d'attachement n'a aucune raison d'être identique dans tous les processus, on ne pourra donc pas utiliser de structures chaînées dans le segment de mémoire partagée.<BR>La primitve de détachement&nbsp;:
</FONT><PRE><FONT SIZE=5><TT>
#include &lt;sys/shm.h&gt;
int shmdt (const void *adr);
</TT></FONT></PRE><FONT SIZE=5>
détache le segment attaché à l'adresse </FONT><FONT SIZE=5><TT>adr</TT></FONT><FONT SIZE=5> par </FONT><FONT SIZE=5><TT>shmat</TT></FONT><FONT SIZE=5>.<BR>La primitive de contrôle&nbsp;:
</FONT><PRE><FONT SIZE=5><TT>
#include &lt;sys/shm.h&gt;
int shmctl(int dipc, int op, struct shmid_ds *pshmid);
</TT></FONT></PRE><FONT SIZE=5>
est extrêmement simple, les seules opérations sont celles qui sont génériques à tous les IPC.
</FONT><DL COMPACT=compact>
<DT><FONT SIZE=5>
</FONT><FONT SIZE=5>IPC_STAT</FONT><DD><FONT SIZE=5> lecture de la structure </FONT><FONT SIZE=5><TT>shmid_ds</TT></FONT><FONT SIZE=5>
</FONT>
<DT><FONT SIZE=5>IPC_SET</FONT><DD><FONT SIZE=5> positionnement de la structure </FONT><FONT SIZE=5><TT>shmid_ds</TT></FONT><FONT SIZE=5>
</FONT>
<DT><FONT SIZE=5>IPC_RMID</FONT><DD><FONT SIZE=5> permet de détruire le segment (super-utilisateur, ou créateur du sémaphore)
</FONT></DL><FONT SIZE=5>Une autre technique de partage de mémoire existe, avec la projection de fichier en mémoire (voir section </FONT><A HREF="#mmap"><FONT SIZE=5>10.5</FONT></A><FONT SIZE=5>).

</FONT><!--TOC chapter <FONT SIZE=5>La Sécurité</FONT>-->

<H1><FONT SIZE=5>Chapitre&nbsp;17&nbsp;&nbsp; La Sécurité</FONT></H1><!--SEC END -->
<FONT SIZE=5>La sécurité est le problème de tout le monde. Pour que la sécurité fonctionne, il
faut que toutes les personnes ayant un accès à une ressource soient conscient du
degré de sécurité associé à la ressource.<BR>
<BR>
</FONT><!--TOC section <FONT SIZE=5>Protection des systèmes d'exploitation</FONT>-->

<H2><FONT SIZE=5>17.1&nbsp;&nbsp; Protection des systèmes d'exploitation</FONT></H2><!--SEC END -->
<FONT SIZE=5>Sécuriser un système, c'est protéger ce système contre un fonctionnement imprévu ou défectueux.<BR>Il peut s'agir&nbsp;:
</FONT><UL>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5> d'erreurs de programmation (d'un utilisateur, ou du système lui-même) qui se propagent au système (du fait de contrôles insuffisants ou mal effectués).
</FONT>
<LI><FONT SIZE=5> d'un mauvais fonctionnement du matériel.
</FONT>
<LI><FONT SIZE=5> enfin, d'un opérateur, concepteur ou réalisateur malveillant ou peu scrupuleux (quand il s'agit d'informations financières!).
</FONT></UL><FONT SIZE=5>

Le recensement des opérations frauduleuses aux Etats-Unis au cours d'une année a donné 339 cas de fraude, pour un coût d'un milliard de francs.<BR>La protection des sites a également un coût très important (temps et
complexité), d'où des systèmes de protection qui résultaient d'un
compromis coût/efficacité.<BR>Le coût en ressources de la protection étant resté stationnaire, les systèmes
et les machines actuelles plus rapides ont rendu ce coût moins prohibitif.<BR>L'idée d'un système de protection est de traiter les différents types de problèmes de manière générale et unitaire.<BR>Implantés seuls, les dispositifs de protection coûtent cher. <BR>Heureusement, si ces dispositifs permettent d'augmenter les performances du logiciel, dans des domaines comme celui de la fiabilité ou de la résistance aux erreurs, leur coût relatif diminue. Si, de plus, ces dispositifs permettent une gestion des ressources partagées plus facile et plus sûre, ils peuvent devenir compétitifs d'un point de vue commercial.<BR>
Il est difficile de définir précisément ce que l'on entend par protection d'un système d'exploitation (et d'information en général), tant les facteurs qui peuvent influer sur cette notion (humains, sociaux, économiques), sont nombreux. On peut dire cependant que la protection se rapporte à tout ce par quoi l'information peut être modifiée, divulguée ou détruite. Dans certains cas, la gestion du trafic aérien par exemple, elle peut être la garantie des performances du système. La confidentialité d'enregistrements financiers, médicaux ou personnels relève aussi de la protection, comme le fait qu'un processus utilisateur ne puisse être exécuté en mode système. La protection exige enfin la correction des processus système.
</FONT><UL>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5> pérennité du système
</FONT>
<LI><FONT SIZE=5> confidentialité des données (système, utilisateur, etc.)
</FONT>
<LI><FONT SIZE=5> correction du système
</FONT></UL><FONT SIZE=5>
A l'opposé, nous ne parlerons pas de&nbsp;:
</FONT><UL>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5> protection physique de l'ordinateur (feu, vol, coupures, etc.)
</FONT>
<LI><FONT SIZE=5> malveillance ou incompétence de l'opérateur (il est éventuellement possible de limiter soigneusement les privilèges du super-utilisateur afin de préserver le système).
</FONT></UL><FONT SIZE=5>
Le degré de protection du système dépend de deux facteurs&nbsp;:
</FONT><UL>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5> le degré de protection des informations qu'il manipule 
</FONT>
<LI><FONT SIZE=5> le degré de confiance en ses logiciels, en particulier le système d'exploitation.
</FONT></UL><FONT SIZE=5>

Un logiciel est fiable quand il satisfait correctement ses spécifications et quand, de plus, il est capable de résister à un environnement imprévu (données erronées, pannes, etc.), soit en corrigeant l'anomalie, soit en la signalant, mais en évitant que les erreurs ne se propagent et ne contaminent le système tout entier.<BR>La protection, l'intégrité et l'authenticité des données qui transitent dans un système d'information sont réalisées par les systèmes cryptographiques (ATHENA et Kerberos au MIT).<BR>Le confinement des erreurs est obtenu en contrôlant les accès aux entités du système d'exploitation, par les domaines de protection.<BR>
</FONT><!--TOC section <FONT SIZE=5>Généralités sur le contrôle d'accès</FONT>-->

<H2><FONT SIZE=5>17.2&nbsp;&nbsp; Généralités sur le contrôle d'accès</FONT></H2><!--SEC END -->
<FONT SIZE=5>Contrôle très précis de l'utilisation des ressources par les processus.<BR>Deux niveaux&nbsp;:
</FONT><UL>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5> un niveau logique (soft), celui du modèle de protection, ensemble de règles qui définissent quels accès (aux ressources) sont autorisés et quels accès sont interdits. Ces règles sont définies soit à la conception du système, soit par les utilisateurs.
</FONT>
<LI><FONT SIZE=5> un niveau matériel qui permet d'appliquer le modèle réellement. C'est le rôle des mécanismes de protection.
</FONT></UL><FONT SIZE=5>
Le premier doit être dynamique. Par contre, le deuxième doit être stable pour faciliter l'implémentation, le contrôle et la fiabillisation.<BR>Les deux doivent de surcroît être indépendants du modèle pour offrir un vaste ensemble de règles possibles.<BR>
</FONT><!--TOC subsection <FONT SIZE=5>Domaines de protection et matrices d'accès</FONT>-->

<H3><FONT SIZE=5>17.2.1&nbsp;&nbsp; Domaines de protection et matrices d'accès</FONT></H3><!--SEC END -->
<FONT SIZE=5>On formalise le système comme un ensemble d'entités actives, les sujets, un ensemble d'entités accessibles, les objets. Le modèle de protection définit quels sujets ont accès à quels objets et comment (modalités d'accès). <BR>
<BR>
On parle alors de droit d'accès, définis par le couple (objet, modalités)<BR>
<BR>
Exemple&nbsp;: (fichier, lire)<BR>Le modèle doit fixer à tout instant les droits d'accès dont dispose chaque processus. Cet ensemble de droits est le domaine de protection du processus.<BR>
<BR>

</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML064.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 17.1&nbsp;: Matrice d'accès</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="matricedacces1"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>

</FONT><!--TOC subsection <FONT SIZE=5>Domaines de protection restreints</FONT>-->

<H3><FONT SIZE=5>17.2.2&nbsp;&nbsp; Domaines de protection restreints</FONT></H3><!--SEC END -->
<FONT SIZE=5>Il est souhaitable que la matrice d'accès puisse évoluer dynamiquement. En effet, un même processus peut avoir, au cours de son existence, des besoins variables afin que chaque module qui compose un processus ne mette pas en danger des ressources non utilisées. Par exemple&nbsp;: un module de lecture de données, un module de calcul, un module d'impression. 
On va donc exécuter chaque module dans un domaine de protection le plus réduit possible.<BR>
<BR>
C'est le </FONT><FONT SIZE=5><I>principe du moindre privilège</I></FONT><FONT SIZE=5>&nbsp;: un programme ne peut endommager un objet auquel il n'a pas accès !<BR>
<BR>
Pour mettre en place ces domaines dynamiques, une possibilité est de changer les droits d'accès du processus au cours de son exécution.
Une autre possibilité est d'ajouter aux objets le type "domaine" et de contrôler les accès à la matrice. L'édition de cases de la matrice devient une opération protégée.<BR>
<BR>

</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML065.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 17.2&nbsp;: Matrice d'accès</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="matricedacces3"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>


</FONT><!--TOC subsection <FONT SIZE=5>Avantages des domaines de protections restreints</FONT>-->

<H3><FONT SIZE=5>17.2.3&nbsp;&nbsp; Avantages des domaines de protections restreints</FONT></H3><!--SEC END -->
<FONT SIZE=5>
Avantages de cette souplesse &nbsp;:
</FONT><UL>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5> le maillon faible&nbsp;: un système rigide laisse souvent des
 "poternes" (portes dérobées) pour pouvoir implémenter certaines opérations&nbsp;;
</FONT>
<LI><FONT SIZE=5> si les mesures de protection sont trop pesantes, l'expérience prouve que l'on crée souvent des moyens "exceptionnels" pour les contourner&nbsp;;
</FONT>
<LI><FONT SIZE=5> il est intéressant de faire varier les contrôles suivant les utilisateurs&nbsp;;
</FONT>
<LI><FONT SIZE=5> on peut réaliser des accès à la carte sur certains objets&nbsp;;
</FONT>
<LI><FONT SIZE=5> enfin, certains problèmes de protection nécessitent des mesures souples, ce sont&nbsp;: "le cheval de Troie" et le confinement.
</FONT></UL><FONT SIZE=5>
</FONT><!--TOC section <FONT SIZE=5>Le cheval de Troie</FONT>-->

<H2><FONT SIZE=5>17.3&nbsp;&nbsp; Le cheval de Troie</FONT></H2><!--SEC END -->
<FONT SIZE=5>Un utilisateur fait souvent appel à un certain nombre de programmes qu'il n'a pas écrit lui-même (heureusement), un éditeur par exemple. Ce programme peut être un cheval de Troie&nbsp;: il va profiter des droits donnés par l'utilisateur pour consulter, copier, modifier ou altérer des données auxquelles il n'est pas censé accéder.<BR>
<BR>
</FONT><!--TOC section <FONT SIZE=5>Le confinement</FONT>-->

<H2><FONT SIZE=5>17.4&nbsp;&nbsp; Le confinement</FONT></H2><!--SEC END -->
<FONT SIZE=5>
Le problème ici est tout simplement le fait que le programme ne manipule pas de données de l'utilisateur mais simplement enregistre ses paramètres d'appels (les utilisateurs à qui vous envoyez du courrier par exemple). Le problème du confinement est donc de vous protéger contre ce type d'extraction d'informations (ce qui peut par exemple être utilisé en bourse pour connaitre votre comportement d'achat).<BR>
<BR>

</FONT><!--TOC section <FONT SIZE=5>les mécanismes de contrôle</FONT>-->

<H2><FONT SIZE=5>17.5&nbsp;&nbsp; les mécanismes de contrôle</FONT></H2><!--SEC END -->
<FONT SIZE=5>Accès hiérarchiques<BR>UNIX (4)/ MULTICS (8) / VMS <BR>Listes d'accès <BR>UNIX/MULTICS<BR>Capacités<BR>Les capacités sont des triplets </FONT><FONT SIZE=5><FONT COLOR=navy>(utilisateur, droits, pointeur)</FONT></FONT><FONT SIZE=5>.
 La manipulation des capacités est réalisée de façon protégée.
 Le pointeur n'est pas directement utilisable par l'utilisateur de la capacité.
 La capacité donne le droit d'accès à certains utilisateurs d'une certaine ressource.
 Pour qu'un autre utilisateur puisse utiliser votre ressource, vous devez lui donner une capacité.<BR>
<BR>

</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML066.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 17.3&nbsp;: Une capacité</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="capacite1"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>
Changer de protection revient à changer de C-liste.<BR>
<BR>
La notion de domaine se matérialise par une simple indirection sur une autre C-liste.<BR>
<BR>

</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML067.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 17.4&nbsp;: Une liste de capacités</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="capacite2"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>
Comme les capacités donnent un accès sans contrôle aux objets, la protection des capacités doit être absolue. Elle est donc réalisée de façon matérielle.<BR>
<BR>
</FONT><!--TOC subsection <FONT SIZE=5>Application des capacités au domaines de protection restreints</FONT>-->

<H3><FONT SIZE=5>17.5.1&nbsp;&nbsp; Application des capacités au domaines de protection restreints</FONT></H3><!--SEC END -->
<FONT SIZE=5>Les C-listes sont des objets d'un type n'ayant qu'un droit d'entrée, la C-liste
contenant le droit réel. <BR>
<BR>
Cette technique sur les C-listes permet d'implanter facilement le principe de moindre
privilège. <BR>
<BR>

</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML068.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 17.5&nbsp;:  Changement du domaine de protection</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="capacite3"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>
Les mécanismes d'accès mémoire modernes permettent aisément de réaliser les capacités.<BR>
<BR>
Un problème important est la révocation <BR>
<BR>
En effet, une fois que vous avez donné une capacité, l'accès est définitivement donné. Pour régler ce problème, on ne fournira pas la capacité d'accès à un objet mais à un domaine, et on détruira ce domaine si l'on veut de nouveau interdire l'accès à l'objet. On crée deux capacités en chaine et l'on détruit celle que l'on possède quand ont veut retirer l'accès.<BR>
<BR>


</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML069.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 17.6&nbsp;: Transmission d'une capacité</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="capacite4"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>


</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML070.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 17.7&nbsp;: Révocation d'une capacité</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="capacite5"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>


</FONT><!--TOC section <FONT SIZE=5>Les ACL</FONT>-->

<H2><FONT SIZE=5>17.6&nbsp;&nbsp; Les ACL</FONT></H2><!--SEC END -->
<FONT SIZE=5>Les ACL (access control lists) sont une extension des modes de protection standard d'UNIX.
Les ACL sont des droits que l'on définit en plus des 9 bits de protection classiques,
 ils permettent en particulier d'autoriser l'accès ou de le refuser, à un utilisateur donné,
 ou à un groupe donné. <BR>
<BR>
Deux commandes permettent de manipuler les ACL, ce sont </FONT><FONT SIZE=5><TT>chacl</TT></FONT><FONT SIZE=5> et </FONT><FONT SIZE=5><TT>lsacl</TT></FONT><FONT SIZE=5>.<BR>La syntaxe de la commande shell </FONT><FONT SIZE=5><TT>chacl</TT></FONT><FONT SIZE=5>&nbsp;:<BR></FONT><FONT SIZE=5><TT>chacl '(dr.staff,r-x)(zipstein.%,r-x)(%.licence,---)' proj</TT></FONT><FONT SIZE=5><BR>qui donne sur le fichier </FONT><FONT SIZE=5><TT>proj</TT></FONT><FONT SIZE=5> les droits de lecture et d'écriture à l'utilisateur </FONT><FONT SIZE=5><TT>dr</TT></FONT><FONT SIZE=5> du groupe </FONT><FONT SIZE=5><TT>staff</TT></FONT><FONT SIZE=5> et à l'utilisateur </FONT><FONT SIZE=5><TT>zipstein</TT></FONT><FONT SIZE=5> quelque soit son groupe et qui refuse cet accès aux utilisateurs du groupe </FONT><FONT SIZE=5><TT>licence</TT></FONT><FONT SIZE=5>.<BR></FONT><FONT SIZE=5><TT>chacl '(binome.%,rwx)(%.@,--x)(%.%,---)' catalogue_projet</TT></FONT><FONT SIZE=5><BR>qui donne le droit d'accès total à l'utilisateur </FONT><FONT SIZE=5><TT>binome</TT></FONT><FONT SIZE=5> (quelque soit son groupe), permet le parcours du répertoire aux membres du groupe propriétaire et refuse l'accès à tous les autres utilisateurs.<BR>Deux symboles spéciaux&nbsp;:
</FONT><DL COMPACT=compact>
<DT><FONT SIZE=5>
</FONT><FONT SIZE=5><TT>%</TT></FONT><DD><FONT SIZE=5> pour n'importe qui (utilisateur ou groupe)
</FONT>
<DT><FONT SIZE=5><TT>@</TT></FONT><DD><FONT SIZE=5> pour le propriétaire ou le groupe propriétaire
</FONT></DL><FONT SIZE=5>On retrouve aussi les autres syntaxes de </FONT><FONT SIZE=5><TT>chmod</TT></FONT><FONT SIZE=5> par exemple&nbsp;:<BR></FONT><FONT SIZE=5><TT>chacl %.%=r fichier</TT></FONT><FONT SIZE=5> <BR>ou<BR></FONT><FONT SIZE=5><TT>chacl @.%=5 fichier</TT></FONT><BR>
<BR>
<FONT SIZE=5>
<BR>
<BR>
</FONT><FONT SIZE=5><B>Attention</B></FONT><FONT SIZE=5> les acl sont détruits par la commande </FONT><FONT SIZE=5><TT>chmod</TT></FONT><FONT SIZE=5> et
la commande </FONT><FONT SIZE=5><TT>chacl</TT></FONT><FONT SIZE=5> ne permet pas de positioner les autres bits
définis dans l'inode&nbsp;; seuls les 9 bits de protections sont
positionnables par </FONT><FONT SIZE=5><TT>chacl</TT></FONT><FONT SIZE=5>.<BR>
<BR>
Pour positionner les droits standard et des acl, il faut donc réaliser en
succession un </FONT><FONT SIZE=5><TT>chmod</TT></FONT><FONT SIZE=5> puis un </FONT><FONT SIZE=5><TT>chacl</TT></FONT><FONT SIZE=5>. <BR>
<BR>
On utilisera&nbsp;:<BR></FONT><FONT SIZE=5><TT>chacl '(prof.%,rwx)' catalogue_projet</TT></FONT><FONT SIZE=5><BR>pour les projets de C ou de système.<BR>
<BR>
La commande </FONT><FONT SIZE=5><TT>lsacl [fichiers]</TT></FONT><FONT SIZE=5> permet de connaître les acl associés aux
fichiers, remarquer qu'à l'inverse de </FONT><FONT SIZE=5><TT>/bin/ls </TT></FONT><FONT SIZE=5> cette commande n'a pas de
paramètres par défaut.<BR>
<BR>
</FONT><!--TOC subsection <FONT SIZE=5>Appels systemes </FONT><FONT SIZE=5><TT>setacl</TT></FONT><FONT SIZE=5> et </FONT><FONT SIZE=5><TT>getacl</TT></FONT>-->

<H3><FONT SIZE=5>17.6.1&nbsp;&nbsp; Appels systemes </FONT><FONT SIZE=5><TT>setacl</TT></FONT><FONT SIZE=5> et </FONT><FONT SIZE=5><TT>getacl</TT></FONT></H3><!--SEC END -->
<FONT SIZE=5>On trouvera deux appels systèmes correspondant&nbsp;:
</FONT><FONT SIZE=5><TT><BR>     #include &lt;sys/acl.h&gt;<BR><BR>     int setacl(<BR>          const char *path,<BR>          size_t nentries,<BR>          const struct acl_entry *acl<BR>     );<BR><BR>     int fsetacl(<BR>          int fildes,<BR>          size_t nentries,<BR>          const struct acl_entry *acl<BR>     );<BR></TT></FONT><BR>
<BR>
<FONT SIZE=5>Un bon exercice &nbsp;: récrire </FONT><FONT SIZE=5><TT>lsacl</TT></FONT><FONT SIZE=5> de façon qu'il fonctionne d'une manière
similaire à </FONT><FONT SIZE=5><TT>/bin/ls</TT></FONT><FONT SIZE=5>.<BR>
<BR>
Utilisation de la commande script pour montrer le comportement des acl.
</FONT><PRE><FONT SIZE=5><TT>
Script started on Fri May  5 10:33:20 1995
$ lsacl *
(dr.%,rw-)(%.staff,---)(%.%,---) fich
(dr.%,rw-)(%.staff,---)(%.%,---) file
(dr.%,rwx)(%.staff,---)(%.%,---) projet
$ chacl  '(prof.%,rwx)' fich
$ lsacl *
(prof.%,rwx)(dr.%,rw-)(%.staff,---)(%.%,---) fich
(dr.%,rw-)(%.staff,---)(%.%,---) file
(dr.%,rwx)(%.staff,---)(%.%,---) projet
$ chacl '(%.staff,rx)' fich
$ lsacl *
(prof.%,rwx)(dr.%,rw-)(%.staff,r-x)(%.%,---) fich
(dr.%,rw-)(%.staff,---)(%.%,---) file
(dr.%,rwx)(%.staff,---)(%.%,---) projet
$ chacl '(illouz.staff=' fich
$ lsacl fich
(illouz.staff,---)(prof.%,rwx)(dr.%,rw-)(%.staff,r-x)(%.%,---) fich
$ chacl '(prof.%,rx)' . ..
$ su prof
Password:
$ cat fich
$ touch fich
$ chacl '(dr.staff,x)' fich
chacl: file "fich": Not owner (errno = 1)
$ lsacl *
(illouz.staff,---)(prof.%,rwx)(dr.%,rw-)(%.staff,r-x)(%.%,---) fich
(dr.%,rw-)(%.staff,---)(%.%,---) file
(dr.%,rwx)(%.staff,---)(%.%,---) projet
$ exit # du su
$ exit # du script

script done on Fri May  5 10:37:18 1995
</TT></FONT></PRE><FONT SIZE=5>
</FONT><!--TOC chapter <FONT SIZE=5>Multiplexer des entrées-sorties</FONT>-->

<H1><FONT SIZE=5>Chapitre&nbsp;18&nbsp;&nbsp; Multiplexer des entrées-sorties</FONT></H1><!--SEC END -->
<FONT SIZE=5>Dans ce chapitre, nous voulons présenter le problème des attentes actives sur plusieurs descripteurs.
Prenons par exemple un cas pratique assez fréquent d'un processus qui doit réaliser une communication entre deux autres, typiquement un gestionnaire de modem qui doit d'une part recevoir des informations d'un processus utilisateur, d'autre part recevoir des informations venant du modem.<BR>
<BR>
Ce qui nous donne la figure </FONT><A HREF="#modem"><FONT SIZE=5>18.1</FONT></A><FONT SIZE=5>.

</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML071.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 18.1&nbsp;: Un gestionaire de modem</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="modem"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>
Mais ce processus doit donc passer son temps à scruter les deux descripteurs &nbsp;: celui qui lui permet de savoir ce que l'utilisateur tape et celui qui lui permet de lire les informations venant de la ligne.<BR>
<BR>

<BR>
<BR>
</FONT><!--TOC subsection <FONT SIZE=5>Résolution avec deux processus</FONT>-->

<H3><FONT SIZE=5>18.0.2&nbsp;&nbsp; Résolution avec deux processus</FONT></H3><!--SEC END -->
<FONT SIZE=5>
Une façon de résoudre le problème est de créer deux processus &nbsp;: un pour
chaque direction de la communication (figure </FONT><A HREF="#modem2"><FONT SIZE=5>18.2</FONT></A><FONT SIZE=5>).<BR>
<BR>

</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML072.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 18.2&nbsp;: Un gestionaire de modem avec deux processus</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="modem2"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>
Mais dans ce cas, nous devons gérer des problèmes de terminaison de processus. Quand le père est tué avant le fils, nous devons alors utiliser un signal pour que le père dise au fils de se terminer, etc, et ceci sans réaliser une solution réellement propre.<BR>
<BR>
</FONT><!--TOC subsection <FONT SIZE=5>Solution avec le mode non bloquant</FONT>-->

<H3><FONT SIZE=5>18.0.3&nbsp;&nbsp; Solution avec le mode non bloquant</FONT></H3><!--SEC END -->
<FONT SIZE=5>On peut aussi utiliser des entrée-sorties non bloquantes.
 Auquel cas notre processus de gestion modem va réaliser sans interruption des appels </FONT><FONT SIZE=5><TT>read</TT></FONT><FONT SIZE=5> sur nos deux descripteurs.
 Le coût en ressources de cette attente active est extrêmement cher, et doit être évité dans le cas d'une machine en temps partagé.<BR>
<BR>
</FONT><!--TOC subsection <FONT SIZE=5>Utiliser les mécanismes asynchrones</FONT>-->

<H3><FONT SIZE=5>18.0.4&nbsp;&nbsp; Utiliser les mécanismes asynchrones</FONT></H3><!--SEC END -->
<FONT SIZE=5>
On peut utiliser des entrées-sorties asynchrones et demander au noyau de nous
prévenir par un signal qui informe de l'arrivée de données sur un descripteur.
Ce signal est soit </FONT><FONT SIZE=5><TT>SIGPOLL</TT></FONT><FONT SIZE=5>, soit </FONT><FONT SIZE=5><TT>SIGIO</TT></FONT><FONT SIZE=5>, mais ce n'est valable que
sur les descripteurs qui sont des périphériques. De plus ce mécanisme ne
désigne pas le descripteur sur lequel s'est faite l'arrivée de caractères, d'où
de nouvelles pertes de temps dûes aux appels réalisés inutilement en mode non bloquant.<BR>
<BR>
</FONT><!--TOC section <FONT SIZE=5>Les outils de sélection</FONT>-->

<H2><FONT SIZE=5>18.1&nbsp;&nbsp; Les outils de sélection</FONT></H2><!--SEC END -->
<FONT SIZE=5>La solution vient d'un système de sélection qui prend un paramètre un ensemble de descripteur,
 et peut tester si l'un de ses descripteurs est près à satisfaire un appel de </FONT><FONT SIZE=5><TT>read</TT></FONT><FONT SIZE=5>.
 Cet appel est bloquant jusqu'à l'arrivée de caractères sur un des descripteurs de l'ensemble.<BR>
<BR>
</FONT><!--TOC subsection <FONT SIZE=5>La primitive </FONT><FONT SIZE=5><TT>select</TT></FONT>-->

<H3><FONT SIZE=5>18.1.1&nbsp;&nbsp; La primitive </FONT><FONT SIZE=5><TT>select</TT></FONT></H3><!--SEC END -->
<FONT SIZE=5>Nous fournissont à la primitive </FONT><FONT SIZE=5><TT>select</TT></FONT><FONT SIZE=5>&nbsp;:
</FONT><UL>
<LI><FONT SIZE=5>
 </FONT><FONT SIZE=5> Les descripteurs que nous voulons scruter.
 </FONT>
<LI><FONT SIZE=5> Les conditions de réveil sur chaque descripteur (en attente de
 lecture, écriture, évènement ?)
</FONT>
<LI><FONT SIZE=5> Combien de temps nous voulons attendre.
</FONT></UL><FONT SIZE=5>La fonction retourne pour chaque descripteur s'il est prêt en
lecture, écriture, ou si l'évènement a eu lieu, et aussi le nombre de descripteur prêts.
Cette information nous permet ensuite d'appeler </FONT><FONT SIZE=5><TT>read</TT></FONT><FONT SIZE=5> ou </FONT><FONT SIZE=5><TT>write</TT></FONT><FONT SIZE=5> sur le(s) bon(s) descripteur(s). <BR>
<BR>
</FONT><PRE><FONT SIZE=5><TT>
#include  &lt;sys/types.h&gt;
#include  &lt;sys/time.h&gt;
#include  &lt;unistd.h&gt;

int select(int maxfd,
           fd_set *readfds,
           fd_set *writefds,
           fd_set *exceptfds
           struct timeval *delai);
</TT></FONT></PRE><FONT SIZE=5>Retourne le nombre de descripteurs prêts, 0 en cas d'expiration du délai.<BR>
<BR>
<BR>
Paramétrage du délai&nbsp;:
</FONT><PRE><FONT SIZE=5><TT>
struct timeval {
    long tv_sec;
    long tv_usec;
};
</TT></FONT></PRE><FONT SIZE=5>
</FONT><DL COMPACT=compact>
<DT><FONT SIZE=5>
</FONT><FONT SIZE=5><TT>delai == NULL</TT></FONT><DD><FONT SIZE=5> Bloquant, attente infinie
</FONT>
<DT><FONT SIZE=5><TT>delai-&gt;tv_sec == 0 &amp;&amp; delai-&gt;tv_usec == 0 </TT></FONT><DD><FONT SIZE=5> Non bloquant, retour immédiat.
</FONT>
<DT><FONT SIZE=5><TT>delai-&gt;tv_sec </TT></FONT><FONT SIZE=5><TT>&gt;</TT></FONT><FONT SIZE=5><TT> 0 &amp;&amp; delai-&gt;tv_usec </TT></FONT><FONT SIZE=5><TT>&gt;</TT></FONT><FONT SIZE=5><TT>0 </TT></FONT><DD><FONT SIZE=5> Semi
 bloquant, attente jusqu'à ce qu'un descripteur soit prêt ou que
 le délai en secondes plus microsecondes soit écoulé.</FONT></DL><FONT SIZE=5>Les trois pointeurs (</FONT><FONT SIZE=5><TT>readfds</TT></FONT><FONT SIZE=5>, </FONT><FONT SIZE=5><TT>writefds</TT></FONT><FONT SIZE=5>, et </FONT><FONT SIZE=5><TT>exceptfds</TT></FONT><FONT SIZE=5>)
sur des ensembles de descripteurs sont utilisés pour indiquer en
entrée les situations qui nous intéressent. C'est à priori (cela peut
varier avec l'implémentation) des tableaux de bits avec un bit pour
chaque descripteur du tableau de descripteurs du processus. L'entier
</FONT><FONT SIZE=5><TT>maxfd</TT></FONT><FONT SIZE=5> est la position du dernier bit significatif de ce tableau de bits.<BR>
<BR>
Les seules façons de manipuler ces ensembles de descripteurs sont&nbsp;:
</FONT><UL>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5> Création
</FONT>
<LI><FONT SIZE=5> Affectation
</FONT>
<LI><FONT SIZE=5> Utilisation d'une des quatre macros suivantes&nbsp;:
</FONT></UL><FONT SIZE=5>
</FONT><BLOCKQUOTE><FONT SIZE=5>
</FONT><DL COMPACT=compact>
<DT><FONT SIZE=5>
</FONT><FONT SIZE=5><TT>FD_ZERO(fd_set fdset)</TT></FONT><DD><FONT SIZE=5> RAZ de l'ensemble.
</FONT>
<DT><FONT SIZE=5><TT>FD_SET(int fd, fd_set *fdset)</TT></FONT><DD><FONT SIZE=5> Positionne le bit fd a 1.
</FONT>
<DT><FONT SIZE=5><TT>FD_CLR(int fd, fd_set *fdset)</TT></FONT><DD><FONT SIZE=5> Positionne le bit fd à 0
</FONT>
<DT><FONT SIZE=5><TT>FD_ISSET(int fd, fd_set *fdset)</TT></FONT><DD><FONT SIZE=5> vrai si le bit fd est à 1 dans l'ensemble.
</FONT></DL><FONT SIZE=5>
</FONT></BLOCKQUOTE><FONT SIZE=5>Un descripteur est considéré comme prêt en lecture si un appel </FONT><FONT SIZE=5><TT>read</TT></FONT><FONT SIZE=5> dessus ne sera
pas bloquant. De même, un descripteur est considéré comme prêt en écriture si un appel </FONT><FONT SIZE=5><TT>write</TT></FONT><FONT SIZE=5> ne sera pas bloquant. Les exceptions / évènements sont définis pour les
lignes de communication qui acceptent les </FONT><FONT SIZE=5><I>messages hors bande</I></FONT><FONT SIZE=5> comme les
</FONT><FONT SIZE=5><TT>sockets</TT></FONT><FONT SIZE=5> en mode datagramme.<BR>
<BR>
</FONT><!--TOC subsection <FONT SIZE=5>La primitive </FONT><FONT SIZE=5><TT>poll</TT></FONT>-->

<H3><FONT SIZE=5>18.1.2&nbsp;&nbsp; La primitive </FONT><FONT SIZE=5><TT>poll</TT></FONT></H3><!--SEC END -->
<FONT SIZE=5>La primitive </FONT><FONT SIZE=5><TT>poll</TT></FONT><FONT SIZE=5> fournit un service proche de </FONT><FONT SIZE=5><TT>select</TT></FONT><FONT SIZE=5> avec une autre forme d'interface.<BR>
<BR>
</FONT><PRE><FONT SIZE=5><TT>
#include &lt;stropts.h&gt;
#include &lt;poll.h&gt;
int poll(struct pollfd fdarray[],
         unsigned long nfds,
         int           timeout
  );

struct pollfd {
        int   fd;
        short events;
        short revents;
};
</TT></FONT></PRE><FONT SIZE=5>Ici on spécifie la liste de descripteurs et ce que l'on veut sur chacun d'eux.<BR>
<BR>
La valeur de retour est -1 en cas d'erreur, 0 si le temps d'attente </FONT><FONT SIZE=5><TT>timeout </TT></FONT><FONT SIZE=5> est écoulé, ou un entier positif indiquant le nombre de
descripteurs pour lesquels </FONT><FONT SIZE=5><TT>poll</TT></FONT><FONT SIZE=5> a changé la valeur du champ </FONT><FONT SIZE=5><TT>revents</TT></FONT><FONT SIZE=5>.<BR>
<BR>

<BR>
<BR>
Les évènements sont ici&nbsp;:<BR>Pour les évènements de </FONT><FONT SIZE=5><TT>events</TT></FONT><FONT SIZE=5>&nbsp;:
</FONT><DL COMPACT=compact>
<DT><FONT SIZE=5>
</FONT><FONT SIZE=5>POLLIN</FONT><DD><FONT SIZE=5> Données non prioritaire peuvent être lues.
</FONT>
<DT><FONT SIZE=5>POLLRDNORM</FONT><DD><FONT SIZE=5> idem.
</FONT>
<DT><FONT SIZE=5>POLLRDBAND</FONT><DD><FONT SIZE=5> Données non prioritaire non normales peuvent être lues.
</FONT>
<DT><FONT SIZE=5>POLLPRI</FONT><DD><FONT SIZE=5> Données prioritaire peuvent être lues.</FONT><BR>
<BR>

<DT><FONT SIZE=5>POLLOUT</FONT><DD><FONT SIZE=5> Données non prioritaire peuvent être écrites, les messages de
 haute priorité peuvent toujours êtres écrits.
</FONT>
<DT><FONT SIZE=5>POLLWRNORM</FONT><DD><FONT SIZE=5> idem
</FONT>
<DT><FONT SIZE=5>POLLWRBAND</FONT><DD><FONT SIZE=5> Données non prioritaire non normales peuvent être écrites sans bloquer.
</FONT></DL><FONT SIZE=5>Pour les </FONT><FONT SIZE=5><TT>revents</TT></FONT><FONT SIZE=5> (valeurs de retour de la primitive </FONT><FONT SIZE=5><TT>poll</TT></FONT><FONT SIZE=5>)&nbsp;:<BR>
<BR>
</FONT><DL COMPACT=compact>
<DT><FONT SIZE=5>
</FONT><FONT SIZE=5>POLLIN,POLLRDNORM,POLLRDBAND,POLLPRI</FONT><DD><FONT SIZE=5> les données sont là.
</FONT>
<DT><FONT SIZE=5>POLLOUT,POLLWRNORM, POLLWRBAND</FONT><DD><FONT SIZE=5> l'écriture est possible</FONT><BR>
<BR>

<DT><FONT SIZE=5>POLLERR</FONT><DD><FONT SIZE=5> Une erreur a eu lieu.
</FONT>
<DT><FONT SIZE=5>POLLHUP</FONT><DD><FONT SIZE=5> La ligne a été coupée.
</FONT>
<DT><FONT SIZE=5>POLLNVAL</FONT><DD><FONT SIZE=5> Descripteur invalide.</FONT></DL><FONT SIZE=5>Le mode de blocage de la primitive </FONT><FONT SIZE=5><TT>poll</TT></FONT><FONT SIZE=5> dépend du paramètre </FONT><FONT SIZE=5><TT>timeout</TT></FONT><FONT SIZE=5>
</FONT><DL COMPACT=compact>
<DT><FONT SIZE=5>
</FONT><FONT SIZE=5>timeout == INFTIM</FONT><DD><FONT SIZE=5> Bloquant, INFTIM est défini dans </FONT><CODE><FONT SIZE=5><TT>stropts.h</TT></FONT></CODE><FONT SIZE=5>.
</FONT>
<DT><FONT SIZE=5>timeout == 0</FONT><DD><FONT SIZE=5> Non bloquant.
</FONT>
<DT><FONT SIZE=5>timeout </FONT><FONT SIZE=5>&gt;</FONT><FONT SIZE=5> 0</FONT><DD><FONT SIZE=5> Semi bloquant, attente de </FONT><FONT SIZE=5><TT>timeout</TT></FONT><FONT SIZE=5> micro secondes.
</FONT></DL><FONT SIZE=5>
</FONT><FONT SIZE=5><B>Un Exemple </B></FONT><FONT SIZE=5>
 Attente de données sur ifd1 et ifd2, de place pour écrire sur ofd, avec un
 délai maximum de 10 seconds&nbsp;:<BR></FONT><FONT SIZE=5><TT>  #include &lt;poll.h&gt;<BR>  struct pollfd fds[3];<BR>  int ifd1, ifd2, ofd, count;<BR><BR>  fds[0].fd = ifd1;<BR>  fds[0].events = POLLNORM;<BR>  fds[1].fd = ifd2;<BR>  fds[1].events = POLLNORM;<BR>  fds[2].fd = ofd;<BR>  fds[2].events = POLLOUT;<BR>  count = poll(fds, 3, 10000);<BR>   if (count == -1) {<BR>          perror("poll failed");<BR>           exit(1);<BR>   }<BR>   if (count==0)<BR>         printf("Rien \n");<BR>   if (fds[0].revents &amp; POLLNORM)<BR>         printf("Données a lire sur ifd%d\n", fds[0].fd);<BR>   if (fds[1].revents &amp; POLLNORM)<BR>         printf("Données a lire sur ifd%d\n", fds[1].fd);<BR>   if (fds[2].revents &amp; POLLOUT)<BR>         printf("De la place sur fd%d\n", fds[2].fd);
</TT></FONT><FONT SIZE=5>

</FONT><!--TOC subsection <FONT SIZE=5>Les extensions de </FONT><FONT SIZE=5><TT>read</TT></FONT><FONT SIZE=5> et </FONT><FONT SIZE=5><TT>write</TT></FONT>-->

<H3><FONT SIZE=5>18.1.3&nbsp;&nbsp; Les extensions de </FONT><FONT SIZE=5><TT>read</TT></FONT><FONT SIZE=5> et </FONT><FONT SIZE=5><TT>write</TT></FONT></H3><!--SEC END -->
<FONT SIZE=5>Une extension </FONT><FONT SIZE=5><TT>readv, writev</TT></FONT><FONT SIZE=5> de </FONT><FONT SIZE=5><TT>read</TT></FONT><FONT SIZE=5> et </FONT><FONT SIZE=5><TT>write</TT></FONT><FONT SIZE=5> permet en un
seul appel système de réaliser l'écriture de plusieurs zones mémoire non
contiguës, ce qui permet d'accélerer certaines entrées-sorties structurées.
Mais aussi de mieux organiser les appels système dans notre cas.
</FONT><PRE><FONT SIZE=5><TT>
#include &lt;sys/types.h&gt;
#include &lt;sys/uio.h&gt;

ssize_t readv(int fd, const struct iovec iov[], int iovl);
ssize_t writev(int fd, const struct iovec iov[], int iovl);

struct iovec {
    void *iov_base ;
    int   iov_len;
};
</TT></FONT></PRE><!--TOC section <FONT SIZE=5>une solution multi-activités</FONT>-->

<H2><FONT SIZE=5>18.2&nbsp;&nbsp; une solution multi-activités</FONT></H2><!--SEC END -->
<FONT SIZE=5>L'utilisation de plusieurs activités (threads, voir chapitre </FONT><A HREF="#threads"><FONT SIZE=5>19</FONT></A><FONT SIZE=5>)
permet de réaliser plusieurs appels de </FONT><FONT SIZE=5><TT>read</TT></FONT><FONT SIZE=5> en simultané, le premier
</FONT><FONT SIZE=5><TT>read</TT></FONT><FONT SIZE=5> qui se débloque entraine l'exécution de l'activité le réalisant,
ainsi le coût est minimal. Le seul problème est d'avoir a gérer cette
multiplicité d'activités, ce qui est dans le cas de notre modem assez facile car
les deux activités sont indépendantes (communication Full Duplex).<BR>
<BR>
Pour une situation plus complexe comme un serveur de partage de données, des
mécanismes d'exclusion mutuelle entre activités devront être mis en oeuvre.

</FONT><!--TOC chapter <FONT SIZE=5>Les micro-noyaux</FONT>-->

<H1><FONT SIZE=5>Chapitre&nbsp;19&nbsp;&nbsp; Les micro-noyaux</FONT></H1><!--SEC END -->
<A NAME="threads"></A><FONT SIZE=5>Le principe des micro-noyaux, fortement inspiré de l'approche objet, consiste à
découper le bloc monolithique qu'est le système d'exploitation, en un ensemble
cohérent de modules, qui constituent autant de services spécialisés sur
lesquels il suffira de "brancher" des interfaces. Ces micro-noyaux sont en
général interfacés avec un ensemble d'appels système de type unix ce qui permet
de réutiliser des applications comme par exemple les shells.<BR>
<BR>
Ce qui distingue les systèmes à micro-noyaux des systèmes classiques est la structure en modules logiciels indépendants, appelés modules systèmes. Chacun d'eux est spécialiste d'un fonctionnement de base du système d'exploitation&nbsp;:
</FONT><UL>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5> gestion des processus (exécution, scheduling)
</FONT>
<LI><FONT SIZE=5> gestion de la mémoire (mémoire virtuelle)
</FONT>
<LI><FONT SIZE=5> gestion des entrées/sorties
</FONT>
<LI><FONT SIZE=5> gestion des messages (IPC)
</FONT></UL><FONT SIZE=5>Au-dessus de ces modules se trouve l'interface de programmation qui est elle aussi indépendante et donc théoriquement interchangeable (en général une interface unix-posix).<BR>
<BR>
Sous ces modules, on trouve le micro-noyau qui en général se limite à la gestion des IPC entre modules comme par exemple MACH.<BR>
<BR>
Quelques systèmes à micro-noyau&nbsp;:</FONT><FONT SIZE=5><B> MACH, CHORUS</B></FONT><BR>
<BR>
<FONT SIZE=5>
</FONT><!--TOC subsection <FONT SIZE=5>Les atouts des micro-noyaux</FONT>-->

<H3><FONT SIZE=5>19.0.1&nbsp;&nbsp; Les atouts des micro-noyaux</FONT></H3><!--SEC END -->
<FONT SIZE=5>Les différents modules du système étant définis au niveau "utilisateur" et pas
dans le noyau, il est donc plus facile de les "debugger", de les améliorer etc ...
(ceci n'est pas toujours vrai en pratique). Seul le micro-noyau lui-même nécessite des debuggeurs spéciaux.<BR>
<BR>
La configuration du système se trouve simplifiée car elle ne demande plus de recompiler le noyau, à chaque ajout ou retrait de fonctionnalités dans le système : Oracle, modem, type disques différents etc.<BR>
<BR>
C'est l'avenir.<BR>
<BR>
C'est mieux adapté aux machines multi-processeurs, aux réseaux.<BR>
<BR>
</FONT><!--TOC subsection <FONT SIZE=5>Quelques problèmes</FONT>-->

<H3><FONT SIZE=5>19.0.2&nbsp;&nbsp; Quelques problèmes</FONT></H3><!--SEC END -->
<FONT SIZE=5> Un système plus lent, qui utilise en proportion beaucoup plus de mémoire pour
lui mais aussi pour tous les services qu'il rend. <BR>
<BR>


</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML073.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 19.1&nbsp;: Plusieurs modules système qui utilisent un noyau réduit</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="micro-noyaux"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>


</FONT><!--TOC section <FONT SIZE=5>Le système MACH (Carnegie Mellon University CMU)</FONT>-->

<H2><FONT SIZE=5>19.1&nbsp;&nbsp; Le système MACH (Carnegie Mellon University CMU)</FONT></H2><!--SEC END -->
<FONT SIZE=5>Le système Mach est donc un système avec un micro-noyau orienté communication.<BR>
<BR>
Le système fournit les services suivants :
</FONT><UL>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5> Tâches multiples
</FONT>
<LI><FONT SIZE=5> Threads multiples dans chaque tâche (avec scheduling).
</FONT>
<LI><FONT SIZE=5> Partage flexible de mémoire entre tâches
</FONT>
<LI><FONT SIZE=5> Un système de communication inter-processus par files de messages efficace et sécurisé
</FONT>
<LI><FONT SIZE=5> La projection de fichiers en mémoire
</FONT>
<LI><FONT SIZE=5> Le noyau lui-même ne fournit que les éléments les plus essentiels, c'est-à-dire 
scheduling
IPC
gestion de la mémoire virtuelle
</FONT></UL><FONT SIZE=5>Tous ces services et les autres sont fournis à travers l'utilisation d'un seul type d'IPC (les messages).

</FONT><!--TOC section <FONT SIZE=5>Le noyau MACH</FONT>-->

<H2><FONT SIZE=5>19.2&nbsp;&nbsp; Le noyau MACH</FONT></H2><!--SEC END -->
<FONT SIZE=5>En pratique, le noyau ne fournit que les services nécessaires à l'implémentation
d'un système de communication entre différents processus utilisateurs (les
modules système par exemple).<BR>
<BR>
Pour cela, le noyau fournit un certain nombre d'abstractions utilisables par le niveau module ou utilisateur.
En particulier 
</FONT><UL>
<LI><FONT SIZE=5>
 </FONT><FONT SIZE=5> Tasks (tâches)
 </FONT>
<LI><FONT SIZE=5> Threads 
 </FONT>
<LI><FONT SIZE=5> Ports
 </FONT>
<LI><FONT SIZE=5> Messages
</FONT></UL><FONT SIZE=5>Les fonctions du noyaux sont donc 
</FONT><UL>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5> création et gestion des tâches et threads 
</FONT>
<LI><FONT SIZE=5> gestion des ports
</FONT>
<LI><FONT SIZE=5> manipulations de base des messages
</FONT>
<LI><FONT SIZE=5> gestion de la mémoire virtuelle
</FONT>
<LI><FONT SIZE=5> scheduling
</FONT></UL><FONT SIZE=5>
</FONT><!--TOC subsection <FONT SIZE=5>Les Tâches et les Threads </FONT>-->

<H3><FONT SIZE=5>19.2.1&nbsp;&nbsp; Les Tâches et les Threads </FONT></H3><!--SEC END -->
<FONT SIZE=5> Dans les systèmes UNIX classiques, une abstraction fondamentale a été définie &nbsp;: le processus. Cette abstraction recouvre à la fois un ensemble de ressources (essentiellement de l'espace d'adressage, mais aussi fichiers ouverts et autres) et une unité d'exécution unique, une seule activité.<BR>
<BR>
 On trouve dans les processus d'une part un programme que le processus exécute et un ensemble de données que le programme manipule (décomposé en données et pile). Historiquement, la notion de réentrance a apporté la possibilité de faire partager la zone programme à plusieurs processus, chacun ayant une zone de données différente. <BR>
<BR>
 Cette abstraction montre ses limites avec l'arrivée des machines multi-processus et l'architecture logicielle clients/serveurs dans laquelle un serveur se démultiplie pour servir les différents clients.<BR>
<BR>
Pour répondre à cette demande, une première approche a été de séparer les deux composantes essentielles du processus,
 c'est-à-dire d'une part les ressources physiques, d'autre part les activités (unités d'exécution) sur ces ressources (light process de SUN).
 Cette idée a fait son chemin et l'on parle d'environnement d'exécution pour les ressources partagées --- ce sont les tâches (tasks MACH) --- et l'on parle d'activités (threads of control).<BR>
<BR>

Sous MACH
</FONT><UL>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5> une tâche est un environnement d'exécution, c'est l'unité de base de protection pour l'allocation des ressources (c'est la tâche qui est propriétaire des ressources). Elle comporte un espace d'adressage (4 Go) et des droits d'accès protégés à certains ports.
</FONT>
<LI><FONT SIZE=5> Une thread est l'unité d'exécution de base. C'est un processus (une activité) qui s'exécute dans la tâche (et uniquement dans la tâche). Elle est constituée essentiellement d'un sous-ensemble du P.C.B. (Processus Control Block d'UNIX) : les registres, une position dans la pile, un segment de pile propre, un pointeur dans le programme.
</FONT></UL><FONT SIZE=5>
Une thread donnée ne s'exécute que dans une tâche donnée, mais une tâche peut avoir plusieurs threads.
Toutes les threads partagent les ressources de la tâche.
Comme la tâche est l'unité de protection, les threads ne sont pas protégées les unes des autres !!<BR>
<BR>
Les tâches sont schedulées comme les processus UNIX.<BR>
<BR>
A l'intérieur d'une tâche, les différentes threads sont par défaut schedulées aléatoirement (même priorité).
Une thread ne s'exécute que si elle et sa tâche sont exécutables.<BR>
<BR>

</FONT><!--TOC subsection <FONT SIZE=5>Ports &amp; Messages</FONT>-->

<H3><FONT SIZE=5>19.2.2&nbsp;&nbsp; Ports &amp; Messages</FONT></H3><!--SEC END -->
<FONT SIZE=5>Toutes les communications entre les différents modules (et objets) du système sont réalisées par des messages !<BR>
<BR>
Trois abstractions sont utilisées pour implémenter et manipuler le système de messages:
</FONT><UL>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5> ports
</FONT>
<LI><FONT SIZE=5> ports set (ensembles de ports)
</FONT>
<LI><FONT SIZE=5> messages
</FONT></UL><FONT SIZE=5>Un port est un canal de communication protégé (implémenté par une file de messages finie), sur lequel des messages peuvent être envoyés et qui sont placés dans la file à la réception.
C'est aussi sous MACH l'unité de référence des objets : tout objet n'est connu que par son port. Toute opération du système consiste à envoyer des messages vers le port d'un objet. Ainsi quand une tâche est crée, le port associé est crée simultanément, quand une tâche est détruite son port est aussi détruit.<BR>
<BR>
Un port set (ensemble de ports) est une file contenant les différentes files des ports de l'ensemble. Une thread peut grâce à ces ensembles de ports attendre un message sur différents ports en même temps.<BR>
<BR>

Un message est une unité de communication entre objets &nbsp;: un message est envoyé au port qui représente l'objet. Un message est une unité de données constituée de deux parties &nbsp;: un header de taille fixe et le corps des données composé de zéro ou plusieurs objets typés (données typées).<BR>
<BR>
Le header décrit la taille, le type et la destination du message.
Le corps contient le contenu ou un pointeur sur le contenu du message.<BR>
<BR>
Il n'y a pas de limite ni sur la taille ni sur le contenu des messages.<BR>
<BR>
A l'inverse des files de message des IPC standard d'UNIX, il est possible d'échanger des pointeurs entre tâches.
Les conversions d'adressages entre les mémoires virtuelles des différentes tâches étant réalisées automatiquement dans presque tous les cas &nbsp;: c'est un avantage indéniable, qui permet par exemple de réaliser un </FONT><FONT SIZE=5><TT>fork</TT></FONT><FONT SIZE=5> par un simple message contenant tout l'espace d'adressage de la tâche réalisant le </FONT><FONT SIZE=5><TT>fork</TT></FONT><FONT SIZE=5> !<BR>
<BR>
Le noyau ne manipule que des messages. Les seules interruptions bas niveau sont celles afférentes a la gestion des messages. Les autres sont réalisées par des envois de messages par le port de la tâche.<BR>
<BR>
Les threads peuvent utiliser les ports pour communiquer entre elles dans une même tâche, ou avec une autre tâche, et de plus, comme les ports sont "visibles" au niveau du réseau, on peut communiquer avec un objet sur une autre machine !<BR>
<BR>

</FONT><!--TOC subsection <FONT SIZE=5>Task Threads &amp; Ports</FONT>-->

<H3><FONT SIZE=5>19.2.3&nbsp;&nbsp; Task Threads &amp; Ports</FONT></H3><!--SEC END -->
<FONT SIZE=5>Les tâches et les Threads sont représentées par des ports (les ports sont des files de message identifiées).<BR>
<BR>
Le port de la tâche ou de la thread permet au système d'identifier quelle tâche ou thread doit être affectée par un appel système donné.<BR>
<BR>
[Sous UNIX, ce rôle d'identification est réalisé par la table des processus et le pid du processus.]<BR>
<BR>
</FONT><CODE><FONT SIZE=5><TT>task_self()</TT></FONT></CODE><FONT SIZE=5> et </FONT><CODE><FONT SIZE=5><TT>thread_self()</TT></FONT></CODE><FONT SIZE=5> retourne le port associé à la tâche, ou la thread qui exécute la primitive.<BR>
<BR>
Une tâche ou Thread peut avoir accès au port d'une autre (tâche ou thread) et peut réaliser des appels système pour ou avec cette autre tâche/thread.<BR>
<BR>

</FONT><!--TOC section <FONT SIZE=5>Les threads POSIX </FONT>-->

<H2><FONT SIZE=5>19.3&nbsp;&nbsp; Les threads POSIX </FONT></H2><!--SEC END -->
<FONT SIZE=5>
Organisation en mémoire pour un processus UNIX avec plusieurs threads &nbsp;: voir figure </FONT><A HREF="#micro-noyaux-pile"><FONT SIZE=5>19.2</FONT></A><FONT SIZE=5>.


</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML074.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 19.2&nbsp;: Organisation mémoire, partage des fonctions entre le processus et les activités</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="micro-noyaux-pile"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>

</FONT><!--TOC subsection <FONT SIZE=5><TT>fork</TT></FONT><FONT SIZE=5> et </FONT><FONT SIZE=5><TT>exec</TT></FONT>-->

<H3><FONT SIZE=5>19.3.1&nbsp;&nbsp; </FONT><FONT SIZE=5><TT>fork</TT></FONT><FONT SIZE=5> et </FONT><FONT SIZE=5><TT>exec</TT></FONT></H3><!--SEC END -->
<FONT SIZE=5>Après un </FONT><FONT SIZE=5><TT>fork</TT></FONT><FONT SIZE=5>, le fils ne contient qu'une seule activité (celle qui a exécuté le
</FONT><FONT SIZE=5><TT>fork</TT></FONT><FONT SIZE=5>). Attention aux variables d'exclusion mutuelle (qui font partie de l'espace
d'adressage partagé) qui sont conservées après le </FONT><FONT SIZE=5><TT>fork()</TT></FONT><FONT SIZE=5> et dont le contenu ne
varie pas. Ainsi si une activité a pris le sémaphore avant le </FONT><FONT SIZE=5><TT>fork()</TT></FONT><FONT SIZE=5>, si
l'activité principale cherche à prendre ce sémaphore après le </FONT><FONT SIZE=5><TT>fork()</TT></FONT><FONT SIZE=5> elle sera
indéfiniment bloquée.<BR>
<BR>
Après un </FONT><FONT SIZE=5><TT>exec</TT></FONT><FONT SIZE=5>, le processus ne contient plus que la thread qui a exécuté l'une
des six commandes </FONT><FONT SIZE=5><TT>exec</TT></FONT><FONT SIZE=5>. Pas de problème avec les sémaphores comme l'espace
d'adressage a changé.<BR>
<BR>

</FONT><!--TOC subsection <FONT SIZE=5>Les noms de fonctions</FONT>-->

<H3><FONT SIZE=5>19.3.2&nbsp;&nbsp; Les noms de fonctions</FONT></H3><!--SEC END -->
<PRE><FONT SIZE=5><TT>
pthread[_objet]_operation[_np]
</TT></FONT></PRE><FONT SIZE=5> où
</FONT><DL COMPACT=compact>
<DT><FONT SIZE=5>
</FONT><FONT SIZE=5>objet</FONT><DD><FONT SIZE=5> désigne si il est présent le type de l'objet auquel la fonction s'applique. Les valeurs possibles de objet peuvent être 
</FONT><FONT SIZE=5><TT>cond</TT></FONT><FONT SIZE=5> pour une variable de condition
</FONT><FONT SIZE=5><TT>mutex</TT></FONT><FONT SIZE=5> pour un sémaphore d'exclusion mutuelle
</FONT>
<DT><FONT SIZE=5>opération</FONT><DD><FONT SIZE=5> désigne l'opération a réaliser, par exemple </FONT><FONT SIZE=5><TT>create</TT></FONT><FONT SIZE=5>, </FONT><FONT SIZE=5><TT>exit</TT></FONT><FONT SIZE=5> ou </FONT><FONT SIZE=5><TT>init</TT></FONT><FONT SIZE=5>
</FONT></DL><FONT SIZE=5>le suffixe </FONT><FONT SIZE=5><TT>np</TT></FONT><FONT SIZE=5> indique, si il est présent, qu'il s'agit d'une fontion non portable, c'est-à-dire Hors Norme.<BR>
<BR>
</FONT><!--TOC subsection <FONT SIZE=5>les noms de types</FONT>-->

<H3><FONT SIZE=5>19.3.3&nbsp;&nbsp; les noms de types</FONT></H3><!--SEC END -->
<PRE><FONT SIZE=5><TT>
pthread[_objet]_t
</TT></FONT></PRE><FONT SIZE=5> avec </FONT><FONT SIZE=5><TT>objet</TT></FONT><FONT SIZE=5> prenant comme valeur </FONT><FONT SIZE=5><TT>cond</TT></FONT><FONT SIZE=5>, </FONT><FONT SIZE=5><TT>mutex</TT></FONT><FONT SIZE=5> ou rien pour une thread.<BR>
<BR>

</FONT><!--TOC subsection <FONT SIZE=5>Attributs d'une activité</FONT>-->

<H3><FONT SIZE=5>19.3.4&nbsp;&nbsp; Attributs d'une activité</FONT></H3><!--SEC END -->
<FONT SIZE=5>Identification d'une pthread &nbsp;: le TID de type pthread_t obtenu par un appel à la primitive&nbsp;:
</FONT><PRE><FONT SIZE=5><TT>
pthread_t pthread_self(void);
</TT></FONT></PRE><FONT SIZE=5> pour le processus propriétaire
</FONT><PRE><FONT SIZE=5><TT>
pid_t getpid(void);
</TT></FONT></PRE><FONT SIZE=5> Les différentes activités d'un processus sont numérotées à partir de 1.
Un processus UNIX standard a une seule activité de numéro 1.<BR>
<BR>
Pour tuer une activité donnée dans un processus donné, on utilisera la commande shell </FONT><FONT SIZE=5><TT>kill</TT></FONT><FONT SIZE=5> avec comme paramètre </FONT><FONT SIZE=5><TT>pid.tid</TT></FONT><FONT SIZE=5>.<BR>Exemple:<BR>kill -9 12345.3<BR>
<BR>
En POSIX, le fait de tuer la thread de numéro 1 a pour effet de tuer le processus ainsi que toutes les autres threads éventuelles du processus.<BR>
<BR>
Pour tester l'égalité de deux pthreads on utilise 
</FONT><PRE><FONT SIZE=5><TT>
int pthread_equal(pthread_t tid1, pthread_t tid2);
</TT></FONT></PRE><FONT SIZE=5> 
</FONT><!--TOC subsection <FONT SIZE=5>Création et terminaison des activités</FONT>-->

<H3><FONT SIZE=5>19.3.5&nbsp;&nbsp; Création et terminaison des activités</FONT></H3><!--SEC END -->
<!--TOC subsubsection <FONT SIZE=5>Création</FONT>-->

<H4><FONT SIZE=5> Création</FONT></H4><!--SEC END -->
<FONT SIZE=5>
</FONT><PRE><FONT SIZE=5><TT>
int pthread_create (pthread_t      *p_tid,
                    pthread_attr_t attr,
                    void           *(*fonction) (void *arg),
                    void           *arg
                   );
</TT></FONT></PRE><FONT SIZE=5> La création et l'activation d'une activité retourne -1 en cas d'echec, 0 sinon.
</FONT><UL>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5> le tid de la nouvelle thread est placé à l'adresse </FONT><CODE><FONT SIZE=5><TT>p_tid</TT></FONT></CODE><FONT SIZE=5>
</FONT>
<LI><FONT SIZE=5> </FONT><FONT SIZE=5><TT>attr</TT></FONT><FONT SIZE=5> attribut de l'activité (ordonnancement), utiliser </FONT><FONT SIZE=5><TT>pthread_attr_default</TT></FONT><FONT SIZE=5>
</FONT>
<LI><FONT SIZE=5> la paramètre </FONT><FONT SIZE=5><TT>fonction</TT></FONT><FONT SIZE=5> correspond à la fonction exécutée par l'activité après sa création : il s'agit donc de son point d'entrée (comme la fonction </FONT><FONT SIZE=5><TT>main</TT></FONT><FONT SIZE=5> pour les processus). Un retour de cette fonction correspondra à la terminaison de cette activité.
</FONT>
<LI><FONT SIZE=5> le paramètre </FONT><FONT SIZE=5><TT>arg</TT></FONT><FONT SIZE=5> est transmis à la fonction au lancement de l'activité.
</FONT></UL><FONT SIZE=5>
</FONT><!--TOC subsubsection <FONT SIZE=5>Terminaison</FONT>-->

<H4><FONT SIZE=5> Terminaison</FONT></H4><!--SEC END -->
<FONT SIZE=5>a) les appels UNIX </FONT><FONT SIZE=5><TT>exit</TT></FONT><FONT SIZE=5> et </FONT><FONT SIZE=5><TT>_exit</TT></FONT><FONT SIZE=5> terminent toutes les threads du processus.
<BR>
<BR>
b) Terminaison d'une thread<BR>
<BR>
</FONT><PRE><FONT SIZE=5><TT>
 int pthread_exit (int *p_status);
</TT></FONT></PRE><FONT SIZE=5> </FONT><FONT SIZE=5><TT>p_status</TT></FONT><FONT SIZE=5> code retour de la thread, comme dans les processus UNIX la thread est zombifiée pour attendre la lecture du code de retour par une autre thread. A l'inverse des processus, comme il peut y avoir plusieurs threads qui attendent, la thread zombie n'est pas libérée par la lecture du p_status, il faut pour cela utiliser une commande spéciale qui permettra de libérer effectivement l'espace mémoire utilisé par la thread.<BR>
<BR>
Cette destruction est explicitement demandée par la commande 
</FONT><PRE><FONT SIZE=5><TT>
int pthread_detach (pthread_t *p_tid);
</TT></FONT></PRE><FONT SIZE=5> Si un tel appel a lieu alors que l'activité est en cours d'exécution, cela indique seulement qu'à l'exécution de </FONT><CODE><FONT SIZE=5><TT>pthread_exit</TT></FONT></CODE><FONT SIZE=5> les ressources seront restituées.<BR>
<BR>

</FONT><!--TOC section <FONT SIZE=5>Synchronisation</FONT>-->

<H2><FONT SIZE=5>19.4&nbsp;&nbsp; Synchronisation</FONT></H2><!--SEC END -->
<FONT SIZE=5>Trois mécanismes de synchronisation inter-activités :
</FONT><UL>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5> la primitive </FONT><FONT SIZE=5><TT>join</TT></FONT><BR>
<BR>

<LI><FONT SIZE=5> les sémaphores d'exclusion mutuelle </FONT><BR>
<BR>

<LI><FONT SIZE=5> les conditions (évènements)
</FONT></UL><!--TOC subsection <FONT SIZE=5>Le modèle fork/join (Paterson)</FONT>-->

<H3><FONT SIZE=5>19.4.1&nbsp;&nbsp; Le modèle fork/join (Paterson)</FONT></H3><!--SEC END -->
<FONT SIZE=5>
Les rendez-vous : join <BR>
<BR>
La primitive
 </FONT><PRE><FONT SIZE=5><TT>
int pthread_join (pthread_t tid, int **status);
</TT></FONT></PRE><FONT SIZE=5> permet de suspendre l'exécution de l'activité courante jusqu'à ce que l'activité </FONT><FONT SIZE=5><TT>tid</TT></FONT><FONT SIZE=5> exécute un appel (implicite ou explicite) à </FONT><FONT SIZE=5><TT>pthread_exit</TT></FONT><FONT SIZE=5>.
Si l'activité </FONT><FONT SIZE=5><TT>tid</TT></FONT><FONT SIZE=5> est déjà terminée, le retour est immédiat, et le code de retour de l'activité visée est égal à **status (double indirection).<BR>
<BR>
La primitive retourne &nbsp;:<BR>0 en cas de succès<BR>-1 en cas d'erreur<BR>
<BR>
</FONT><DL COMPACT=compact>
<DT><FONT SIZE=5>
</FONT><FONT SIZE=5>EINVAL</FONT><DD><FONT SIZE=5> si le </FONT><FONT SIZE=5><TT>tid</TT></FONT><FONT SIZE=5> est incorrect
</FONT>
<DT><FONT SIZE=5>ESRCH</FONT><DD><FONT SIZE=5> activité inexistante
</FONT>
<DT><FONT SIZE=5>EDEADLOCK</FONT><DD><FONT SIZE=5> l'attente de l'activité spécifiée conduit à un interblocage.
</FONT></DL><FONT SIZE=5>
</FONT><!--TOC subsection <FONT SIZE=5>Le problème de l'exclusion mutuelle sur les variables gérées par le noyau</FONT>-->

<H3><FONT SIZE=5>19.4.2&nbsp;&nbsp; Le problème de l'exclusion mutuelle sur les variables gérées par le noyau</FONT></H3><!--SEC END -->
<FONT SIZE=5>Il est nécessaire d'avoir plusieurs variables </FONT><FONT SIZE=5><TT>errno</TT></FONT><FONT SIZE=5>, une par activité. En effet cette variable globale pourrait être changée par une autre activité. Voir plus loin comment définir des variables globales locales à chaque activité.<BR>
<BR>


</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML075.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 19.3&nbsp;: Changement de la valeur </FONT><FONT SIZE=5><TT>errno</TT></FONT><FONT SIZE=5> par une autre thread</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="threaderrno"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>


</FONT><!--TOC subsection <FONT SIZE=5>Les sémaphores d'exclusion mutuelle</FONT>-->

<H3><FONT SIZE=5>19.4.3&nbsp;&nbsp; Les sémaphores d'exclusion mutuelle</FONT></H3><!--SEC END -->
<FONT SIZE=5>Ces sémaphores binaires permettent d'assurer l'exclusion mutuelle.
</FONT><UL>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5> Il faut définir un objet de type </FONT><FONT SIZE=5><TT>pthread_mutex_t</TT></FONT><FONT SIZE=5> qui correspond à un ensemble d'attributs de type </FONT><FONT SIZE=5><TT>pthread_mutexattr_t</TT></FONT><FONT SIZE=5><BR>(on utilisera en général la constante </FONT><FONT SIZE=5><TT>pthread_mutexattr_default</TT></FONT><FONT SIZE=5> ).</FONT><BR>
<BR>

<LI><FONT SIZE=5> Initialiser la variable par un appel à la fonction 
</FONT><PRE><FONT SIZE=5><TT>
int pthread_mutex_init(pthread_mutex_t     *p_mutex,
                       pthread_mutexattr_t attr);
</TT></FONT></PRE><FONT SIZE=5> </FONT>
<LI><FONT SIZE=5> On pourra détruire le sémaphore par un appel à la fonction 
</FONT><PRE><FONT SIZE=5><TT>
int pthread_mutex_destroy(pthread_mutex_t *p_mutex);
</TT></FONT></PRE><FONT SIZE=5> </FONT></UL><FONT SIZE=5>
</FONT><!--TOC subsection <FONT SIZE=5>Utilisation des sémaphores</FONT>-->

<H3><FONT SIZE=5>19.4.4&nbsp;&nbsp; Utilisation des sémaphores</FONT></H3><!--SEC END -->
<FONT SIZE=5>Opération P &nbsp;:<BR>Un appel à la fonction 
</FONT><PRE><FONT SIZE=5><TT>
pthread_mutex_lock (pthread_mutex_t *pmutex);
</TT></FONT></PRE><FONT SIZE=5> permet à une activité de réaliser une opération P sur le sémaphore. Si le sémaphore est déjà utilisé, l'activité est bloquée jusqu'à la réalisation de l'opération V (par une autre activité) qui libèrera le sémaphore.<BR>
<BR>
Opération P non bloquante &nbsp;:
</FONT><PRE><FONT SIZE=5><TT>
pthread_mutex_trylock (pthread_mutex_t *pmutex);
</TT></FONT></PRE><FONT SIZE=5> renvoie 1 si le sémaphore est libre <BR>0 si le sémaphore est occupé par une autre activité<BR>-1 en cas d'erreur.<BR>Opération V &nbsp;:<BR>Un appel à la fonction 
</FONT><PRE><FONT SIZE=5><TT>
pthread_mutex_unlock(pthread_mutex_t *pmutex);
</TT></FONT></PRE><FONT SIZE=5> réalise la libération du sémaphore désigné.<BR>
<BR>

</FONT><!--TOC subsection <FONT SIZE=5>Les conditions (évènements)</FONT>-->

<H3><FONT SIZE=5>19.4.5&nbsp;&nbsp; Les conditions (évènements)</FONT></H3><!--SEC END -->
<FONT SIZE=5>Les conditions permettent de bloquer une activité sur une attente d'évènement. Pour cela l'activité doit posséder un sémaphore, l'activité peut alors libérer le sémaphore sur l'évènement, c'est-à-dire : elle libère le sémaphore, se bloque en attente de l'évènement, à la réception de l'évènement elle reprend le sémaphore.<BR>
<BR>
</FONT><FONT SIZE=5><B>Initialisation</B></FONT><FONT SIZE=5> d'une variable de type </FONT><CODE><FONT SIZE=5><TT>pthread_cond_t</TT></FONT></CODE><FONT SIZE=5> 
</FONT><PRE><FONT SIZE=5><TT>
int pthread_cond_init (pthread_cond_t *p_cond, pthread_condattr_t attr);
</TT></FONT></PRE><FONT SIZE=5> L'attente sur une condition 
</FONT><PRE><FONT SIZE=5><TT>
int pthread_cond_wait (pthread_cond_t *p_cond, pthread_mutex_t *p_mutex);
</TT></FONT></PRE><FONT SIZE=5> Trois étapes
</FONT><OL type=1>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5> libération sur sémaphore *p_mutex
</FONT>
<LI><FONT SIZE=5> activité mise en sommeil sur l'évènement
</FONT>
<LI><FONT SIZE=5> réception de l'évènement, récupération du sémaphore
</FONT></OL><FONT SIZE=5>La condition est indépendante de l'événement et n'est pas nécessairement valide à la réception (cf. exemple).<BR>
<BR>

Exemple, le programme suivant:
</FONT><PRE><FONT SIZE=5><TT>
pthread_mutex_t m;
pthread_cond_t  cond;
int             condition = 0;

void *ecoute(void *beurk)
{
    pthread_mutex_lock(m);
    sleep(5);
    while (!condition)
        pthread_cond_wait(cond, m);
    pthread_mutex_unlock(m);

    pthread_mutex_lock(print);
    printf(" Condition realisee\n");
    pthread_mutex_unlock(print);
}

main()
{
    pthread_t lathread;

    pthread_create(lathread, pthread_attr_default, ecoute, NULL);
    sleep(1);
    pthread_mutex_lock(m);
    condition = 1;
    pthread_mutex_unlock(m);
    pthread_cond_signal(cond);
}

</TT></FONT></PRE><FONT SIZE=5> 
Un autre exemple d'utilisation de condition avec deux threads qui utilisent deux tampons pour réaliser la commande cp, avec une activité responsable de la lecture et l'autre de l'écriture.
Les conditions permettent de synchroniser les deux threads. Ici nous utilisons la syntaxe NeXT/MACH.
</FONT><PRE><FONT SIZE=5><TT>
#include &lt;sdtio.h&gt; 
#include &lt;fcntl.h&gt;
#import  &lt;mach/cthreads.h&gt;

enum { BUFFER_A_LIRE = 1, BUFFER_A_ECRIRE = -1 };

mutex_t     lock1;  /* variables de protection et d'exclusion */
condition_t cond1;

char buff1[BUFSIZ];
int  nb_lu1;
int  etat1 = BUFFER_A_LIRE;
int  ds, dd;        /* descripteurs source et destination */

lire()         /* activite lecture */
{
    for(;;)  { /* lecture dans le buffer 1 */
        mutex_lock(lock1);
        while (etat1 == BUFFER_A_ECRIRE)
            condition_wait(cond1, lock1);
        nb_lu1 = read(ds, buff1, BUFSIZ);
        if (nb_lu1 == 0)
        {
            etat1 = BUFFER_A_ECRIRE;
            condition_signal(cond1);
            mutex_unlock(lock1);
            break;
        }
        etat1 = BUFFER_A_ECRIRE;
        condition_signal(cond1);
        mutex_unlock(lock1);
    }
}

ecrire()
{
    for(;;)
    { /* ecriture du buffer 1 */        
        mutex_lock(lock1);
        while (etat1 == BUFFER_A_LIRE)
            condition_wait(cond1, lock1);
        if (nb_lu1 == 0)
        {
            mutex_unlock(lock1);
            exit(0);
        }
        write(dd, buff1, nb_lu1);
        mutex_unlock(lock1);
        etat1 = BUFFER_A_LIRE;
        condition_signal(cond1);
    }
}

main()
{
    ds    = open(argv[1], O_RDONLY);
    dd    = open(argv[2], O_WRONLY|O_TRUNC|O_CREAT, 0666);
    lock1 = mutex_alloc();
    cond1 = condition_alloc();

    cthread_fork((cthread_fn_t)lire, (any_t)0);
    ecrire(); /* la thread principale realise les ecritures */
}
</TT></FONT></PRE><FONT SIZE=5> </FONT><!--TOC section <FONT SIZE=5>Ordonnancement des activités</FONT>-->

<H2><FONT SIZE=5>19.5&nbsp;&nbsp; Ordonnancement des activités</FONT></H2><!--SEC END -->
<!--TOC subsection <FONT SIZE=5>L'ordonnancement POSIX des activités</FONT>-->

<H3><FONT SIZE=5>19.5.1&nbsp;&nbsp; L'ordonnancement POSIX des activités</FONT></H3><!--SEC END -->
<FONT SIZE=5>L'ordonnancement des activités DCE basé sur POSIX est très similaire à l'ordonnancement des activités sous MACH.
Deux valeurs permettent de définir le mode d'ordonnancement d'une activité &nbsp;:<BR>la politique et la priorité.<BR>Pour manipuler ces deux valeurs, il vous faut créer un objet attribut d'activité (</FONT><CODE><FONT SIZE=5><TT>pthread_attr</TT></FONT></CODE><FONT SIZE=5>) en appelant </FONT><CODE><FONT SIZE=5><TT>pthread_attr_create()</TT></FONT></CODE><FONT SIZE=5>, puis changer les valeurs par défaut avec les fonctions décrites plus loin et créer la pthread avec cet objet </FONT><CODE><FONT SIZE=5><TT>pthread_attr</TT></FONT></CODE><FONT SIZE=5>.
Ou bien la pthread peut elle-même changer ses deux valeurs, priorité et politique.<BR>
<BR>
Les fonctions sont :
</FONT><PRE><FONT SIZE=5><TT>
#include &lt;pthread.h&gt;
pthread_attr_setsched(pthread_attr_t *attr, int politique);
</TT></FONT></PRE><FONT SIZE=5>Les différentes politiques possibles sont&nbsp;:
</FONT><DL COMPACT=compact>
<DT><FONT SIZE=5>
</FONT><FONT SIZE=5>SCHED_FIFO</FONT><DD><FONT SIZE=5> La thread la plus prioritaire s'exécute jusqu'à ce qu'elle bloque. Si il y a plus d'une pthread de priorité maximum, la première qui obtient le cpu s'exécute jusqu'à ce qu'elle bloque.
</FONT>
<DT><FONT SIZE=5>SCHED_RR</FONT><DD><FONT SIZE=5> Round Robin. La thread la plus prioritaire s'exécute jusqu'à
 ce qu'elle bloque. Les threads de même priorité maximum sont organisées avec le
 principe du tourniquet, c'est-à-dire qu'il existe un quantum de temps au bout
 duquel le cpu est préempté pour une autre thread (voire Chapitre
 </FONT><A HREF="#cha:processus"><FONT SIZE=5>7</FONT></A><FONT SIZE=5> sur les Processus).
</FONT>
<DT><FONT SIZE=5>SCHED_OTHER</FONT><DD><FONT SIZE=5> Comportement par défaut. Tous les threads sont dans le
 même touniquet, il n'y a pas de niveau de priorité, ceci permet l'absence de famine. Mais les threads avec une politique </FONT><FONT SIZE=5><TT>SCHED_FIFO</TT></FONT><FONT SIZE=5> ou </FONT><FONT SIZE=5><TT>SCHED_RR</TT></FONT><FONT SIZE=5> peuvent placer les threads </FONT><FONT SIZE=5><TT>SCHED_OTHER</TT></FONT><FONT SIZE=5> en situation de famine.
</FONT>
<DT><FONT SIZE=5>SCHED_FG_NP</FONT><DD><FONT SIZE=5> (option DCE non portable) Même politique que </FONT><FONT SIZE=5><TT>SCHED_OTHER</TT></FONT><FONT SIZE=5> mais l'ordonnanceur peut faire évoluer les priorités des threads pour assurer l'équité. 
</FONT>
<DT><FONT SIZE=5>SCHED_BG_NP</FONT><DD><FONT SIZE=5> (option DCE non portable) Même politique que </FONT><FONT SIZE=5><TT>SCHED_FG_NP</TT></FONT><FONT SIZE=5>, mais les threads avec une politique </FONT><FONT SIZE=5><TT>SCHED_FIFO</TT></FONT><FONT SIZE=5> ou </FONT><FONT SIZE=5><TT>SCHED_RR</TT></FONT><FONT SIZE=5> peuvent placer les threads </FONT><FONT SIZE=5><TT>SCHED_BG_NP</TT></FONT><FONT SIZE=5> en situation de famine.
</FONT></DL><PRE><FONT SIZE=5><TT>
pthread_attr_setprio(pthread_attr_t *attr, int prio);
</TT></FONT></PRE><FONT SIZE=5>La priorité varie dans un intervalle défini par la politique:<BR>PRI_OTHER_MIN </FONT><FONT SIZE=5>&lt;=</FONT><FONT SIZE=5> prio </FONT><FONT SIZE=5>&lt;=</FONT><FONT SIZE=5> PRI_OTHER_MAX<BR>PRI_FIFO_MIN </FONT><FONT SIZE=5>&lt;=</FONT><FONT SIZE=5> prio </FONT><FONT SIZE=5>&lt;=</FONT><FONT SIZE=5> PRI_FIFO_MAX<BR>PRI_RR_MIN </FONT><FONT SIZE=5>&lt;=</FONT><FONT SIZE=5> prio </FONT><FONT SIZE=5>&lt;=</FONT><FONT SIZE=5> PRI_RR_MAX<BR>PRI_FG_MIN_NP </FONT><FONT SIZE=5>&lt;=</FONT><FONT SIZE=5> prio </FONT><FONT SIZE=5>&lt;=</FONT><FONT SIZE=5> PRI_FG_MAX_NP<BR>PRI_BG_MIN_NP </FONT><FONT SIZE=5>&lt;=</FONT><FONT SIZE=5> prio </FONT><FONT SIZE=5>&lt;=</FONT><FONT SIZE=5> PRI_BG_MAX_NP<BR>Ces deux fonctions retournent 0 en cas de succès et -1 sinon. La valeur de </FONT><FONT SIZE=5><B>errno</B></FONT><FONT SIZE=5> indiquant si l'erreur est une question de paramètres ou de permission.<BR>
<BR>
Les deux fonctions que l'on peut appeler sur une pthread pour changer sa priorité ou sa politique sont&nbsp;:
</FONT><PRE><FONT SIZE=5><TT>
pthread_setprio(pthread_t *unepthread, int prio);
pthread_setsched(pthread_t *unepthread, int politique, int prio);
</TT></FONT></PRE><FONT SIZE=5>
Il est possible de connaître la priorité ou la politique d'une pthread ou d'un objet pthread_attr avec&nbsp;:
</FONT><PRE><FONT SIZE=5><TT>
pthread_attr_getprio(pthread_attr_t *attr,int prio);
pthread_attr_getsched(pthread_attr_t *attr,int politique);
pthread_getprio(pthread_t *unepthread, int prio);
pthread_getsched(pthread_t *unepthread, int politique);
</TT></FONT></PRE><!--TOC section <FONT SIZE=5>Les variables spécifiques à une thread</FONT>-->

<H2><FONT SIZE=5>19.6&nbsp;&nbsp; Les variables spécifiques à une thread</FONT></H2><!--SEC END -->
<FONT SIZE=5>Avec un processus multi-threads, nous sommes dans une situation de partage de
données. Toutes les données du processus sont à priori manipulables par toutes les
threads. Or certaines données sont critiques et difficilement
partageables. Premièrement ce sont les données de la bibliothèque
standard. Pour les fonctions de la bibliothèque standard, on peut résoudre le
problème en utilisant un sémaphore d'exclusion mutuelle
</FONT><CODE><FONT SIZE=5><TT>pthread_mutex_t</TT></FONT></CODE><FONT SIZE=5> pour POSIX.<BR>
<BR>
Mais certaines variables ne peuvent être protégées.
C'est le cas de la variables </FONT><FONT SIZE=5><TT>errno</TT></FONT><FONT SIZE=5>, comme nous l'avons vu précédemment.
Pour cette variable, la solution est d'avoir une variable
par thread. Ainsi le fichier </FONT><CODE><FONT SIZE=5><TT>&lt;errno.h&gt;</TT></FONT></CODE><FONT SIZE=5> est modifié et contient&nbsp;:<BR></FONT><PRE><FONT SIZE=5><TT>
extern int *_errno();
#define errno (*_errno())
</TT></FONT></PRE><FONT SIZE=5> 
La valeur </FONT><FONT SIZE=5><TT>errno</TT></FONT><FONT SIZE=5> est obtenue par une fonction qui retourne la valeur de
</FONT><FONT SIZE=5><TT>errno</TT></FONT><FONT SIZE=5> associée à la thread qui fait l'appel à </FONT><FONT SIZE=5><TT>_errno</TT></FONT><FONT SIZE=5> .<BR>
<BR>
</FONT><!--TOC subsection <FONT SIZE=5>Principe général des données spécifiques, POSIX</FONT>-->

<H3><FONT SIZE=5>19.6.1&nbsp;&nbsp; Principe général des données spécifiques, POSIX</FONT></H3><!--SEC END -->
<FONT SIZE=5>L'idée des données spécifique est de créer un vecteur pour chaque donnée spécifique.
Ainsi pour des données spécifique statiques, chaque thread possède son propre exemplaire.
Les données spécifiques sont identifiées par des clés de type </FONT><CODE><FONT SIZE=5><TT>pthread_key_t</TT></FONT></CODE><FONT SIZE=5>.<BR>
<BR>
</FONT><!--TOC subsection <FONT SIZE=5>Création de clés</FONT>-->

<H3><FONT SIZE=5>19.6.2&nbsp;&nbsp; Création de clés</FONT></H3><!--SEC END -->
<FONT SIZE=5>La création d'une clé est liée à la création d'un tableau statique (variable globale), initialisé à NULL à la création. La fonction 
</FONT><PRE><FONT SIZE=5><TT>
#include &lt;pthread.h&gt;
int pthread_keycreate (pthread_key_t *p_cle, 
                       void          (*destructeur)(void *valeur));
</TT></FONT></PRE><FONT SIZE=5>
permet la création du tableau, 0 succès et -1 echec. La structure pointée par </FONT><CODE><FONT SIZE=5><TT>p_cle</TT></FONT></CODE><FONT SIZE=5> nous permettra d'accèder aux valeurs stockées, la clé est évidemment la même pour toutes les threads.
Le paramètre </FONT><FONT SIZE=5><TT>destructeur</TT></FONT><FONT SIZE=5> de type pointeur sur fonction prenant un pointeur sur void en paramètre et renvoyant void, donne l'adresse d'une fonction qui est exécutée à la terminaison de la thread (ce qui permet de faire le ménage).
Si ce pointeur est nul, l'information n'est pas détruite à la terminaison de l'activité.<BR>
<BR>

</FONT><!--TOC subsection <FONT SIZE=5>Lecture/écriture d'une variable spécifique</FONT>-->

<H3><FONT SIZE=5>19.6.3&nbsp;&nbsp; Lecture/écriture d'une variable spécifique</FONT></H3><!--SEC END -->
<FONT SIZE=5>La fonction 
</FONT><PRE><FONT SIZE=5><TT>
#include &lt;pthread.h&gt;
int pthread_getspecific (pthread_key_t *p_clé, void **pvaleur);
</TT></FONT></PRE><FONT SIZE=5>
permet la lecture de la valeur qui est copié à l'adresse </FONT><FONT SIZE=5><TT>pvaleur</TT></FONT><FONT SIZE=5>
retourne 0 ou -1 selon que l'appel à réussi ou non. 
La fonction
</FONT><PRE><FONT SIZE=5><TT>
#include &lt;pthread.h&gt;
int pthread_setspecific (pthread_key_t *p_clé, void *valeur);
</TT></FONT></PRE><FONT SIZE=5>
permet l'écriture à l'emplacement spécifié de </FONT><FONT SIZE=5><TT>valeur</TT></FONT><FONT SIZE=5>
retourne 0 ou -1 selon que l'appel a réussit ou non. <BR>
<BR>
</FONT><!--TOC section <FONT SIZE=5>Les fonctions standardes utilisant des zones statiques</FONT>-->

<H2><FONT SIZE=5>19.7&nbsp;&nbsp; Les fonctions standardes utilisant des zones statiques</FONT></H2><!--SEC END -->
<FONT SIZE=5>Certaines fonctions standardes comme </FONT><FONT SIZE=5><TT>ttyname()</TT></FONT><FONT SIZE=5> ou </FONT><FONT SIZE=5><TT>readdir()</TT></FONT><FONT SIZE=5> retourne l'adresse d'une zone statique. Plusieurs threads en concurrence peuvent donc nous amener à des situations incohérentes. La solution des sémaphores d'exclusion étant coûteuse, ces fonctions sont réécrites pour la bibliothèque de thread de façon à être réentrantes.<BR>
<BR>
Attention les problèmes de réentrance peuvent avoir lieu en utilisant des
appels systèmes non réentrant dans les handlers de signaux &nbsp;! Ceci sans utiliser
de threads &nbsp;!<BR>
<BR>

</FONT><!--TOC chapter <FONT SIZE=5>Entrées-sorties avancées</FONT>-->

<H1><FONT SIZE=5>Chapitre&nbsp;20&nbsp;&nbsp; Entrées-sorties avancées</FONT></H1><!--SEC END -->
<FONT SIZE=5>Les entrées-sorties avancées sont des entrées-sorties qui permettent
de faire abstraction du réseau ou d'utiliser le protocole UDP avec
des commandes d'envoi et de réception de messages. Les deux grandes
familles de systèmes UNIX ont proposé chacune leur méthode. D'une
part les </FONT><FONT SIZE=5><TT>streams</TT></FONT><FONT SIZE=5> de SYS V, et d'autre part les </FONT><FONT SIZE=5><TT>sockets</TT></FONT><FONT SIZE=5> de BSD. Dans
les deux cas, le principe de conservation de l'interface </FONT><FONT SIZE=5><TT>read</TT></FONT><FONT SIZE=5> et
</FONT><FONT SIZE=5><TT>write </TT></FONT><FONT SIZE=5> a été conservé au maximum. Le choix </FONT><FONT SIZE=5><B>POSIX</B></FONT><FONT SIZE=5> est
l'utilisation de </FONT><FONT SIZE=5><TT>sockets</TT></FONT><FONT SIZE=5>.<BR>
<BR>
</FONT><!--TOC section <FONT SIZE=5>Les streams</FONT>-->

<H2><FONT SIZE=5>20.1&nbsp;&nbsp; Les streams</FONT></H2><!--SEC END -->
<FONT SIZE=5>
Les entrées-sorties avancées décrites ici sont spécifiques au système
V.4 d'ATT, les outils correspondant sous BSD sont les sockets, qui grâce
à leurs possibilités réseaux, ont éte choisies dans la norme POSIX. <BR>
<BR>
On trouve dans les implémentations Système V.4 un mécanisme
d'interfaçage des drivers de périphériques appelé </FONT><FONT SIZE=5><TT>streams</TT></FONT><FONT SIZE=5>.
(Attention ce ne sont pas les canaux de la bibliothèques standard).
Les streams améliorent le précédent mécanisme de </FONT><FONT SIZE=5><TT>clist</TT></FONT><FONT SIZE=5> utilisé pour bufferiser les entrées-sorties. <BR>
<BR>

</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML076.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 20.1&nbsp;: Un stream</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="streams"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>
Le stream fournit un canal bidirectionnel entre le processus et le
driver de terminal (ou de pseudo-terminal) (voir figure </FONT><A HREF="#streams"><FONT SIZE=5>20.1</FONT></A><FONT SIZE=5>). Un apport des </FONT><FONT SIZE=5><TT>streams</TT></FONT><FONT SIZE=5> est de pouvoir insérer un module de traitement entre la tête du stream et le
driver de terminal comme le montre la figure </FONT><A HREF="#streams2"><FONT SIZE=5>20.2</FONT></A><FONT SIZE=5>.<BR>
<BR>

</FONT><BLOCKQUOTE><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV><FONT SIZE=5>
</FONT><DIV ALIGN=center><FONT SIZE=5>
</FONT><IMG SRC="CHTML077.gif"><FONT SIZE=5>
</FONT></DIV><BR>
<DIV ALIGN=center><FONT SIZE=5>Figure 20.2&nbsp;: Ajout d'un module de traitement</FONT></DIV><BR>
<FONT SIZE=5>
</FONT><A NAME="streams2"></A><FONT SIZE=5>
</FONT><DIV ALIGN=center><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><FONT SIZE=5>
Le module de traitement doit être linké au noyau pour fonctionner, ce qui limite la
portée de cet ajout.<BR>
<BR>
Les streams offrent des fonctionnalités plus larges que les deux
appels classiques </FONT><FONT SIZE=5><TT>read</TT></FONT><FONT SIZE=5> et </FONT><FONT SIZE=5><TT>write</TT></FONT><FONT SIZE=5>. Il est possible sur les
</FONT><FONT SIZE=5><TT>streams</TT></FONT><FONT SIZE=5> d'utiliser deux appels </FONT><FONT SIZE=5><TT>putmsg</TT></FONT><FONT SIZE=5> et </FONT><FONT SIZE=5><TT>putpmsg</TT></FONT><FONT SIZE=5> qui
permettent d'envoyer des informations "express" ou des informations
de contrôle (des signaux par exemple). Ceci permet en particulier de
réaliser un module de traitement Réseau, qui va permettre d'utiliser
un fichier à distance comme un fichier local, tout en permettant grâce
à </FONT><FONT SIZE=5><TT>putmsg et getmsg</TT></FONT><FONT SIZE=5> de pouvoir envoyer des commandes au module de
traitement ou d'envoyer des messages hord bande.
On ne trouvera des implémentations des streams que dans les
implémentations de Systeme V.4. Ce qui n'est pas le cas des HP avec le
système 9.<BR>
<BR>
</FONT><!--TOC section <FONT SIZE=5>Les sockets</FONT>-->

<H2><FONT SIZE=5>20.2&nbsp;&nbsp; Les sockets</FONT></H2><!--SEC END -->
<FONT SIZE=5>Les sockets ont été crées dans l'implémentation BSD.
Ils permettent de réaliser des échanges interprocessus sans liens d'héritage, et même ce qui est le point fort, entre processus s'exécutant sur des machines différentes. La communication se faisant alors grâce à un réseau de façon transparente pour l'utilisateur.<BR>
<BR>
Les sockets sont des liens bidirectionnels de communication,
ils ont été mis au point pour pouvoir manipuler de façon homogène les communications entre machines.<BR>
<BR>
Les sockets ont été définis de façon à pouvoir unifier tous les systèmes de communication inter processus (IPC) à un très haut niveau, en permettant à la fois:
</FONT><UL>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5> de garder une compatibilité ascendante avec le principe fondamental des filtres UNIX et des redirections avec l'utilisation des descripteurs. </FONT><BR>
<BR>

<LI><FONT SIZE=5> d'utiliser des protocoles divers, en particulier d'envoyer des messages "Hors-Bande" qui peuvent doubler les autres informations sur la ligne.
 </FONT></UL><FONT SIZE=5>
C'est un objet abstrait qui peut être manipulé comme un descripteur de fichier.<BR>
<BR>
Les sockets sont pour un processus utilisables comme des fichiers, les appels systèmes </FONT><FONT SIZE=5><TT>read</TT></FONT><FONT SIZE=5> et </FONT><FONT SIZE=5><TT>write</TT></FONT><FONT SIZE=5> fonctionnent normalement sur des sockets ouverts en mode stream. La primitve </FONT><FONT SIZE=5><TT>socket </TT></FONT><FONT SIZE=5> de création de socket retourne un entier indiquant une entrée de la table des descripteur.<BR>
<BR>
La structure équivalente à l'inode des fichiers est une structure </FONT><FONT SIZE=5><TT>struct socket</TT></FONT><FONT SIZE=5> définie dans le fichier </FONT><CODE><FONT SIZE=5><TT>&lt;sys/socket.h&gt;</TT></FONT></CODE><FONT SIZE=5>.<BR>
<BR>
A l'inverse des fichiers, les sockets n'ont d'existence que lorsqu'ils sont référencés par un processus.<BR>
<BR>
</FONT><!--TOC section <FONT SIZE=5>Création d'un socket</FONT>-->

<H2><FONT SIZE=5>20.3&nbsp;&nbsp; Création d'un socket</FONT></H2><!--SEC END -->
<FONT SIZE=5>La création d'un socket se fait grâce à l'appel <BR>
<BR>
</FONT><PRE><FONT SIZE=5><TT>
int s_desc = socket (int domain, int type, int protocol);
</TT></FONT></PRE><FONT SIZE=5>
Le </FONT><FONT SIZE=5><EM>Domaine</EM></FONT><FONT SIZE=5> est un terme réseau qui désigne un ensemble de protocoles de communication entre machines. Le domaine permet de définir correctement l'adresse pour le réseau du socket.<BR>
<BR>
En effet comme nous l'avons vu dans le cas de tubes, quand deux processus n'ont pas de lien d'héritage, il faut utiliser des tubes nommés pour pouvoir les faire communiquer par tubes.
Ici pour que deux processus puisse communiquer par socket, il faut qu'un processus crée un socket puis lui définisse une adresse dans le domaine, le deuxième processus pourra ensuite se connecter au socket ainsi nommé.<BR>
<BR>
On trouvera dans </FONT><CODE><FONT SIZE=5><TT>&lt;sys/socket.h&gt;</TT></FONT></CODE><FONT SIZE=5> les différents domaines supportés
par exemple :<BR>
<BR>
AF_UNIX (pour tous les protocoles internes)<BR>AF_INET (pour les protocoles ARPA internet)<BR>AF_CCITT (X25)<BR>AF_NS ( chez Xerox )<BR>AF_APPLETALK <BR>etc<BR>
<BR>
Le domaine définit aussi la liste des protocoles utilisables. Les différents protocoles ne sont pas utilisables dans tous les domaines.<BR>
<BR>
</FONT><!--TOC section <FONT SIZE=5>Les différentes formes de communication par socket</FONT>-->

<H2><FONT SIZE=5>20.4&nbsp;&nbsp; Les différentes formes de communication par socket</FONT></H2><!--SEC END -->
<FONT SIZE=5>Le type permet de définir le type de communication voulue.<BR>Parmi les propriétés d'une transmission, on trouve&nbsp;:
</FONT><OL type=1>
<LI><FONT SIZE=5>
</FONT><FONT SIZE=5> les données sont livrées dans l'ordre
</FONT>
<LI><FONT SIZE=5> sans duplication
</FONT>
<LI><FONT SIZE=5> sans perte
</FONT>
<LI><FONT SIZE=5> en préservant les bornes des messages
</FONT>
<LI><FONT SIZE=5> avec des messages "express" hors-bande.
</FONT>
<LI><FONT SIZE=5> communication orientée-connexion = "mode connecté".
</FONT></OL><FONT SIZE=5>Les tubes, par exemple, ont les trois premières propriétés, mais pas la quatrième.<BR>La sixième propriété est un mode de communication où l'on définit sur le réseau un canal de transmission, ce qui permet d'éviter d'envoyer avec chaque message l'adresse du socket d'envoi. A la place, un échange d'identité est réalisé avant le début de la communication proprement dite. Il est entendu qu'il ne sera pas possible de se connecter à partir d'un troisième socket.<BR>
<BR>
On peut par exemple si l'on utilise une ligne "à la" TRANSPAC vouloir utiliser un système où les messages ne sont pas découpés (propriété 4), et où les messages peuvent éventuellement être perdus (ligne modem) ou dupliqués, en effet TRANSPAC utilise un algorithme de transmission qui peut avoir pour conséquence la duplication de paquets d'informations. <BR>
<BR>
Les types les plus utilisés sont&nbsp;:
</FONT><DL COMPACT=compact>
<DT><FONT SIZE=5>
</FONT><FONT SIZE=5>SOCK_STREAM</FONT><DD><FONT SIZE=5> connexion à double sens avec les propriétés 1,2,3 et éventuellement la propriété 5.
</FONT>
<DT><FONT SIZE=5>SOCK_DGRAM</FONT><DD><FONT SIZE=5> datagrammes, propriété 4 uniquement.
</FONT>
<DT><FONT SIZE=5>SOCK_RAW</FONT><DD><FONT SIZE=5> (cru) aucun protocole, uniquement par le super utilisateur, permet de manipuler directement l'interface de communication bas niveau.
</FONT>
<DT><FONT SIZE=5>SOCK_SEQPACKET</FONT><DD><FONT SIZE=5> 1,2,3. Le lecteur doit y lire un paquet à chaque lecture. Défini uniquement dans le domaine AF_NS (Xerox)
</FONT></DL><FONT SIZE=5>Les protocoles sont en géneral spécifiques au domaine, l'utilisation de la valeur zéro pour le protocole laisse au système le soin de sélectionner lui-même le bon protocole dans le domaine. <BR>
<BR>
</FONT><!--TOC section <FONT SIZE=5>Définition de l'adresse d'un socket</FONT>-->

<H2><FONT SIZE=5>20.5&nbsp;&nbsp; Définition de l'adresse d'un socket</FONT></H2><!--SEC END -->
<FONT SIZE=5>Dans le cas de deux processus qui n'ont pas d'ancêtres communs, il faut donner au socket une adresse (un nom) qui va permettre à différents processus de se brancher sur la bonne ligne. Comme nous l'avons indiqué plus haut, le type de l'adresse dépend du domaine. Mais une seule primitive réalise l'association d'une adresse à une socket, c'est la primitive&nbsp;:
</FONT><PRE><FONT SIZE=5><TT>
int bind(int descripteur, struct sockaddr *adresse, int longeur_adresse);
</TT></FONT></PRE><FONT SIZE=5>
Un appel à cette fonction réalise un attachement (bind) du socket de descripteur donné à l'adresse pointée par </FONT><FONT SIZE=5><TT>adresse</TT></FONT><FONT SIZE=5> qui est supposée être de taille </FONT><FONT SIZE=5><TT>longeur_adresse</TT></FONT><FONT SIZE=5>. Retourne -1 en cas d'echec.<BR>
<BR>
La taille des adresses de socket varie en fonction du domaine de communication utilisé, les adresses sont donc structurées comme des chaines du Pascal : la longueur en premier sur deux octets suivie de l'adresse réelle (en général, une zone de 14 octets est réservée pour l'adresse réelle).<BR>
<BR>
Une seule adresse est associée à un socket donné sur une machine, par contre le domaine de communication peut permettre l'utilisation répétée d'une même adresse, le courrier électronique par exemple.<BR>
<BR>
</FONT><!--TOC section <FONT SIZE=5>Utilisation des sockets</FONT>-->

<H2><FONT SIZE=5>20.6&nbsp;&nbsp; Utilisation des sockets</FONT></H2><!--SEC END -->
<FONT SIZE=5>Les sockets sont donc un regroupement sous un même formalisme d'un ensemble de protocoles de communication. Nous regardons ici quelques cas d'utilisations.<BR>
<BR>
</FONT><!--TOC subsection <FONT SIZE=5>Utilisation local AF_UNIX</FONT>-->

<H3><FONT SIZE=5>20.6.1&nbsp;&nbsp; Utilisation local AF_UNIX</FONT></H3><!--SEC END -->
<FONT SIZE=5>Il est possible d'utiliser les sockets comme des tubes, et une fonction spécifique existe qui crée deux sockets dont le comportement est identique à celui que l'on obtient avec l'appel </FONT><FONT SIZE=5><TT>pipe</TT></FONT><FONT SIZE=5>, c'est la primitive&nbsp;:
</FONT><PRE><FONT SIZE=5><TT>
void socketpair (int domain, int type, int protocol, int sv[]).
</TT></FONT></PRE><FONT SIZE=5>
que l'on appellera avec les paramètres suivant pour créer un tube&nbsp;:
</FONT><PRE><FONT SIZE=5><TT>
socketpair(AF_UNIX, SOCK_STREAM, 0, tube);
</TT></FONT></PRE><FONT SIZE=5>les deux sockets crées sont immédiatement utilisables exactement comme un tube, et comme les tubes, ces deux sockets n'ont pas de nom.
Remarquer que ces deux sockets restent utilisables dans les deux sens. Pour avoir un comportment similaire à cette paire de sockets, nous devrions avec des tubes créer deux tubes dirigés chacun dans un sens.<BR>
<BR>
La structure d'adresse pour le domaine AF_UNIX est comme pour les tubes une référence de l'arborescence. Elle est de type </FONT><FONT SIZE=5><TT>struct sockaddr_un</TT></FONT><FONT SIZE=5> défini dans le fichier </FONT><CODE><FONT SIZE=5><TT>&lt;sys/un.h&gt;</TT></FONT></CODE><FONT SIZE=5> &nbsp;:
</FONT><PRE><FONT SIZE=5><TT>
struct sockaddr_un {
        short   sun_family;    /* AF_UNIX */
        char    sun_path[108]; /* reference */
};
</TT></FONT></PRE><FONT SIZE=5>La primitive </FONT><FONT SIZE=5><TT>bind</TT></FONT><FONT SIZE=5> ne fonctione que si la référence n'existe pas.<BR>
<BR>
</FONT><!--TOC subsection <FONT SIZE=5>Utilisation avec le concept INTERNET</FONT>-->

<H3><FONT SIZE=5>20.6.2&nbsp;&nbsp; Utilisation avec le concept INTERNET</FONT></H3><!--SEC END -->
<FONT SIZE=5>Internet est une norme de communication réseau largement utilisée par "the net" qui est souvent référencé par TCP/IP, qui sont les deux protocoles principaux. Cette norme permet l'interconnection de tous les réseaux quelle que soit leur technologie.<BR>
<BR>
Les sockets AF_INET utiliserons les supports TCP/IP de votre machine.<BR>
<BR>
Les adresses sont de la forme </FONT><FONT SIZE=5><TT>struct sockaddr_in</TT></FONT><FONT SIZE=5> définie dans le fichier </FONT><CODE><FONT SIZE=5><TT>&lt;netinet/in.h&gt;</TT></FONT></CODE><FONT SIZE=5>&nbsp;:
</FONT><PRE><FONT SIZE=5><TT>
struct in_addr {  /* adrsse internet 192.103.134.86 -&gt; fillmore */
        u_long s_addr;
};

struct sockaddr_in {
        short   sin_family; /* AF_INET */
        u_short sin_port;   /* numero de port */
        struct  in_addr sin_addr; 
        char    sin_zero[8];/* Huit zéros utilisés comme masque ailleurs */
};
</TT></FONT></PRE><FONT SIZE=5>Ainsi l'attachement va se faire sur une machine, et sur cette machine le socket sera attaché à un certain port (entier) qui permet de différencier les différents sockets utilisables de l'extérieur.<BR>
<BR>
Les serveurs doivent donc rendre public leur numéro de port, pour que les clients puissent se connecter.<BR>
<BR>
Le système a un certain nombre de ports réservés (IPPORT_RESERVED).<BR>
<BR>
Les clients n'ont pas d'intérêt à avoir un port prédéfini, en spécifiant INADDR_ANY le système choisit un port libre, ce qui évite
les conflits (le bind est implicite lors du premier envoi).<BR>
<BR>
Attention : l'accès partagé aux ports impose les mêmes contraintes que toute autre ressource du système. <BR>
<BR>
</FONT><!--TOC section <FONT SIZE=5>Le mode connecté</FONT>-->

<H2><FONT SIZE=5>20.7&nbsp;&nbsp; Le mode connecté</FONT></H2><!--SEC END -->
<FONT SIZE=5>Dans une liaison en mode connecté (propriété 6), il faut initialiser la communication entre les deux processus. Pour cela on utilisera un appel à la primitive&nbsp;:
</FONT><PRE><FONT SIZE=5><TT>
int connect (int socket, struct sockaddr *server, int serveraddrlen);
</TT></FONT></PRE><FONT SIZE=5>dans le processus client.<BR>
<BR>
Le processus serveur doit en premier lieu indiquer grâce à la primitive 
</FONT><PRE><FONT SIZE=5><TT>
int listen (int socket, int nombre);
</TT></FONT></PRE><FONT SIZE=5>
le nombre de connexions qui peuvent être bufferisées (mise en attente d'un accept).<BR>
<BR>
Les connexions sont ensuite reçues l'une après l'autre dans le processus serveur avec la primitive :
</FONT><PRE><FONT SIZE=5><TT>
int nsock = accept (int s, struct sockaddr *client, int *clientaddr);
</TT></FONT></PRE><FONT SIZE=5>Attention : </FONT><FONT SIZE=5><TT>accept</TT></FONT><FONT SIZE=5> renvoie un nouveau descripteur de socket, c'est sur ce nouveau socket que sera réalisé la connexion entre client et serveur. Le socket d'origine ne sert que de file d'attente des demandes de connexion par </FONT><FONT SIZE=5><TT>connect</TT></FONT><FONT SIZE=5>.<BR>
<BR>
</FONT><!--TOC section <FONT SIZE=5>La communication par messages avec les sockets</FONT>-->

<H2><FONT SIZE=5>20.8&nbsp;&nbsp; La communication par messages avec les sockets</FONT></H2><!--SEC END -->
<FONT SIZE=5>les primitives d'envoi de messages&nbsp;:<BR>
<BR>
</FONT><PRE><FONT SIZE=5><TT>
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;

int send(int s, char * msg, int len, int flags); /* mode connecté seulement */

int sendto(int s, char * msg, int len, int flags,
           struct sockaddr *to, int tolen);

int sendmsg(int s, struct msghdr msg[], int flags);

flags: 
 MSG_OOB          /* process out-of-band data */
 MSG_DONTROUTE    /* bypass routing, use direct interface */
</TT></FONT></PRE><FONT SIZE=5>la valeur de retour -1 n'indique pas que le message n'a pas été délivré, mais uniquement une erreur locale.
Si errno == EMSGSIZE, le message est trop long et n'a pas été envoyé.<BR>
<BR>
Réception de messages: 
</FONT><PRE><FONT SIZE=5><TT>
int cc = recv (int s, char *buf, int len, int flags);

int cc = recvfrom (int s, char *buf, int len, int flags,
                   struct sockaddr *from, int *fromlen);

int cc = recvmsg (int s, struct msghdr msg[], int flags);


flags:
     MSG_PEEK    /* peek at incoming message */ 
       
messages:
struct msghdr {
    caddr_t      msg_name;          /* optional address */
    int          msg_namelen;       /* size of address */
    struct iovec *msg_iov;          /* scatter/gather array */
    int          msg_iovlen;        /* # elements in msg_iov */
    caddr_t      msg_accrights;     /* access rights sent/received */
    int          msg_accrightslen;
};
</TT></FONT></PRE><FONT SIZE=5>On utilisera la primitive </FONT><FONT SIZE=5><TT>ioctl</TT></FONT><FONT SIZE=5> pour manipuler les propriétés du socket comme par exemple le mode non bloquant en lecture.<BR>
<BR>
Quelques primitives annexes:<BR>
<BR>
Pour connaître l'adresse du socket associé (en mode connecté) :
</FONT><PRE><FONT SIZE=5><TT>
    getpeername(int s, struct sockaddr *name, int *namelen);
</TT></FONT></PRE><FONT SIZE=5>Donne le nom du socket s :
</FONT><PRE><FONT SIZE=5><TT>
     getsockname(int s, struct sockaddr *name, int *namelen);
</TT></FONT></PRE><FONT SIZE=5>Enfin les primitives suivantes permettent de manipuler certaines options :
</FONT><PRE><FONT SIZE=5><TT>
    getsockopt(int s, int level, int optname, char *optval, int *optlen);

    setsockopt(int s, int level, int optname, char *optval, int optlen);
</TT></FONT></PRE><!--TOC section <FONT SIZE=5>Accès réseau sous Unix</FONT>-->

<H2><FONT SIZE=5>20.9&nbsp;&nbsp; Accès réseau sous Unix</FONT></H2><!--SEC END -->
<FONT SIZE=5>Fichiers de configuration (/etc/...)<BR>
<BR>
</FONT><PRE><FONT SIZE=5><TT>
# Network services, Internet style
#
systat          11/tcp          users
ftp             21/tcp
telnet          23/tcp
smtp            25/tcp          mail

# &lt;internet address&gt;    &lt;official hostname&gt; &lt;aliases&gt;
#
192.134.103.86  rome # Serveur -HP 9000s755

# Internet server configuration database
#
systat  stream  tcp     nowait  /etc/miscd      systatd
#systat dgram   udp     wait    /etc/miscd      systatd
daytime stream  tcp     nowait  /etc/miscd      daytimed

</TT></FONT></PRE><FONT SIZE=5>Une bibliothèque de fonctions permet la manipulation de la base de données INTERNET:
</FONT><FONT SIZE=5><TT>gethostid(), gethostbyname() ,gethostbyaddr() </TT></FONT><FONT SIZE=5> 
 (pas de distinction majuscule/minuscule)<BR>
<BR>
Un standard de représentation des nombres permet le décodage par des machines d'architectures différentes, ex: htonl() = host to network long.
<BR>
<BR>
</FONT><!--HTMLFOOT-->
<FONT SIZE=5></FONT><!--ENDHTML-->
<FONT SIZE=5>
<!--FOOTER-->
</FONT><HR SIZE=2><FONT SIZE=5>
</FONT><BLOCKQUOTE><FONT SIZE=5><EM>Ce document a été traduit de L<sup>A</sup>T<sub>E</sub>X par
</EM></FONT><A HREF="http://pauillac.inria.fr/~maranget/hevea/index.html"><FONT SIZE=5><EM>H</EM></FONT><EM><FONT SIZE=4><sup>E</sup></FONT></EM><FONT SIZE=5><EM>V</EM></FONT><EM><FONT SIZE=4><sup>E</sup></FONT></EM><FONT SIZE=5><EM>A</EM></FONT></A><FONT SIZE=5><EM>.
</EM></FONT></BLOCKQUOTE></BODY>
</HTML>

