PARTAGE DE DONNEES; PRECOMPILATION

Lorsque plusieurs programmes doivent traiter les mêmes données il est très u`~ile que la définition de ces données soit unique. La modification de l'une de ces données est alors effectuée automatiquement pour tous les programmes concernés par cette donnée. Pour réaliser cet objectif il est nécessaire que la définition d'une donnée n'appartienne pas à un programme particulier. La définition de cette donnée doit donc alors être introduite automatiquement dans le programme utilisateur au moment de sa compilation. Cette opération est définie pour beaucoup de langage de programmation ( PL/1, ADA, C, ...). Cette opération s'effectue avant la compilation et ajoute donc une phase supplémentaire à la production d'un programme. 
Cette phase est dénommée "phase de précompilation":
2.1 La commande include
Cette commande permet d'ajouter au fichier à compiler le contenu d'un autre fichier. Ainsi toutes les définitions qui doivent être utilisées par plusieurs programmes seront défiaies dans un fichier qui lui même sera introduit dans le fichier à compiler su moment de
 la précompilation.
Exemple:
Le programme suivant réalise une liste des éléments d'un tablesu de structures. La structure est composée seulement de deux éléments : un nom et une valeur :
main() {
struct elem [
char nom[8]; int val;
} tab[10]; int i;
for(i=0; i< 10; ++i)
scanf("X7s Xd",tab[i].nom,&tab[ij.val); for(i = 0; i < 10; ++i)
printf("Xs Xd\n",tab[i).nom,tab[i).val); }
Si dans un sutre programme on utilise la même structure elle devra être redéclarée. En plaçant cette définition dans un fichier externe cette structure ne sera déclarée qu'une seule fois:
Le fichier de définition:
struct elem {
char nom[8]; int val;
};
Le programme d'écho devient:
~include "exemp.h" main()
struct elem tab[10]; int i;
for(i=0; i< 10; ++i)
scanf("X7s Xd",tab[i].nom,&tab[iJ.val); for(i = 0; i < 10; ++i)
printf("Xs Xd`n",tab[iJ.nom,tab[iJ.val); }
Un autre programme utilisant la même structure peut alors être défini:
#include "exemp.h" main()
struct elem tab(10]; int i;
for(i=0; i< 10; ++i)
scanf("%7s %d",tab[i].nom,&tab[i].val); tri(tab);
for(i = 0; i < 10; ++i)
printf("%s %d\n",tab[i].nom,tab[i].val); tri(tab)
struct elem *tab; int i,j,k; char c;
j = l; while (j )
j = 0;
for(i=0; i < 9; ++i)
for (k = 0; k < 7; ++k)
if (tab[iJ.nom[k] 1= tab[i+1].nom[kJ) break; if ((k < 7) && (tab[i].nom[k] > tab[i+1].nom[k])) j = l;
for(k = 0; k < 7; ++k) c = tab[i].nom[k];
tab[i].nom[k] = tab[i+1].nom[k]; tab[i+lJ.nom[k] = c;
} k = tab[iJ.val;
tab[i].val = tab[i+lJ.val; tab[i+1].val = k;
? }
return; )
La modification de la structure doit être réalisée dans le fichier de définition "exemp.h". Cette modification sera alors valable pour les deux programmes.
Lors de l'écriture d'un projet toutes les données communes à plusieurs unités de traitement de ce projet doivent être déclarées dans des fichiers externes Ces fichiers comprendront aussi les données _succentibles d'être utilisées lors des modifications ou extensions futures.


la commande "include" distingue deux catégories de fichiers. Les fichiers systèmes qui contiennent les définitions standard liées au système et les fichiers utilisateurs spécifiques a chaque application. Les fichiers systèmes sont placés dans un endroit précis de la machine ( sous UNIX ils sont placés dans le répertoire "/usr/include". Les fichiers utilisateurs sont soit placés dans un emplacement précisé paz l'utilisateur ( sous UNIX ils sont placés dans le répertoire courant ou dans un répertoire précisé à l'appel du compilateur ). La distinction entre les deux types du fichier s'effectue par les caractères qui encadrent le nom du fichier à inclure:
Nom de fichier entre guillemets: fichier utilisateur.
Nom de fichier entre les symboles "<" et ">": fichier système. Exemple:
#include <stdio.h> /* fichier système */ #include "exemp.h" /* fichier utilisateur */
2.2 La commande define
Au cours de la phase de précompilation le langage C permet le traitement de macro-instruction. La première fonction des macroinstructions correspond au remplacement d'une chaîne de caractères par une autre. Ce remplacement s'effectue sur toutes les occurences possibles de la chaîne source.
Exemple:
La commande #define EXP 1
transforme l'instruction x += EXP * EXP
en x += 1 * 1
Cette possiblité permet de définir toutes les constantes machines par des noms symboliques. Ce procédé permet une plus grande aisance dans la portabilité du logiciel.
Ce remplacement peut comprendre tout un programme:
#define EXPI { printf("un exemple de remplacement~n"); }
Dans ce dernier cas la partie de programme:
i = 0; EXP1 j = 1;
sera remplacée avant la compilation par la partie:
i = 0;
printf("un exemple de remplacement~n"); } j = 1;
La deuxième fonction des macro-instructions concerne la définition d'une chaîne de caractères avec paramètres. Dans la chaîne de caractères résultante il y a substitution des chaînes paramètres.
Exemple:
La définition
#define max(a,b) (a < b)2 b : a
transforme la partie de programme
x = max(z,t);
en
x = (z < t)7 t: z;
Un nom défini dans une macro-instruction peut toujours être éliminé pour la suite de la compilation par la commande "undef". Cette commande annule la signification de la chaîne paramètre:
Exemple:
#define max(a,b) (a < b)? b : a
x = max(z,t); /* appel de la macro */ #undef max
x = max(z,t); /* appel de la fonction "max" *I
Dans le premier cas l'expression sera remplacée par l'extension de la macro-instruction. Dans le second cas aucun pré-traitement ne sera effectué et un appel à une fonction "max" sera réalisé.
2.3 La précompilation conditionnelle
La précompilation conditionnelle permet de définir différents codes pour le méme programme source.
.... ....
l'utilisation directe du maximum par rapport à l'appel d'une fonction. La définition du maximum pourra étre alors la suivante dans le fichier MAX.h:
#ifdef DIRECT
#define max(a,b) (a < b)? b : a #else
max(a,b) int a,b;
return((a < b)? b : a); ?
#endif
Si au debut du programme utilisant max(a,b) la constante DIRECT est définie la fonction "max" sera traitée comme une macro-instruction. Dans le cas contraire cette fonction sera définie comme une fonction standard C.


Le programme:
#define DIRECT 1 #include "MAX.h" main()
int x,y,z; x = 0;
y = 1;
z = max(x,y);
?
sera compilé comme:
main() int x,y,z; x = 0;
max(a,b) int a,b; {
return((a < b)? b: a);
} main()
int x,y,z; x = 0;
y = 1;
z = max(x,y);
}
L'instruction de précompilation conditionnelle peut également vérifier 
la valeur d'une expression constante. Si cette expression est non nulle
 alors la partie conditionnelle est prise en compte. Dans le cas contraire, 
c'est à dire si l'expression est nulle la partie prise en compte est la partie 
encadrée par les préinstructions "#else" et "#endif".

Exemple: On souhaite placer dans une zone fixe d'une 
longueur donnée des élements de longueur fixe. Si la longueur 
des éléments à ranger est un sous-mutiple de la longueur de la zone 
il faut utiliser un tableau. Dans le cas contraire il faut 
utiliser une structure:

#define LGZONE 512 /* longueur de la
 typedef struct {
 zone */ char NOM[8];
ïnt K; /* définition de } ELEM; l'élément */ #define LGELEM 12 /* longueur de
#if LGZONE X LGELEM l'élément */ struct ELSTR { /* tableau
ELEM TELEM[LGZONE / LGELEM]; d'éléments */ char CDR[LGZONE X LGELEM]; /* caractères de
} PLELEM; remplissage */ #else
ELEM PLELEM[LGZONE / LGELEM]; #endif
2.4 La gestion des lignes
Un programme en langage C peut être généré par d'autres programmes qui fonctionnent alors comme préprocesseur. Le langage "YACC" par exemple

y = 1;
z = (x < y)? y: x;
?
tandis que le programme:
#include "MAX.h" main()
int x,y,z; x = 0;
y = 1;
z = max(x,y);
fournit un programme en langage C à partir d'un fichier "YACC" donné. Pour pouvoir produire des diagnostics d'erreurs corrects une commande du préprocesseur indique au compilateur un numéro de ligne et un nom de fichier. Ce dernier peut être absent et dans ce cas le nom de fichier n'est pas changé. Toutes les erreurs qui pourront alors apparaître après la commande "line" feront référence su fichier précisé et le numéro de ligne sera relatif su numéro défini. La commande à la forme:
#line constante identificateur
La constante donne le numéro de ligne et l'identificateur le nom du fichier.
