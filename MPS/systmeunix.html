<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=utf-8">
	<TITLE></TITLE>
	<META NAME="GENERATOR" CONTENT="OpenOffice.org 1.0.1  (Linux)">
	<META NAME="CREATED" CONTENT="20030127;10501300">
	<META NAME="CHANGED" CONTENT="16010101;0">
	<!--HEVEA command line is: hevea -francais CHTML.tex -->
	<!--FRENCH-->
	<!--HTMLHEAD-->
	<!--ENDHTML-->
	<!--CUT DEF chapter 1 -->
</HEAD>
<BODY LANG="fr-FR">
<P><BR><BR><FONT SIZE=5><BR><BR></FONT><BR><BR>
</P>
<H1 ALIGN=CENTER><FONT SIZE=5>Cours Syst&egrave;me</FONT></H1>
<H3 ALIGN=CENTER><FONT SIZE=5>D.Revuz 
<IMG SRC="http://perso0.free.fr/cgi-bin/wwwcount.cgi?df=dominique.revuz.NCS.dat&amp;dd=zero&amp;ft=0" NAME="Image1" ALIGN=BOTTOM WIDTH=42 HEIGHT=14 BORDER=0>
<IMG SRC="http://perso0.free.fr/cgi-bin/wwwcount.cgi?df=dominique.revuz.HEVEA.dat&amp;dd=zero&amp;ft=0" NAME="Image2" ALIGN=BOTTOM WIDTH=42 HEIGHT=14 BORDER=0>
</FONT>
</H3>
<BLOCKQUOTE><FONT SIZE=5><B>R&eacute;sum&eacute;&nbsp;: </B>Cours de
conception de syst&egrave;mes et d'utilistion d'UNIX<BR>Ce poly est a
l'usage des etudiants de l'ESITCOM et du deuxi&egrave;me cycle
d'informatique de Marne la Vall&eacute;e comme support du cours
SYST&Egrave;MES d'EXPLOITATION.<BR><BR>Cette version 2, apportte de
nombreuse correction de typo et autre, je remercie D. Lecorfec Pour
sa lecture attentive, et les remarques sur le fond seront prises en
compte dans la prochaine version.<BR><BR>Ce poly a une version HTML
disponible sur le Web a l'adresse
suivante&nbsp;&nbsp;:<BR></FONT><TT><FONT SIZE=5>http://www-igm.univ-mlv.fr/~dr/NCS/</FONT></TT><FONT SIZE=5>.<BR><BR>Ce
document a de nombreux d&eacute;fauts en particulier sont manque
d'homog&eacute;n&eacute;it&eacute;, et le manque d'explications sur
certaines parties (explication donn&eacute;es en g&eacute;n&eacute;ral
oralement en cours).<BR><BR>Au menu l'essentiel d'UNIX&nbsp;: SGF,
processus, signaux, m&eacute;moire, m&eacute;moire virtuelle,
manipulation terminaux, tubes, IPC. Quelques d&eacute;tours&nbsp;&nbsp;:
micro-noyaux, s&eacute;curit&eacute;. Un chapitre important mais un
peut court&nbsp;: les probl&egrave;mes de programation distribu&eacute;.
Peut &ecirc;tre une petit incursion sur les pages de G. Roussel vous
en apprendrons plus, sur les threads, les serveurs, JAVA etc
.<BR></FONT><TT><FONT SIZE=5>http://massena.univ-mlv.fr/&nbsp;roussel</FONT></TT><BR><BR><FONT SIZE=5>Pr&eacute;requis&nbsp;:
pour la partie conceptuelle pas de pr&eacute;requis. pour la partie
technique une comp&eacute;tance raisonable en C/C++ est
n&eacute;cessaire.<BR><BR>&Eacute;volutions futures&nbsp;:
dr@univ-mlv.fr (j'attend vos remarques), uniformisation de la
pr&eacute;sentation, n&eacute;toyage des points obscurs, corrections
orthographiques, complement sur fcntl, ioctl, plus d'exemples, des
sujets de projets . </FONT>
</BLOCKQUOTE>
<P><!--TOC chapter <FONT SIZE=5>Bibliographie</FONT>--><BR><BR>
</P>
<H1><FONT SIZE=5>Chapitre&nbsp;1&nbsp;&nbsp; Bibliographie</FONT></H1>
<P><!--SEC END --><FONT SIZE=5>J.-M. Rifflet. </FONT><EM><FONT SIZE=5>La
programation sous</FONT></EM><FONT SIZE=5> UNIX. Ediscience, 1993. Le
manuel de r&eacute;f&eacute;rence.<BR>A.Tanenbaum. </FONT><EM><FONT SIZE=5>Syst&egrave;mes
d'exploitation, sysyt&egrave;mes centralis&eacute;s, syst&egrave;mes
distribu&eacute;s.</FONT></EM><FONT SIZE=5> Inter-Editions, 1994.
Cours g&eacute;n&eacute;ral sur les syt&egrave;mes d'exploitation.<BR>M.
Bach. </FONT><EM><FONT SIZE=5>The design of the UNIX operating
system.</FONT></EM><FONT SIZE=5> 1986. Prentice-Hall, Englewood
Cliffs, N.J. ISBN 0-13-201757-1<BR>J. Beauquier &amp; B. B&eacute;rard
Syst&egrave;mes d'exploitation concepts et algorithmes. 1991.
McGraw-Hill. ISBN 2-7042-1221-X<BR>W.R. Stevens, </FONT><EM><FONT SIZE=5>UNIX
Network Programming.</FONT></EM><FONT SIZE=5> 1990 Prentice-Hall,
Englewood Cliffs, N.J. <BR>W.R. Stevens, </FONT><EM><FONT SIZE=5>Advanced
Programming in the UNIX Environnement</FONT></EM><FONT SIZE=5>
Addison-Wesley ISBN 0-201-56317-7<BR><BR><BR><BR><BR><BR><!--TOC chapter <FONT SIZE=5>Introduction et Historique</FONT>--></FONT><BR><BR>
</P>
<H1><FONT SIZE=5>Chapitre&nbsp;2&nbsp;&nbsp; Introduction et
Historique</FONT></H1>
<H2><FONT SIZE=5><!--SEC END --><!--TOC section <FONT SIZE=5>Historique</FONT>-->2.1&nbsp;&nbsp;
Historique</FONT></H2>
<H3><FONT SIZE=5><!--SEC END --><!--TOC subsection <FONT SIZE=5>les débuts (1945-55)</FONT>-->2.1.1&nbsp;&nbsp;
les d&eacute;buts (1945-55)</FONT></H3>
<P><!--SEC END --><FONT SIZE=5>L'ENIACENIAC soit 20000 tubes &agrave;
vide, fait 20 tonnes et occupe 160 <I>m</I></FONT><FONT SIZE=4><SUP>2</SUP></FONT><FONT SIZE=5>.<BR>Chaque
Calculateur est unique et une &eacute;quipe travaille &agrave; la
fois &agrave; la fabrication, la programmation, la maintenance et
l'utilisation.<BR>Ce sont des machines sans m&eacute;moire, ex&eacute;cutant
un seul programme &agrave; la fois. Le chargement des programmes et
des donn&eacute;es se fait au mieux avec des cartes ou des bandes
perfor&eacute;es.<BR>Durant cette p&eacute;riode de nombreuses t&acirc;ches
sont automatis&eacute;es, chargement, assemblage, &eacute;dition de
liens (avec des biblioth&egrave;ques).<BR>Plus tard sont d&eacute;velopp&eacute;s
les compilateurs permettant d'utiliser des langages de plus haut
niveau.<!--TOC subsection <FONT SIZE=5>Transistors et traitement par lots 1955-65 </FONT>--></FONT></P>
<H3><FONT SIZE=5>2.1.2&nbsp;&nbsp; Transistors et traitement par lots
1955-65 </FONT>
</H3>
<P><!--SEC END --><FONT SIZE=5>Invention de la m&eacute;moire <FONT FACE="symbol">&frac34;&reg;</FONT>
Fabrication industrielle, commercialisation de machines.<BR><BR>Une
s&eacute;ance-type de programmation&nbsp;:</FONT></P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>&eacute;criture sur
	cartes [programmeur] </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>chargement des cartes
	compilateur [op&eacute;rateur] </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>chargement des cartes
	du programme </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>cr&eacute;ation du
	code interm&eacute;diaire (assemblage) </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>chargement des cartes
	de l'assembleur </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>cr&eacute;ation du
	code en langage machine </FONT>
	</P>
	<LI><P><FONT SIZE=5>ex&eacute;cution du programme </FONT>
	</P>
</UL>
<P><FONT SIZE=5>un probl&egrave;me&nbsp;: &agrave; chaque erreur
r&eacute;alisation d'un dump (listing de l'image m&eacute;moire) pour
le programmeur, qui n'est pas sur place pour r&eacute;aliser une
correction &agrave; chaud (pas de p&eacute;riph&eacute;riques
interactifs trop co&ucirc;teux).<BR><BR><B>Solutions&nbsp;:</B> </FONT>
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>le </FONT><EM><FONT SIZE=5>traitement
	par lots</FONT></EM><FONT SIZE=5> (batch proccessing)traitement par
	lots pour regrouper et ex&eacute;cuter par groupes les travaux
	similaires </FONT>
	</P>
	<LI><P><FONT SIZE=5>le </FONT><EM><FONT SIZE=5>moniteur
	r&eacute;sidentmoniteur r&eacute;sident</FONT></EM><FONT SIZE=5> qui
	encha&icirc;ne automatiquement les travaux, un nouveau type de
	cartes est introduit, qui donne des instructions &agrave; r&eacute;aliser
	par le moniteur, (charger, ex&eacute;cuter, etc.). </FONT>
	</P>
</UL>
<P><FONT SIZE=5>Ce moniteur r&eacute;sidant est l'anc&ecirc;tre des
syst&egrave;mes d'exploitation, (la m&eacute;moire qui est apparue
avec les transistors est d&eacute;coup&eacute;e en deux zones&nbsp;:
moniteur, utilisateur). <BR><BR>La diff&eacute;rence de vitesse entre
les E/S et l'unit&eacute; centrale (UC) devient flagrante&nbsp;: les
p&eacute;riph&eacute;riques sont alors dot&eacute;s de circuits
autonomes leur permettant de faire certains traitements sans le
secours de l'UC. Ces circuits sont parfois des ordinateurs plus
petits (dont le co&ucirc;t du temps de calcul est plus faible).<!--TOC subsection <FONT SIZE=5>VLSI et Multiprogrammation 1965-80</FONT>--></FONT></P>
<H3><FONT SIZE=5>2.1.3&nbsp;&nbsp; VLSI et Multiprogrammation 1965-80</FONT></H3>
<P><!--SEC END --><FONT SIZE=5>Circuits int&eacute;gr&eacute;s <FONT FACE="symbol">&frac34;&reg;</FONT>
moindre co&ucirc;t de fabrication<BR><FONT FACE="symbol">&frac34;&reg;</FONT>
&eacute;volution rapide des mod&egrave;les <BR><FONT FACE="symbol">&frac34;&reg;</FONT>
vente aux entreprises <BR>IBM lance l'id&eacute;e d'un syst&egrave;me
unique adapt&eacute; &agrave; plusieurs machines&nbsp;: OS/360.
<BR><BR></FONT><EM><FONT SIZE=5>Arriv&eacute;e des disques
magn&eacute;tiques.</FONT></EM><FONT SIZE=5> Apparait le principe de
multiprogrammation, les entr&eacute;es-sorties sur disque &eacute;tant
effectu&eacute;es de fa&ccedil;on asynchrone avec des calculs sur
l'unit&eacute; centrale (parall&egrave;lisation).<BR><BR><B>Multiprogrammation</B>&nbsp;:
plusieurs programmes sont en m&ecirc;me temps en m&eacute;moire et
sur le disque, si le programme en cours d'ex&eacute;cution demande
une op&eacute;ration d'entr&eacute;e-sortie alors un autre programme
est ex&eacute;cut&eacute; pendant que se d&eacute;roule l'op&eacute;ration.<!--TOC subsection <FONT SIZE=5>UNIX</FONT>-->
</FONT>
</P>
<H3><FONT SIZE=5>2.1.4&nbsp;&nbsp; UNIX</FONT></H3>
<UL>
	<LI><P STYLE="margin-bottom: 0cm"><!--SEC END --><FONT SIZE=5>1969
	Ken Thompson, Dennis Ritchie </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>1971 + Brian
	Kernighan </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>1973 C </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>1984 100000 cpu /UNIX
	</FONT>
	</P>
	<LI><P><FONT SIZE=5>1993 UNIX est le syst&egrave;me de r&eacute;f&eacute;rence
	</FONT>
	</P>
</UL>
<TABLE CELLPADDING=0 CELLSPACING=2>
	<TR>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>Avec de nombreux</FONT></P>
		</TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>standards</FONT></P>
		</TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>AES, SVID2, XPG2, XPG3, XPG4, POSIX.1
			OSF</FONT></P>
		</TD>
	</TR>
	<TR>
		<TD></TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>et des innovations comme&nbsp;:</FONT></P>
		</TD>
		<TD VALIGN=TOP></TD>
	</TR>
	<TR>
		<TD></TD>
		<TD></TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>les micro-noyaux, MACH, CHORUS, MASIX</FONT></P>
		</TD>
	</TR>
	<TR>
		<TD></TD>
		<TD></TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>Des copies &nbsp;: Windows NT par
			exemple ...</FONT></P>
		</TD>
	</TR>
</TABLE>
<P><FONT SIZE=5>Le succ&egrave;s d'UNIX sans doute parce que&nbsp;: </FONT>
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Ecrit dans un langage
	de haut niveau&nbsp;: C (C++, Objective C)&nbsp;; </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>une interface simple
	et puissante &nbsp;: les shells, qui fournissent des services de
	haut niveau&nbsp;; </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Des primitives
	puissantes qui permettent de simplifier l'&eacute;criture des
	programmes&nbsp;; </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Un syst&egrave;me de
	fichier hi&eacute;rarchique qui permet une maintenance simple et une
	impl&eacute;mentation efficace&nbsp;; </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Un format g&eacute;n&eacute;rique
	pour les fichiers, le flot d'octets qui simplifie l'&eacute;criture
	des programmes&nbsp;; </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Il fournit une
	interface simple aux p&eacute;riph&eacute;riques&nbsp;; </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Il est
	multi-utilisateurs et multi-t&acirc;ches&nbsp;; </FONT>
	</P>
	<LI><P><FONT SIZE=5>Il cache compl&egrave;tement l'architecture de
	la machine &agrave; l'utilisateur. </FONT>
	</P>
</UL>
<H3><FONT SIZE=5><!--TOC subsection <FONT SIZE=5>Des points forts </FONT>-->2.1.5&nbsp;&nbsp;
Des points forts </FONT>
</H3>
<UL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5><!--SEC END -->Syst&egrave;me
	n&eacute; dans le monde de la recherche int&eacute;gration de
	concepts avanc&eacute;s </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Diffusion ouverte
	acc&egrave;s aux sources </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Langage (de haut
	niveau ) compilation s&eacute;par&eacute;e, conditionnelle,
	param&eacute;trage, pr&eacute;compilation </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Enrichissement
	constant </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Ouverture
	(param&eacute;trabilit&eacute; du poste de travail) </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Souplesse des
	entr&eacute;es/sorties uniformit&eacute; </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Facilit&eacute;s de
	communication inter-syst&egrave;mes </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Communaut&eacute;s
	d'utilisateurs (/etc/groups) </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Langages de commandes
	(flexibles et puissants) </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Aspect
	multi-utilisateurs connections de tout type de terminal,
	biblioth&egrave;ques, etc </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Parall&eacute;lisme
	multi-t&acirc;ches &nbsp;: &quot;scheduling&quot; par t&acirc;che
	communication entre t&acirc;ches multiprocesseurs </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Interface
	syst&egrave;me/applications appels syst&egrave;me, biblioth&egrave;que
	</FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>le syst&egrave;me de
	gestion de fichiers hi&eacute;rarchie </FONT>
	</P>
	<LI><P><FONT SIZE=5>Interfaces graphiques norm&eacute;es&nbsp;: X11.
	</FONT>
	</P>
</UL>
<H3><FONT SIZE=5><!--TOC subsection <FONT SIZE=5>Des points faibles</FONT>-->2.1.6&nbsp;&nbsp;
Des points faibles</FONT></H3>
<UL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5><!--SEC END -->S&eacute;curit&eacute;
	(pire encore en r&eacute;seau ) Am&eacute;lioration avec les A.C.L. </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Fragilit&eacute; du
	S.G.F. pertes de fichiers possible en cas de crash </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Gestion et rattrapage
	des interruptions pas de temps r&eacute;el (Q.N.X.). </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>M&eacute;canisme de
	cr&eacute;ation de processus lourd Am&eacute;lioration avec les
	threads. </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Une &eacute;dition de
	liens statique Am&eacute;lioration avec les librairies partag&eacute;es.
	</FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Rattrapage d'erreur
	du compilateur C standard peu ais&eacute; ! </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Co&ucirc;t en
	ressources </FONT>
	</P>
	<LI><P><FONT SIZE=5>Gestion <FONT FACE="symbol">&frac34;&reg;</FONT>
	verrous sur fichiers</FONT></P>
</UL>
<H2><FONT SIZE=5><!--TOC section <FONT SIZE=5>Structure générale des systèmes d'exploitation</FONT>-->2.2&nbsp;&nbsp;
Structure g&eacute;n&eacute;rale des syst&egrave;mes d'exploitation</FONT></H2>
<P><!--SEC END --><FONT SIZE=5>Un syst&egrave;me d'exploitation est
un programme qui sert d'interface entre un utilisateur et un
ordinateur. <BR><BR><BR><BR><BR>Un syst&egrave;me d'exploitation est
un ensemble de proc&eacute;dures manuelles et automatiques qui permet
&agrave; un groupe d'utilisateurs de partager efficacement un
ordinateur. </FONT><EM><FONT SIZE=5>Brinch Hansen.</FONT></EM><FONT SIZE=5>
<BR><BR><BR><BR><BR>Il est plus facile de d&eacute;finir un syst&egrave;me
d'exploitation par ce qu'il fait que par ce qu'il est. </FONT><EM><FONT SIZE=5>J.L.
Peterson.</FONT></EM><FONT SIZE=5> <BR><BR><BR><BR><BR>Un syst&egrave;me
d'exploitation est un ensemble de proc&eacute;dures coh&eacute;rentes
qui a pour but de g&eacute;rer la p&eacute;nurie de ressources. </FONT><EM><FONT SIZE=5>J-l.
Stehl&eacute; P. Hochard.</FONT></EM><FONT SIZE=5> <BR><BR><BR><BR><BR><BR><BR><BR><B>Quelques
syst&egrave;mes</B>&nbsp;: </FONT>
</P>
<DL>
	<DT><FONT SIZE=5>le batch</FONT></DT><DD>
	<FONT SIZE=5>Le traitement par lot (disparus). </FONT>
	</DD><DT>
	<FONT SIZE=5>interactifs</FONT></DT><DD>
	<FONT SIZE=5>Pour les utilisateurs (ce cher UNIX). </FONT>
	</DD><DT>
	<FONT SIZE=5>temps r&eacute;els</FONT></DT><DD>
	<FONT SIZE=5>Pour manipuler des situations physiques par des
	p&eacute;riph&eacute;riques (OS9 un petit fr&egrave;re fut&eacute;
	d'UNIX). </FONT>
	</DD><DT>
	<FONT SIZE=5>distribu&eacute;s</FONT></DT><DD>
	<FONT SIZE=5>UNIX?, les micros noyaux? l'avenir? </FONT>
	</DD><DT>
	<FONT SIZE=5>moniteurs transactionnels</FONT></DT><DD>
	<FONT SIZE=5>Ce sont des applications qui manipulent des objets &agrave;
	t&acirc;ches multiples comme les comptes dans une banque, des
	r&eacute;servations, etc </FONT>
	</DD><DT>
	<FONT SIZE=5>SE orient&eacute;s objets</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>Micro Noyaux. </FONT>
	</DD></DL>
<H3>
<FONT SIZE=5><!--TOC subsection <FONT SIZE=5>Les couches fonctionnelles</FONT>-->2.2.1&nbsp;&nbsp;
Les couches fonctionnelles</FONT></H3>
<P ALIGN=CENTER STYLE="margin-left: 1cm; margin-right: 1cm; border-top: none; border-bottom: 1.10pt double #808080; border-left: none; border-right: none; padding: 0cm">
<FONT SIZE=1 STYLE="font-size: 6pt"><!--SEC END --></FONT><BR><BR>
</P>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML001.gif" NAME="Image3" ALIGN=BOTTOM WIDTH=314 HEIGHT=329 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
2.1&nbsp;: Vue g&eacute;n&eacute;rale du syst&egrave;me</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="vue.general"></A><BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<P><FONT SIZE=5>Couches fonctionnelles&nbsp;: </FONT>
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Programmes
	utilisateurs </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Programmes
	d'application </FONT>&eacute;diteurs/tableurs/BD/CAO 
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Programmes syst&egrave;me
	</FONT>assembleurs/compilateurs/&eacute;diteurs de liens/chargeurs 
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>syst&egrave;me
	d'exploitation </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>langage machine </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>microprogramme </FONT>
	</P>
	<LI><P><FONT SIZE=5>machines physiques </FONT>
	</P>
</UL>
<H3><FONT SIZE=5><!--TOC subsection <FONT SIZE=5>L'architecture du système </FONT>-->2.2.2&nbsp;&nbsp;
L'architecture du syst&egrave;me </FONT>
</H3>
<P ALIGN=CENTER STYLE="margin-left: 1cm; margin-right: 1cm; border-top: none; border-bottom: 1.10pt double #808080; border-left: none; border-right: none; padding: 0cm">
<FONT SIZE=1 STYLE="font-size: 6pt"><!--SEC END --></FONT><BR><BR>
</P>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML002.gif" NAME="Image4" ALIGN=BOTTOM WIDTH=321 HEIGHT=290 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
2.2&nbsp;: Point de vue utilisateur</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="vue.utilisateur"></A><BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<P><FONT SIZE=5>L'architecture globale d'UNIX est une architecture
par couches (coquilles) successsives comme le montre la figure </FONT><A HREF="#vue.utilisateur"><FONT SIZE=5>2.2</FONT></A><FONT SIZE=5>.
Les utilisateure communiquent avec la couche la plus &eacute;volu&eacute;e
celle des applications. Le programmeur lui va pouvoir en fonction de
ces besoins utiliser des couches de plus en plus profondes.<BR>Chaque
couche est construite pour pouvoir &ecirc;tre utilis&eacute;e sans
connaitre les couches inf&eacute;rieures (ni leur fonctionnement, ni
leur interface). <BR>Cette hi&eacute;rarchie d'encapsulation permet
d'&eacute;crire des applications plus portables si elles sont &eacute;crites
dans les couches hautes. Pour des applications o&ugrave; le temps de
calcul prime devant la portabilit&eacute;, les couches basses seront
utilis&eacute;es.<BR><BR><!--TOC subsection <FONT SIZE=5>L'architecture du noyau</FONT>--></FONT><BR><BR>
</P>
<H3><FONT SIZE=5>2.2.3&nbsp;&nbsp; L'architecture du noyau</FONT></H3>
<P ALIGN=CENTER STYLE="margin-left: 1cm; margin-right: 1cm; border-top: none; border-bottom: 1.10pt double #808080; border-left: none; border-right: none; padding: 0cm">
<FONT SIZE=1 STYLE="font-size: 6pt"><!--SEC END --></FONT><BR><BR>
</P>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML003.gif" NAME="Image5" ALIGN=BOTTOM WIDTH=276 HEIGHT=324 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
2.3&nbsp;: Architecture du noyau</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="architecture.noyau"></A>
<BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<P><FONT SIZE=5>L'autre approche architecturale est l'architecture
interne du Noyau (kernel).noyau C'est &agrave; dire l'architecture du
programme qui va nous interfacer avec le mat&eacute;riel. Le but ici
est de simplifier la compr&eacute;hension et la fabrication du
syst&egrave;me. Nous cherchons donc ici &agrave; d&eacute;composer le
noyau en parties disjointes (qui sont concevables et programmables de
fa&ccedil;ons disjointes). La Figure </FONT><A HREF="#architecture.noyau"><FONT SIZE=5>2.3</FONT></A><FONT SIZE=5>
donne une id&eacute;e de ce que peut &ecirc;tre l'architecture
interne d'un noyau UNIX. Noter bien la position ext&eacute;rieure des
biblioth&egrave;ques biblioth&egrave;ques.<!--TOC chapter <FONT SIZE=5>Système de Gestion de Fichiers</FONT>--></FONT></P>
<H1><FONT SIZE=5>Chapitre&nbsp;3&nbsp;&nbsp; Syst&egrave;me de
Gestion de Fichiers</FONT></H1>
<P><!--SEC END --><FONT SIZE=5>Syst&egrave;me de Gestion de Fichiers
<BR><BR>Le syst&egrave;me de gestion de fichiers est un outil de
manipulation des fichiers et de la structure d'arborescence des
fichiers sur disque et a aussi le r&ocirc;le sous UNIX de conserver
toutes les informations dont la p&eacute;rennit&eacute; est
importante pour le syst&egrave;me. Ainsi tous les objets importants
du syst&egrave;me sont r&eacute;f&eacute;renc&eacute;s dans le
syst&egrave;me de fichiers (m&eacute;moire, terminaux, p&eacute;riph&eacute;riques
vari&eacute;s, etc).<BR>Il permet de plus une utilisation facile des
fichiers et g&egrave;re de fa&ccedil;on transparente les diff&eacute;rents
probl&egrave;mes d'acc&egrave;s aux supports de masse (partage,
d&eacute;bit, droits, etc).<!--TOC section <FONT SIZE=5>Le concept de fichier</FONT>--></FONT></P>
<H2><FONT SIZE=5>3.1&nbsp;&nbsp; Le concept de fichier</FONT></H2>
<P><!--SEC END --><FONT SIZE=5>fichier L'unit&eacute; logique de base
du S.G.F. <B>le fichier</B>. <BR>Le contenu est enti&egrave;rement
d&eacute;fini par le cr&eacute;ateur.<BR>Sur Unix les fichiers ne
sont pas typ&eacute;s.<BR><B>Un fichier Unix est une suite finie de
bytes (octets).<BR><BR>Mat&eacute;rialis&eacute; par une inode et des
blocs du disque.</B><BR>L'inode d&eacute;finit le fichier, soit
principalement les informations&nbsp;: </FONT>
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>le propri&eacute;taire
	et le groupe propri&eacute;taire, propri&eacute;taire groupe </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>les droits d'acc&egrave;s
	des diff&eacute;rents utilisateurs,droits </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>la taille, </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>la date de cr&eacute;ation,
	</FONT>
	</P>
	<LI><P><FONT SIZE=5>la localisation sur disque. </FONT>
	</P>
</UL>
<P><FONT SIZE=5>on trouvera sur d'autre syst&egrave;mes d'autres
structures d'information pour d&eacute;crire les fichiers.<BR><BR></FONT><EM><FONT SIZE=5>Un
nom est li&eacute; &agrave; un fichier (une r&eacute;f&eacute;rence
indique un fichier) mais un fichier n'est pas li&eacute; &agrave; une
r&eacute;f&eacute;rence, un fichier peut exister sans avoir de nom
dans l'arborescence.</FONT></EM><FONT SIZE=5>r&eacute;f&eacute;rence<!--TOC section <FONT SIZE=5> Fichiers ordinaires / Fichiers spéciaux.</FONT>--></FONT></P>
<H2><FONT SIZE=5>3.2&nbsp;&nbsp; Fichiers ordinaires / Fichiers
sp&eacute;ciaux.</FONT></H2>
<P><!--SEC END --><FONT SIZE=5>fichier!ordinairesfichier!sp&eacute;ciaux
On a deux grands types de fichiers sous Unix &nbsp;: </FONT>
</P>
<DL>
	<DT><FONT SIZE=5>les fichiers standards</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>que sont par exemple les fichiers texte, les
	ex&eacute;cutables, etc. C'est-&agrave;-dire tout ce qui est
	manipul&eacute; par les utilisateurs.</FONT></DD><DT>
	<FONT SIZE=5>Les fichiers sp&eacute;ciaux</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>p&eacute;riph&eacute;riques, m&eacute;moire etc, qui ne
	sont manipulables que par l'interm&eacute;diaire du syst&egrave;me. </FONT>
	</DD></DL>
<P>
<EM><FONT SIZE=5>Les catalogues</FONT></EM><FONT SIZE=5> sont des
fichiers sp&eacute;ciaux, il faut en effet pour les manipuler
physiquement faire appel au syst&egrave;me </FONT><A HREF="#note1" NAME="text1"><FONT SIZE=2><SUP>1</SUP></FONT></A><FONT SIZE=5>.<BR>Les
fichiers physiques dans le r&eacute;pertoire /dev <BR>fichier!physiques
</FONT>
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Character devices les
	terminaux (claviers, &eacute;crans) les imprimantes etc </FONT>
	</P>
	<LI><P><FONT SIZE=5>Block devices la m&eacute;moire les disques les
	bandes magn&eacute;tiques etc </FONT>
	</P>
</UL>
<P><FONT SIZE=5>Les fichiers &agrave; usages logiques et non
physiques </FONT>
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>liens symboliques </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>pseudo-terminaux </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>sockets </FONT>
	</P>
	<LI><P><FONT SIZE=5>tubes nomm&eacute;s Ce dernier type de fichiers
	sp&eacute;ciaux est utilis&eacute; pour servir d'interface entre
	disques, entre machines et simuler&nbsp;: des terminaux, des lignes
	de communication, etc. </FONT>
	</P>
</UL>
<H3><FONT SIZE=5><!--TOC subsection <FONT SIZE=5>Les catalogues (historique)</FONT>-->3.2.1&nbsp;&nbsp;
Les catalogues (historique)</FONT></H3>
<P><!--SEC END --><FONT SIZE=5>Les arborescences de fichiers et de
catalogues, organis&eacute;es comme un graphe acyclique </FONT><A HREF="#note2" NAME="text2"><FONT SIZE=2><SUP>2</SUP></FONT></A><FONT SIZE=5>,
apparaissent avec le projet MULTICS. Cette organisation logique du
disque a les avantages suivants&nbsp;:</FONT></P>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML004.gif" NAME="Image6" ALIGN=BOTTOM WIDTH=241 HEIGHT=200 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
3.1&nbsp;: l'arborescence MULTICS</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="chapitre2.arbo1"></A><BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE><FONT SIZE=5>Une racine, un acc&egrave;s absolu ais&eacute;.<BR>Une
structure dynamique.<BR>Une grande puissance d'expression.<BR>Un
graphe acyclique.</FONT></BLOCKQUOTE>
<P><FONT SIZE=5>L'organisation est arborescente avec quelques
connections suppl&eacute;mentaires (liens multiples sur un m&ecirc;me
fichier) qui en font un graphe. Mais ce graphe doit rester acyclique,
pour les raisons suivantes&nbsp;:<BR>L'ensemble des algorithmes
simples utilisables sur des graphe acycliques comme le parcours, la
v&eacute;rification des fichiers libres, etc. deviennent beaucoup
plus difficiles &agrave; &eacute;crire pour des graphes admettant des
cycles.<BR>Des algorithmes de ramasse-miettes doivent &ecirc;tre
utilis&eacute;s pour savoir si certains objets sont utilis&eacute;s
on non et pour r&eacute;cuperer les inodes ou blocs perdus apr&egrave;s
un crash.<BR>Tous les algorithmes de d&eacute;tection dans un graphe
quelconque ont une complexit&eacute; beaucoup plus grande que ceux
qui peuvent profiter de l'acyclicit&eacute; du graphe.<BR>Sous Unix
nous sommes assur&eacute;s que le graphe est acyclique car il est
interdit d'avoir plusieurs r&eacute;f&eacute;rences pour un m&ecirc;me
catalogue (sauf la r&eacute;f&eacute;rence sp&eacute;ciale &quot;</FONT><TT><FONT SIZE=5>..</FONT></TT><FONT SIZE=5>&quot;
).<BR><B>Sous UNIX c'est un graphe acyclique !</B> <!--TOC section <FONT SIZE=5>Les inodes</FONT>--></FONT></P>
<H2><FONT SIZE=5>3.3&nbsp;&nbsp; Les inodes</FONT></H2>
<P><!--SEC END --><FONT SIZE=5>inodesfichiers!inodes L'inode est le
centre de tous les &eacute;changes entre le disque et la m&eacute;moire.
L'inode est la structure qui contient toutes les informations sur un
fichier donn&eacute; &agrave; l'exception de sa r&eacute;f&eacute;rence,
dans l'arborescence.<BR>Les informations stock&eacute;es dans une
inode disque sont&nbsp;: </FONT>
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>utilisateur
	propri&eacute;taire propri&eacute;taire </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>groupe
	propri&eacute;tairegroupe </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>type de fichier </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>droits d'acc&egrave;s
	</FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>date de dernier acc&egrave;s
	</FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>date de derni&egrave;re
	modification </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>date de derni&egrave;re
	modification de l'inode </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>taille du fichier </FONT>
	</P>
	<LI><P><FONT SIZE=5>adresses des blocs-disque contenant le fichier. </FONT>
	</P>
</UL>
<P><FONT SIZE=5>Dans une inode en m&eacute;moire (fichier en cours
d'utilisation par un processus) on trouve d'autres informations
suppl&eacute;mentaires&nbsp;:<BR>le statut de l'inode </FONT>
</P>
<BLOCKQUOTE><FONT SIZE=5>{ locked,<BR>waiting P<BR>inode &agrave;
&eacute;crire,<BR>fichier &agrave; &eacute;crire,<BR>le fichier est
un point de montage<BR>} </FONT>
</BLOCKQUOTE>
<P><FONT SIZE=5>Et deux valeurs qui permettent de localiser l'inode
sur un des disques logiques&nbsp;: </FONT>
</P>
<BLOCKQUOTE><FONT SIZE=5>Num&eacute;ro du disque logique<BR>Num&eacute;ro
de l'inode dans le disque </FONT>
</BLOCKQUOTE>
<P><FONT SIZE=5>cette information est inutile sur le disque (on a une
bijection entre la position de l'inode sur disque et le num&eacute;ro
d'inode).<BR>On trouve aussi d'autres types d'informations comme
l'acc&egrave;s &agrave; la table des verrous ou bien des informations
sur les disques &agrave; distance dans les points de montage.<!--TOC section <FONT SIZE=5>Organisation des disques System V</FONT>-->
</FONT>
</P>
<H2><FONT SIZE=5>3.4&nbsp;&nbsp; Organisation des disques System V</FONT></H2>
<P><!--SEC END --><FONT SIZE=5>L'organisation disque d&eacute;crite
sur la figure </FONT><A HREF="#sdf.DisqueDur"><FONT SIZE=5>3.2</FONT></A><FONT SIZE=5>
est la plus simple que l'on peut trouver de nos jours sous UNIX, il
en existe d'autres (cf. section </FONT><A HREF="#ffs"><FONT SIZE=5>3.8</FONT></A><FONT SIZE=5>)
o&ugrave; l'on peut en particulier placer un m&ecirc;me disque
logique sur plusieurs disques physiques (dangereux), certaines o&ugrave;
les blocs sont fragmentables, etc.</FONT></P>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML005.gif" NAME="Image7" ALIGN=BOTTOM WIDTH=320 HEIGHT=290 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
3.2&nbsp;: Organisation des blocs et des inodes (SYS V)</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="sdf.DisqueDur"></A><BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<DL>
	<DT><FONT SIZE=5>Boot bloc</FONT></DT><DD>
	<FONT SIZE=5>utilis&eacute; au chargement du syst&egrave;me.boot
	bloc </FONT>
	</DD><DT>
	<FONT SIZE=5>Super Bloc</FONT></DT><DD>
	<FONT SIZE=5>il contient toutes les informations g&eacute;n&eacute;rales
	sur le disque logique.super bloc </FONT>
	</DD><DT>
	<FONT SIZE=5>Inode list</FONT></DT><DD>
	<FONT SIZE=5>Table des inodes. </FONT>
	</DD><DT>
	<FONT SIZE=5>blocs</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>les blocs de donn&eacute;es chain&eacute;s &agrave; la
	cr&eacute;ation du disque (</FONT><TT><FONT SIZE=5>mkfs</FONT></TT><FONT SIZE=5>).
	</FONT>
	</DD></DL>
<P>
<FONT SIZE=5>Les blocs de donn&eacute;es ne sont pas fragmentables
sous Syst&egrave;me V.<!--TOC section <FONT SIZE=5>Adressage des blocs dans les inodes</FONT>-->
</FONT>
</P>
<H2><FONT SIZE=5>3.5&nbsp;&nbsp; Adressage des blocs dans les inodes</FONT></H2>
<P STYLE="margin-bottom: 0cm"><!--SEC END --><FONT SIZE=5>Le syst&egrave;me
d'adressage des blocs dans les inodes (syst&egrave;me V) consiste en
13 adresses de blocs. Les dix premi&egrave;res adresses sont des
adresses qui pointent directement sur les blocs de donn&eacute;es du
fichier. Les autres sont des adresses indirectes vers des blocs de
donn&eacute;es contenant des adresses. La figure </FONT><A HREF="#inodes"><FONT SIZE=5>3.3</FONT></A><FONT SIZE=5>
nous montre les trois niveaux d'indirection. L'int&eacute;r&ecirc;t
de cette repr&eacute;sentation est d'&eacute;conomiser sur la taille
des inodes tout en permettant un acc&egrave;s rapide au petits
fichiers (la majorit&eacute; des fichiers sont petits). Mais en
laissant la possibilit&eacute; de cr&eacute;er de tr&egrave;s gros
fichiers&nbsp;:</FONT></P>
<P ALIGN=CENTER STYLE="margin-bottom: 0cm"><FONT SIZE=5>10+256+(256 &times;
256 )+( 256 &times; 256 &times; 256)</FONT></P>
<P><FONT SIZE=5>blocs disques. </FONT>
</P>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML006.gif" NAME="Image8" ALIGN=BOTTOM WIDTH=308 HEIGHT=397 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
3.3&nbsp;: Adressage direct et indirect des inode UNIX</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="inodes"></A><BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<P><FONT SIZE=5>inodes<!--TOC section <FONT SIZE=5>Allocation des inodes d'un disque</FONT>-->
</FONT>
</P>
<H2><FONT SIZE=5>3.6&nbsp;&nbsp; Allocation des inodes d'un disque</FONT></H2>
<P><!--SEC END --><FONT SIZE=5>inodes L'allocation des inodes est
r&eacute;alis&eacute;e en recherchant dans la zone des inodes du
disque une inode libre. Pour acc&eacute;l&eacute;rer cette recherche
: un tampon d'inodes libres est g&eacute;r&eacute; dans le SuperBloc,
de plus l'indice de la premi&egrave;re inode libre est gard&eacute;
en r&eacute;f&eacute;rence dans le SuperBloc afin de red&eacute;marrer
la recherche qu'&agrave; partir de la premi&egrave;re inode
r&eacute;ellement libre. </FONT>
</P>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML007.gif" NAME="Image9" ALIGN=BOTTOM WIDTH=399 HEIGHT=107 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
3.4&nbsp;: Inodes libres dans le SuperBloc.</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="ialloc1"></A><BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML008.gif" NAME="Image10" ALIGN=BOTTOM WIDTH=399 HEIGHT=107 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
3.5&nbsp;: Allocation d'une inode.</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="ialloc2"></A><BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML009.gif" NAME="Image11" ALIGN=BOTTOM WIDTH=398 HEIGHT=193 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
3.6&nbsp;: Si le SuperBloc est vide. </FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="ialloc3"></A><BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML010.gif" NAME="Image12" ALIGN=BOTTOM WIDTH=398 HEIGHT=92 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
3.7&nbsp;: Lib&eacute;ration d'une inode avec le SuperBloc plein.</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="ialloc4"></A><BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML011.gif" NAME="Image13" ALIGN=BOTTOM WIDTH=398 HEIGHT=92 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
3.8&nbsp;: Le num&eacute;ro d'inode inf&eacute;rieur au num&eacute;ro
de r&eacute;f&eacute;rence.</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="ialloc5"></A><BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML012.gif" NAME="Image14" ALIGN=BOTTOM WIDTH=398 HEIGHT=92 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
3.9&nbsp;: Le num&eacute;ro d'inode sup&eacute;rieur au num&eacute;ro
de r&eacute;f&eacute;rence.</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="ialloc6"></A><BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML013.gif" NAME="Image15" ALIGN=BOTTOM WIDTH=474 HEIGHT=626 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
3.10&nbsp;: Faille de l'algorithme d'allocation.</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="faille"></A><BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<P><FONT SIZE=5>Mais ce syst&egrave;me a une faille qu'il faut
pr&eacute;voir dans l'&eacute;criture dans l'algorithme ialloc
d'allocation d'inode, cette faille est d&eacute;crite dans la
Figure&nbsp;</FONT><A HREF="#faille"><FONT SIZE=5>3.10<!--TOC section <FONT SIZE=5>Allocation des blocs-disque</FONT>--></FONT></A><FONT SIZE=5>
</FONT>
</P>
<H2><FONT SIZE=5>3.7&nbsp;&nbsp; Allocation des blocs-disque</FONT></H2>
<P><!--SEC END --><FONT SIZE=5>L'algorithme utilis&eacute; pour g&eacute;rer
l'allocation des inodes s'appuie sur le fait que l'on peut tester si
une inode est libre ou non en regardant son contenu. Ceci n'est plus
vrai pour les blocs. La solution est de cha&icirc;ner les blocs. Ce
cha&icirc;nage est r&eacute;alis&eacute; par blocs d'adresses pour
acc&eacute;l&eacute;rer les acc&egrave;s et profiter au maximum du
buffer cache. Il existe donc un bloc d'adresses dans le super bloc
qui sert de zone de travail pour l'allocateur de blocs. L'utilisation
de ce bloc et le m&eacute;canisme d'allocation sont d&eacute;crits
dans les Figures </FONT><A HREF="#balloc1"><FONT SIZE=5>3.11</FONT></A><FONT SIZE=5>
&agrave; </FONT><A HREF="#balloc6"><FONT SIZE=5>3.16</FONT></A></P>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML014.gif" NAME="Image16" ALIGN=BOTTOM WIDTH=400 HEIGHT=298 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
3.11&nbsp;: Liste chain&eacute;e de blocs.</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="balloc1"></A><BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML015.gif" NAME="Image17" ALIGN=BOTTOM WIDTH=400 HEIGHT=142 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
3.12&nbsp;: Etat initial du SuperBloc.</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="balloc2"></A><BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML016.gif" NAME="Image18" ALIGN=BOTTOM WIDTH=400 HEIGHT=141 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
3.13&nbsp;: Lib&eacute;ration du bloc 978.</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="balloc3"></A><BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML017.gif" NAME="Image19" ALIGN=BOTTOM WIDTH=400 HEIGHT=142 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
3.14&nbsp;: Allocation du bloc 978.</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="balloc4"></A><BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML018.gif" NAME="Image20" ALIGN=BOTTOM WIDTH=400 HEIGHT=156 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
3.15&nbsp;: Allocation du bloc 109.</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="balloc5"></A><BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML019.gif" NAME="Image21" ALIGN=BOTTOM WIDTH=400 HEIGHT=142 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
3.16&nbsp;: Lib&eacute;ration du bloc 612.</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="balloc6"></A><BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<H2><FONT SIZE=5><!--TOC section <FONT SIZE=5>Les systèmes de fichiers ffs/ufs de BSD</FONT>-->3.8&nbsp;&nbsp;
Les syst&egrave;mes de fichiers ffs/ufs de BSD</FONT></H2>
<P><A NAME="ffs"></A><!--SEC END --><FONT SIZE=5>ffs Les disques sous
BSD sont organis&eacute;s par groupes de cylindres et chacun de ces
groupes a la m&ecirc;me organisation que les disques logiques System
V, avec en plus une table de groupes de cylindres qui permet
d'organiser l'allocation des blocs de fa&ccedil;on &agrave; r&eacute;duire
le d&eacute;placement des t&ecirc;tes de lecture (ce qui augmente le
d&eacute;bit).<BR><BR>Quelques diff&eacute;rences :<BR><BR>Les blocs
de donn&eacute;es sont plus grands (4K ou 8K) mais
fragmentables.<BR><BR>Une inode contient 12 adresses directes, une
adresse indirecte et 2 adresses indirectes doubles.<BR><BR>Enfin, les
r&eacute;pertoires sont compos&eacute;s d'enregistrements de tailles
variables (le nom des liens est en effet limit&eacute; &agrave; 14 en
System V, et &agrave; 255 en BSD, c.f. entr&eacute;es-sorties sur
r&eacute;pertoires), la norme POSIX fixe la taille maximum des liens
&agrave; 255 (MAXNAMLEN).<!--BEGIN NOTES chapter--></FONT></P>
<HR WIDTH=215 ALIGN=CENTER SIZE=2>
<DL>
	<DT><A HREF="#text1" NAME="note1"><FONT SIZE=5>1</FONT></A></DT><DD>
	<FONT SIZE=5>les r&eacute;pertoires restent accessibles en lecture
	comme des fichiers ordinaires (essayez de faire <TT>cat &quot;.&quot;</TT>),
	mais l'acc&egrave;s en &eacute;criture est contraint, pour assurer
	la structure arborescente. </FONT>
	</DD><DT>
	<A HREF="#text2" NAME="note2"><FONT SIZE=5>2</FONT></A></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>Ce n'est pas un arbre car un fichier peut avoir
	plusieurs r&eacute;f&eacute;rences </FONT>
	</DD></DL>
<H1>
<FONT SIZE=5><!--END NOTES--><!--TOC chapter <FONT SIZE=5>Le Buffer Cache</FONT>-->Chapitre&nbsp;4&nbsp;&nbsp;
Le Buffer Cache</FONT></H1>
<H2><FONT SIZE=5><!--SEC END --><!--TOC section <FONT SIZE=5>Introduction au buffer cache</FONT>-->4.1&nbsp;&nbsp;
Introduction au buffer cache</FONT></H2>
<P><!--SEC END --><FONT SIZE=5>buffer cache Le buffer cache est un
ensemble de structures de donn&eacute;es et d'algorithmes qui
permettent de minimiser le nombre des acc&egrave;s disque.<BR>Ce qui
est tr&egrave;s important car les disques sont tr&egrave;s lents
relativement au CPU et un noyau qui se chargerait de toutes les
entr&eacute;es/sorties serait d'une grande lenteur et l'unit&eacute;
de traitement ne serait effectivement utilis&eacute;e qu'&agrave; un
faible pourcentage (voir Historique). <BR>Deux id&eacute;es pour
r&eacute;duire le nombre des acc&egrave;s disques&nbsp;: </FONT>
</P>
<OL>
	<LI><P><FONT SIZE=5>bufferiser les diff&eacute;rentes commandes
	d'&eacute;criture et de lecture de fa&ccedil;on &agrave; faire un
	acc&egrave;s disque uniquement pour une quantit&eacute; de donn&eacute;es
	de taille raisonnable (un bloc disque).bufferiser</FONT></P>
	<LI><P><FONT SIZE=5>Eviter des &eacute;critures inutiles quand les
	donn&eacute;es peuvent encore &ecirc;tre chang&eacute;es (&eacute;criture
	diff&eacute;r&eacute;es).</FONT></P>
</OL>
<H3><FONT SIZE=5><!--TOC subsection <FONT SIZE=5>Avantages et désavantages du buffer cache</FONT>-->4.1.1&nbsp;&nbsp;
Avantages et d&eacute;savantages du buffer cache</FONT></H3>
<UL>
	<LI><P><FONT SIZE=5><!--SEC END -->Un acc&egrave;s uniforme au
	disque. Le noyau n'a pas &agrave; conna&icirc;tre la raison de
	l'entr&eacute;e-sortie. Il copie les donn&eacute;es depuis et vers
	des tampons (que ce soient des donn&eacute;es, des inodes ou le
	superbloc). Ce m&eacute;canisme est modulaire et s'int&egrave;gre
	facilement &agrave; l'ensemble du syst&egrave;me qu'il rend plus
	facile &agrave; &eacute;crire.</FONT></P>
	<LI><P><FONT SIZE=5>Rend l'utilisation des entr&eacute;es-sorties
	plus simple pour l'utilisateur qui n'a pas &agrave; se soucier des
	probl&egrave;mes d'alignement, il rend les programmes portables sur
	d'autres UNIX </FONT><A HREF="#note3" NAME="text3"><FONT SIZE=2><SUP>1</SUP></FONT></A><FONT SIZE=5>.</FONT></P>
	<LI><P><FONT SIZE=5>Il r&eacute;duit le trafic disque et de ce fait
	augmente la capacit&eacute; du syst&egrave;me. Attention&nbsp;: le
	nombre de tampons ne doit pas trop r&eacute;duire la m&eacute;moire
	centrale utilisable.</FONT></P>
	<LI><P><FONT SIZE=5>L'impl&eacute;mentation du buffer cache prot&egrave;ge
	contre certaines &eacute;critures &quot;concurrentes&quot; </FONT>
	</P>
	<LI><P><FONT SIZE=5>L'&eacute;criture diff&eacute;r&eacute;e pose un
	probl&egrave;me dans le cas d'un crash du syst&egrave;me. En effet
	si votre machine s'arr&ecirc;te (coupure de courant) et que un (ou
	plusieurs) blocs sont marqu&eacute;s &quot;&agrave; &eacute;crire&quot;
	ils n'ont donc pas &eacute;t&eacute;s sauvegard&eacute;s
	physiquement. L'int&eacute;grit&eacute; des donn&eacute;es n'est
	donc pas assur&eacute;e en cas de crash.</FONT></P>
	<LI><P><FONT SIZE=5>Le buffer cache n&eacute;cessite que l'on
	effectue une recopie (interne &agrave; la m&eacute;moire, de la zone
	utilisateur au cache ou inversement) pour toute entr&eacute;e-sortie.
	Dans le cas de transferts nombreux ceci ralentit les entr&eacute;es-sorties
	. </FONT>
	</P>
</UL>
<H2><FONT SIZE=5><!--TOC section <FONT SIZE=5>Le buffer cache, structures de données.</FONT>-->4.2&nbsp;&nbsp;
Le buffer cache, structures de donn&eacute;es.</FONT></H2>
<P ALIGN=CENTER STYLE="margin-left: 1cm; margin-right: 1cm; border-top: none; border-bottom: 1.10pt double #808080; border-left: none; border-right: none; padding: 0cm">
<FONT SIZE=1 STYLE="font-size: 6pt"><!--SEC END --></FONT><BR><BR>
</P>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML020.gif" NAME="Image22" ALIGN=BOTTOM WIDTH=312 HEIGHT=160 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
4.1&nbsp;: Structure des ent&ecirc;tes de Bloc du Buffer Cache</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="buffercache.header"></A>
<BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<P><FONT SIZE=5>Le statut d'un bloc cache est une combinaison des
&eacute;tats suivants&nbsp;: </FONT>
</P>
<DL>
	<DT><FONT SIZE=5>verrouill&eacute;</FONT></DT><DD>
	<FONT SIZE=5>l'acc&egrave;s est reserv&eacute; &agrave; un
	processus. </FONT>
	</DD><DT>
	<FONT SIZE=5>valide</FONT></DT><DD>
	<FONT SIZE=5>(les donn&eacute;es contenues dans le bloc sont
	valides). </FONT>
	</DD><DT>
	<FONT SIZE=5>&quot;&agrave; &eacute;crire&quot;</FONT></DT><DD>
	<FONT SIZE=5>les donn&eacute;es du bloc doivent &ecirc;tre &eacute;crites
	sur disque avant de r&eacute;allouer le bloc ( c'est de l'&eacute;criture
	retard&eacute;e). </FONT>
	</DD><DT>
	<FONT SIZE=5>actif</FONT></DT><DD>
	<FONT SIZE=5>le noyau est en train d'&eacute;crire/lire le bloc sur
	le disque. </FONT>
	</DD><DT>
	<FONT SIZE=5>attendu</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>un processus attend la lib&eacute;ration du bloc. </FONT>
	</DD></DL>
<H3>
<FONT SIZE=5><!--TOC subsection <FONT SIZE=5>La liste doublement chaînée des blocs libres</FONT>-->4.2.1&nbsp;&nbsp;
La liste doublement cha&icirc;n&eacute;e des blocs libres</FONT></H3>
<P><FONT SIZE=5><!--SEC END -->Les tampons libres appartiennent
simultan&eacute;ment &agrave; deux listes doublement cha&icirc;n&eacute;es&nbsp;:
la liste des blocs libres et la hash-liste correspondant au dernier
bloc ayant &eacute;t&eacute; contenu dans ce tampon. </FONT>
</P>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML021.gif" NAME="Image23" ALIGN=BOTTOM WIDTH=320 HEIGHT=190 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
4.2&nbsp;: La liste des tampons libres.</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="buffercache.listes"></A>
<BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<P><FONT SIZE=5>L'insertion dans la liste des tampons libres se fait
en fin de liste, la suppression (allocation du tampon &agrave; un
bloc donn&eacute;) se fait en d&eacute;but de liste, ainsi le tampon
allou&eacute; est le plus vieux tampon lib&eacute;r&eacute;</FONT><A HREF="#note4" NAME="text4"><FONT SIZE=2><SUP>2</SUP></FONT></A><FONT SIZE=5>.
Ceci permet une r&eacute;ponse imm&eacute;diate si le bloc
correspondant est r&eacute;utilis&eacute; avant que le tampon ne soit
allou&eacute; &agrave; un autre bloc.<!--TOC section <FONT SIZE=5>L'algorithme de la primitive </FONT><FONT SIZE=5><TT>getblk</TT></FONT>--></FONT></P>
<H2>4.3&nbsp;&nbsp; L'algorithme de la primitive <TT>getblk</TT></H2>
<PRE><!--SEC END -->
<FONT SIZE=5>Algorithme getblk (allocation d'un tampon)</FONT>
<FONT SIZE=5>entree : # disque logique , # de block</FONT>
<FONT SIZE=5>sortie : un tampon verrouille utilisable pour manipuler bloc</FONT>
<FONT SIZE=5>{</FONT>
<FONT SIZE=5>    while (tampon non trouve)</FONT>
<FONT SIZE=5>    {</FONT>
<FONT SIZE=5>        if (tampon dans sa hash liste)</FONT>
<FONT SIZE=5>        {</FONT>
<FONT SIZE=5>                if (tampon actif )  </FONT>
<FONT SIZE=5>                { </FONT>
<FONT SIZE=5>       [5]          sleep attente de la liberation du tampon</FONT>
<FONT SIZE=5>                    continuer</FONT>
<FONT SIZE=5>                }</FONT>
<FONT SIZE=5>       [1]      verrouiller le tampon      </FONT>
<FONT SIZE=5>                retirer le tampon de la liste des tampons libres</FONT>
<FONT SIZE=5>                retourner le tampon</FONT>
<FONT SIZE=5>        }</FONT>
<FONT SIZE=5>        else  /* n'est pas dans la hash liste */</FONT>
<FONT SIZE=5>        {</FONT>
<FONT SIZE=5>                if (aucun tampon libre ) </FONT>
<FONT SIZE=5>                {</FONT>
<FONT SIZE=5>        [4]         sleep attente de la liberation d'un tampon </FONT>
<FONT SIZE=5>                    continuer</FONT>
<FONT SIZE=5>                }</FONT>
<FONT SIZE=5>                retirer le tampon de la liste libre</FONT>
<FONT SIZE=5>        [3]     if (le tampon est a ecrire)  </FONT>
<FONT SIZE=5>                {</FONT>
<FONT SIZE=5>                    lancer la sauvegarde sur disque</FONT>
<FONT SIZE=5>                    continuer</FONT>
<FONT SIZE=5>                }</FONT>
<FONT SIZE=5>        [2]     retirer le buffer de son ancienne liste </FONT>
<FONT SIZE=5>                 de hashage, le placer sur la nouvelle</FONT>
<FONT SIZE=5>                retourner le tampon</FONT>
<FONT SIZE=5>        }</FONT>
<FONT SIZE=5>    }</FONT>
<FONT SIZE=5>}</FONT></PRE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML022.gif" NAME="Image24" ALIGN=BOTTOM WIDTH=400 HEIGHT=208 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
4.3&nbsp;: Etat du buffer cache avant les sc&eacute;narios 1, 2 et 3.</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="getblk1"></A><BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML023.gif" NAME="Image25" ALIGN=BOTTOM WIDTH=401 HEIGHT=194 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
4.4&nbsp;: Sc&eacute;nario 1- Demande d'un tampon pour le bloc-disque
4.</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="getblk1b"></A><BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML024.gif" NAME="Image26" ALIGN=BOTTOM WIDTH=400 HEIGHT=195 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
4.5&nbsp;: Sc&eacute;nario 2- Demande d'un tampon pour le bloc-disque
41.</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="getblk2b"></A><BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML025.gif" NAME="Image27" ALIGN=BOTTOM WIDTH=400 HEIGHT=185 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
4.6&nbsp;: Sc&eacute;nario 3- Demande pour le bloc 18 (3 &amp; 5
marqu&eacute;s &agrave; &eacute;crire).</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="getblk3b"></A><BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML026.gif" NAME="Image28" ALIGN=BOTTOM WIDTH=401 HEIGHT=194 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
4.7&nbsp;: Sc&eacute;nario 4- Plus de blocs libres.</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="getblk4"></A><BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML027.gif" NAME="Image29" ALIGN=BOTTOM WIDTH=400 HEIGHT=208 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
4.8&nbsp;: Sc&eacute;nario 5- Demande pour le bloc 17 qui est d&eacute;j&agrave;
utilis&eacute;.</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="getblk5"></A><BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<P STYLE="margin-left: 6.4cm; margin-right: 6.4cm; border-top: none; border-bottom: 1.10pt double #808080; border-left: none; border-right: none; padding: 0cm">
<FONT SIZE=1 STYLE="font-size: 6pt"><!--BEGIN NOTES chapter--></FONT><BR><BR>
</P>
<DL>
	<DT><A HREF="#text3" NAME="note3"><FONT SIZE=5>1</FONT></A></DT><DD>
	<FONT SIZE=5>Les probl&egrave;mes d'alignement existent toujours
	quand on transf&egrave;re des donn&eacute;es, cf. protocoles XDR,RPC
	</FONT>
	</DD><DT>
	<A HREF="#text4" NAME="note4"><FONT SIZE=5>2</FONT></A></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>ordre fifo&nbsp;: first in first out </FONT>
	</DD></DL>
<H1>
<FONT SIZE=5><!--END NOTES--><!--TOC chapter <FONT SIZE=5>La bibliothèque standard</FONT>-->Chapitre&nbsp;5&nbsp;&nbsp;
La biblioth&egrave;que standard</FONT></H1>
<H2><FONT SIZE=5><!--SEC END --><!--TOC section <FONT SIZE=5>Les descripteurs de fichiers.</FONT>-->5.1&nbsp;&nbsp;
Les descripteurs de fichiers.</FONT></H2>
<P STYLE="margin-bottom: 0cm"><!--SEC END --><FONT SIZE=5>Le fichier
d'inclusion </FONT><CODE><TT><FONT SIZE=5>&lt;stdio.h&gt;</FONT></TT></CODE><FONT SIZE=5>
contient la d&eacute;finition du type </FONT><TT><FONT SIZE=5>FILE</FONT></TT><FONT SIZE=5>.
stdio.h@</FONT><TT><FONT SIZE=5>stdio.h</FONT></TT><FONT SIZE=5> Ce
type est une structure contenant les informations n&eacute;cessaires
au syst&egrave;me pour la manipulation d'un fichier ouvert. Le
contenu exact de cette structure peut varier d'un syst&egrave;me &agrave;
l'autre (UNIX, VMS, autre).<BR><BR>Toutes les fonctions d'E/S
utilisent en premier argument un pointeur sur une telle structure&nbsp;:
</FONT><TT><FONT SIZE=5>FILE *</FONT></TT><FONT SIZE=5>. FILE@</FONT><TT><FONT SIZE=5>FILE</FONT></TT><FONT SIZE=5>
Le r&ocirc;le de cet argument est d'indiquer le fichier sur lequel on
doit effectuer l'op&eacute;ration d'&eacute;criture ou de
lecture.<BR><BR>Pour pouvoir utiliser une fonction d'entr&eacute;e-sortie
il faut donc avoir une valeur pour ce premier argument, c'est le r&ocirc;le
de la fonction </FONT><TT><FONT SIZE=5>fopen</FONT></TT><FONT SIZE=5>
de nous fournir ce pointeur en &quot;ouvrant&quot; le fichier.
stdlib!printf@</FONT><TT><FONT SIZE=5>printf</FONT></TT><FONT SIZE=5>
stdlib!scanf@</FONT><TT><FONT SIZE=5>scanf</FONT></TT><FONT SIZE=5>
Les deux fonctions </FONT><TT><FONT SIZE=5>printf</FONT></TT><FONT SIZE=5>
et </FONT><TT><FONT SIZE=5>scanf</FONT></TT><FONT SIZE=5> sont des
synonymes de </FONT>
</P>
<P ALIGN=CENTER STYLE="margin-bottom: 0cm"><TT><FONT SIZE=5>fprintf(stdout,
format, ...)</FONT></TT></P>
<P STYLE="margin-bottom: 0cm"><FONT SIZE=5><BR>et</FONT></P>
<P ALIGN=CENTER STYLE="margin-bottom: 0cm"><TT><FONT SIZE=5>fscanf(stdin,
format, ...)</FONT></TT></P>
<P><FONT SIZE=5><BR>o&ugrave; </FONT><TT><FONT SIZE=5>stdout</FONT></TT><FONT SIZE=5>
et </FONT><TT><FONT SIZE=5>stdin</FONT></TT><FONT SIZE=5> sont des
expressions de type </FONT><TT><FONT SIZE=5>FILE *</FONT></TT><FONT SIZE=5>
d&eacute;finies sous forme de macro-d&eacute;finitions dans le
fichier </FONT><TT><CODE><FONT SIZE=5>&lt;stdio.h&gt;</FONT></CODE></TT><BR><BR><FONT SIZE=5>.
Avec POSIX ce sont effectivement des fonctions.<BR><BR>Sous UNIX les
fichiers ouverts par un processus le restent dans ses fils. Par
exemple le shell a en g&eacute;n&eacute;ral trois fichiers ouverts&nbsp;:
</FONT>
</P>
<DL>
	<DT><TT><FONT SIZE=5>stdin</FONT></TT></DT><DD>
	<FONT SIZE=5>le terminal ouvert en lecture. stdlib!stdin@</FONT><TT><FONT SIZE=5>stdin</FONT></TT><FONT SIZE=5>
	</FONT>
	</DD><DT>
	<TT><FONT SIZE=5>stdout</FONT></TT></DT><DD>
	<FONT SIZE=5>le terminal ouvert en &eacute;criture.
	stdlib!stdout@</FONT><TT><FONT SIZE=5>stdout</FONT></TT><FONT SIZE=5>
	</FONT>
	</DD><DT>
	<TT><FONT SIZE=5>stderr</FONT></TT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>le terminal ouvert en &eacute;criture, et en mode non
	bufferis&eacute;. stdlib!stderr@</FONT><TT><FONT SIZE=5>stderr</FONT></TT><FONT SIZE=5>
	</FONT>
	</DD></DL>
<P>
<FONT SIZE=5>ainsi si l'ex&eacute;cution d'un programme C est
r&eacute;alis&eacute;e &agrave; partir du shell le programme C a d&eacute;j&agrave;
ces trois descripteurs de fichiers utilisables. C'est pourquoi il est
en g&eacute;n&eacute;ral possible d'utiliser </FONT><TT><FONT SIZE=5>printf</FONT></TT><FONT SIZE=5>
et </FONT><TT><FONT SIZE=5>scanf</FONT></TT><FONT SIZE=5> sans ouvrir
pr&eacute;alablement de fichiers. Mais si l'entr&eacute;e standard
n'est pas ouverte, </FONT><TT><FONT SIZE=5>scanf</FONT></TT><FONT SIZE=5>
&eacute;choue&nbsp;: </FONT>
</P>
<PRE>
<FONT SIZE=5><B>#include &lt;stdio.h&gt;</B></FONT>
<FONT SIZE=5><B>main()</B></FONT>
<FONT SIZE=5><B>{</B></FONT>
<FONT SIZE=5><B>    int i;</B></FONT>

<FONT SIZE=5><B>    if (scanf(&quot;%d&quot;, &amp;i) == EOF)</B></FONT>
<FONT SIZE=5><B>    {</B></FONT>
<FONT SIZE=5><B>        printf(&quot;l\'entree standard est fermee\n&quot;);</B></FONT>
<FONT SIZE=5><B>    }</B></FONT>
<FONT SIZE=5><B>    else</B></FONT>
<FONT SIZE=5><B>    {</B></FONT>
<FONT SIZE=5><B>        printf(&quot;l\'entree standard est ouverte\n&quot;);</B></FONT>
<FONT SIZE=5><B>    }</B></FONT>
<FONT SIZE=5><B>}</B></FONT></PRE><P>
<FONT SIZE=5>Compil&eacute;,(</FONT><TT><FONT SIZE=5>a.out</FONT></TT><FONT SIZE=5>),
cela donne les deux sorties suivantes&nbsp;: </FONT>
</P>
<PRE>
<FONT SIZE=5><B>$ a.out </B></FONT>
<FONT SIZE=5><B>l'entree standard est ouverte</B></FONT>
<FONT SIZE=5><B>$ a.out &lt;&amp;- # fermeture de l'entree standard en ksh</B></FONT>
<FONT SIZE=5><B>l'entree standard est fermee</B></FONT></PRE><P>
<FONT SIZE=5>De m&ecirc;me </FONT><TT><FONT SIZE=5>printf</FONT></TT><FONT SIZE=5>
&eacute;choue si la sortie standard est ferm&eacute;e.<!--TOC subsection <FONT SIZE=5>Ouverture d'un fichier</FONT>-->
</FONT>
</P>
<H3><FONT SIZE=5>5.1.1&nbsp;&nbsp; Ouverture d'un fichier</FONT></H3>
<P><!--SEC END --><FONT SIZE=5>La fonction de la biblioth&egrave;que
standard </FONT><TT><FONT SIZE=5>fopen</FONT></TT><FONT SIZE=5>
permet d'ouvrir un fichier ou de le cr&eacute;er. </FONT>
</P>
<PRE>
<FONT SIZE=5><B>#include &lt;stdio.h&gt;</B></FONT>
<FONT SIZE=5><B>FILE  *fopen(const char *filename,</B></FONT>
<FONT SIZE=5><B>             const char *type);</B></FONT></PRE><P>
<FONT SIZE=5>stdlib!fopen@</FONT><TT><FONT SIZE=5>fopen</FONT></TT><FONT SIZE=5>
</FONT><TT><B><FONT SIZE=5>filename</FONT></B></TT><FONT SIZE=5> est
une r&eacute;f&eacute;rence absolue ou relative du fichier &agrave;
ouvrir; si le fichier n'existe pas alors il est cr&eacute;&eacute; <I><FONT COLOR="#800000">si
et seulement si</FONT></I> l'utilisateur du processus a
l'autorisation d'&eacute;crire dans le r&eacute;pertoire.<BR></FONT><TT><B><FONT SIZE=5>type</FONT></B></TT><FONT SIZE=5>
est une des cha&icirc;nes suivantes&nbsp;: </FONT>
</P>
<DL>
	<DT><FONT SIZE=5>&quot;r&quot;</FONT></DT><DD>
	<FONT SIZE=5>ouverture en lecture au d&eacute;but du fichier </FONT>
	</DD><DT>
	<FONT SIZE=5>&quot;w&quot;</FONT></DT><DD>
	<FONT SIZE=5>ouverture en &eacute;criture au d&eacute;but du fichier
	avec &eacute;crasement du fichier si il existe (le fichier est vid&eacute;
	de son contenu &agrave; l'ouverture). </FONT>
	</DD><DT>
	<FONT SIZE=5>&quot;a&quot;</FONT></DT><DD>
	<FONT SIZE=5>ouverture en &eacute;criture &agrave; la fin du fichier
	(mode append). </FONT>
	</DD><DT>
	<FONT SIZE=5>&quot;r+&quot;,&quot;w+&quot;,&quot;a+&quot;</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>ouverture en lecture &eacute;criture respectivement au
	d&eacute;but du fichier, au d&eacute;but du fichier avec &eacute;crasement,
	&agrave; la fin du fichier. </FONT>
	</DD></DL>
<PRE>
<FONT SIZE=5><B>FILE *f;</B></FONT>
<FONT SIZE=5><B>...</B></FONT>
<FONT SIZE=5><B>if ((f = fopen(&quot;toto&quot;, &quot;r&quot;)) == NULL)</B></FONT>
<FONT SIZE=5><B>{</B></FONT>
<FONT SIZE=5><B>    fprintf(stderr, &quot;impossible d'ouvrir toto\n&quot;);</B></FONT>
<FONT SIZE=5><B>    exit(1);</B></FONT>
<FONT SIZE=5><B>}</B></FONT>
<FONT SIZE=5><B>...</B></FONT></PRE><P>
<FONT SIZE=5>La fonction retourne un pointeur sur un descripteur du
fichier ouvert ou </FONT><TT><FONT SIZE=5>NULL</FONT></TT><FONT SIZE=5>
en cas d'&eacute;chec, (acc&egrave;s interdit, cr&eacute;ation
impossible, etc).<!--TOC subsection <FONT SIZE=5>Redirection d'un descripteur&nbsp;: </FONT><FONT SIZE=5><TT>freopen </TT></FONT>--></FONT></P>
<H3><FONT SIZE=5>5.1.2&nbsp;&nbsp; Redirection d'un descripteur&nbsp;:
</FONT><TT><FONT SIZE=5>freopen </FONT></TT>
</H3>
<P><!--SEC END --><FONT SIZE=5>redirection stdlib!freopen@</FONT><TT><FONT SIZE=5>freopen</FONT></TT><FONT SIZE=5>
Permet d'associer un descripteur d&eacute;j&agrave; utilis&eacute; &agrave;
une autre ouverture de fichier. Ceci permet de r&eacute;aliser
facilement les redirections du shell. </FONT>
</P>
<PRE>
<FONT SIZE=5><B>FILE *freopen(const char *ref,</B></FONT>
<FONT SIZE=5><B>              const char *mode,</B></FONT>
<FONT SIZE=5><B>              FILE *f)</B></FONT></PRE><P>
<FONT SIZE=5>Par exemple les redirections de la ligne shell&nbsp;: </FONT>
</P>
<PRE>
<FONT SIZE=5>com &lt;ref1 &gt;&gt;ref2</FONT></PRE><P>
<FONT SIZE=5>peuvent &ecirc;tre r&eacute;alis&eacute;es avec </FONT>
</P>
<PRE>
<FONT SIZE=5>if (!freopen(&quot;ref1&quot;, &quot;r&quot;, stdin) || !freopen(&quot;ref2&quot;, &quot;a&quot;, stdout))</FONT>
<FONT SIZE=5>{</FONT>
<FONT SIZE=5>    fprintf(stderr, &quot;erreur sur une redirection\n&quot;);</FONT>
<FONT SIZE=5>    exit(1);</FONT>
<FONT SIZE=5>}</FONT>
<FONT SIZE=5>execl(&quot;./com&quot;, &quot;com&quot;, NULL);</FONT></PRE><H3>
<FONT SIZE=5><!--TOC subsection <FONT SIZE=5>Création de fichiers temporaires</FONT>-->5.1.3&nbsp;&nbsp;
Cr&eacute;ation de fichiers temporaires</FONT></H3>
<P><!--SEC END --><FONT SIZE=5>La fonction stdlib!tmpfile@</FONT><TT><FONT SIZE=5>tmpfile</FONT></TT><FONT SIZE=5>
</FONT>
</P>
<PRE>
<FONT SIZE=5><B>#include &lt;stdio.h&gt;</B></FONT>
<FONT SIZE=5><B>FILE *tmpfile(void);</B></FONT></PRE><P>
<FONT SIZE=5>cr&eacute;e et ouvre en &eacute;criture un nouveau
fichier temporaire, qui sera d&eacute;truit (un </FONT><TT><FONT SIZE=5>unlink</FONT></TT><FONT SIZE=5>
est r&eacute;alis&eacute; imm&eacute;diatement) &agrave; la fin de
l'ex&eacute;cution du processus, attention le descripteur est h&eacute;rit&eacute;
par les fils. Cette fonction utilise la fonction </FONT>
</P>
<PRE>
<FONT SIZE=5><B>char *tmpnam(char *ptr);</B></FONT></PRE><P>
<FONT SIZE=5>stdlib!tmpnam@</FONT><TT><FONT SIZE=5>tmpnam</FONT></TT><FONT SIZE=5>
Cette fonction g&eacute;n&egrave;re un nouveau nom de fichier et
place celui-ci dans la zone point&eacute;e par ptr si ptr <FONT FACE="symbol">&sup1;</FONT>
NULL, la zone r&eacute;serv&eacute;e doit &ecirc;tre d'au moins
</FONT><TT><FONT SIZE=5>L_tmpnam</FONT></TT><FONT SIZE=5> octets. Si
ptr = </FONT><TT><FONT SIZE=5>NULL</FONT></TT><FONT SIZE=5> une zone
statique est utilis&eacute;e.<!--TOC subsection <FONT SIZE=5>Ecriture non formatée</FONT>-->
</FONT>
</P>
<H3><FONT SIZE=5>5.1.4&nbsp;&nbsp; Ecriture non format&eacute;e</FONT></H3>
<P><FONT SIZE=5><!--SEC END -->Les deux fonctions suivantes
permettent d'&eacute;crire et de lire des zones m&eacute;moire, le
contenu de la m&eacute;moire est directement &eacute;crit sur disque
sans transformation, et r&eacute;ciproquement le contenu du disque
est plac&eacute; tel quel en m&eacute;moire. L'int&eacute;r&ecirc;t
de ces fonctions est d'obtenir des entr&eacute;es sorties plus
rapides et des sauvegardes disque plus compactes mais malheureusement
illisibles (binaire). </FONT>
</P>
<PRE>
<FONT SIZE=5><B>#include &lt;stdio.h&gt;</B></FONT>
<FONT SIZE=5><B>int fwrite(void *add, size_t ta, size_t nbobjets, FILE *f);</B></FONT></PRE><P>
<FONT SIZE=5>stdlib!fwrite@</FONT><TT><FONT SIZE=5>fwrite</FONT></TT><FONT SIZE=5>
Ecrit </FONT><TT><FONT SIZE=5>nbobjets</FONT></TT><FONT SIZE=5> de
taille </FONT><TT><FONT SIZE=5>ta</FONT></TT><FONT SIZE=5> qui se
trouvent &agrave; l'adresse </FONT><TT><FONT SIZE=5>add</FONT></TT><FONT SIZE=5>
dans le fichier de descripteur </FONT><TT><FONT SIZE=5>f</FONT></TT><FONT SIZE=5>.
</FONT>
</P>
<PRE>
<FONT SIZE=5><B>#include &lt;stdio.h&gt;</B></FONT>
<FONT SIZE=5><B>int fread(void *add, size_t ta, size_t nbobjets, FILE *f);</B></FONT></PRE><P>
<FONT SIZE=5>stdlib!fread@</FONT><TT><FONT SIZE=5>fread</FONT></TT><FONT SIZE=5>
Lit </FONT><TT><FONT SIZE=5>nbobjets</FONT></TT><FONT SIZE=5> de
taille </FONT><TT><FONT SIZE=5>ta</FONT></TT><FONT SIZE=5> dans le
fichier de descripteur </FONT><TT><FONT SIZE=5>f</FONT></TT><FONT SIZE=5>
et les place &agrave; partir de l'adresse </FONT><TT><FONT SIZE=5>add</FONT></TT><FONT SIZE=5>
en m&eacute;moire.<BR><BR>Attention&nbsp;: La fonction </FONT><TT><FONT SIZE=5>fread</FONT></TT><FONT SIZE=5>
retourne 0 si l'on essaye de lire au del&agrave; du fichier. Pour
&eacute;crire une boucle de lecture propre on utilise la fonction
</FONT><TT><FONT SIZE=5>feof(FILE *)</FONT></TT><FONT SIZE=5>&nbsp;: </FONT>
</P>
<PRE>
<FONT SIZE=5><B>int n[2];</B></FONT>

<FONT SIZE=5><B>while (fread(n, sizeof(int), 2, f), !feof(f))</B></FONT>
<FONT SIZE=5><B>      printf(&quot;%d %d \n&quot;, n[0], n[1]);</B></FONT></PRE><P>
<FONT SIZE=5>stdlib!feof@</FONT><TT><FONT SIZE=5>feof<!--TOC subsection <FONT SIZE=5>Accès séquentiel</FONT>--></FONT></TT><FONT SIZE=5>
</FONT>
</P>
<H3><FONT SIZE=5>5.1.5&nbsp;&nbsp; Acc&egrave;s s&eacute;quentiel</FONT></H3>
<P><FONT SIZE=5><!--SEC END -->On distingue deux techniques d'acc&egrave;s
aux supports magn&eacute;tiques&nbsp;: </FONT>
</P>
<UL>
	<LI><P><FONT SIZE=5>acc&egrave;s s&eacute;quentiel L'acc&egrave;s
	s&eacute;quentiel qui consiste &agrave; traiter les informations
	dans l'ordre o&ugrave; elle apparaissent sur le support (bandes). Le
	lecteur physique avance avec la lecture, et se positionne sur le
	d&eacute;but de l'enregistrement suivant.</FONT></P>
	<LI><P><FONT SIZE=5>L'acc&egrave;s direct qui consiste &agrave; se
	placer directement sur l'information sans parcourir celles qui la
	pr&eacute;c&egrave;dent (disques). Le lecteur physique reste sur le
	m&ecirc;me enregistrement apr&egrave;s une lecture.acc&egrave;s
	direct </FONT>
	</P>
</UL>
<P><FONT SIZE=5>En langage C l'acc&egrave;s est s&eacute;quentiel
mais il est possible de d&eacute;placer le &quot;pointeur de fichier&quot;
c'est &agrave; dire s&eacute;lectionner l'indice du prochain octet &agrave;
lire ou &eacute;crire.pointeur de fichier</FONT><BR><BR><FONT SIZE=5>Comme
nous venons de le voir dans les modes d'ouverture, le pointeur de
fichier peut &ecirc;tre initialement plac&eacute; en d&eacute;but ou
fin de fichier.<BR><BR>Les quatre fonctions d'entr&eacute;e-sortie
(</FONT><TT><FONT SIZE=5>fgetc, fputc, fscanf, fprintf</FONT></TT><FONT SIZE=5>)
travaillent s&eacute;quentiellement &agrave; partir de cette origine
fix&eacute;e par </FONT><TT><FONT SIZE=5>fopen</FONT></TT><FONT SIZE=5>.<!--TOC subsection <FONT SIZE=5>Manipulation du pointeur de fichier</FONT>--></FONT></P>
<H3><FONT SIZE=5>5.1.6&nbsp;&nbsp; Manipulation du pointeur de
fichier</FONT></H3>
<P><!--SEC END --><FONT SIZE=5>Le pointeur de fichier est un entier
</FONT><TT><FONT SIZE=5>long</FONT></TT><FONT SIZE=5> qui indique &agrave;
partir de quel octet du fichier la prochaine fonction d'entr&eacute;e-sortie
doit s'effectuer.<BR><BR>En d&eacute;but de fichier cet entier est
nul.</FONT></P>
<PRE>
<FONT SIZE=5><B>#include &lt;stdio.h&gt;</B></FONT>
<FONT SIZE=5><B>int fseek(FILE *f, long pos, int direction);</B></FONT></PRE><P>
<FONT SIZE=5>stdlib!fseek@</FONT><TT><FONT SIZE=5>fseek</FONT></TT><FONT SIZE=5>
</FONT><TT><FONT SIZE=5>f</FONT></TT><FONT SIZE=5> le descripteur du
fichier dans lequel ont d&eacute;place le pointeur.<BR><BR>direction
est une des trois constantes enti&egrave;res suivantes&nbsp;: </FONT>
</P>
<DL>
	<DT><FONT SIZE=5>SEEK_SET</FONT></DT><DD>
	<FONT SIZE=5>positionnement sur l'octet pos du fichier </FONT>
	</DD><DT>
	<FONT SIZE=5>SEEK_CUR</FONT></DT><DD>
	<FONT SIZE=5>positionnement sur le </FONT><TT><FONT SIZE=5>pos</FONT></TT><FONT SIZE=5>-i&egrave;me
	octet apr&egrave;s la position courante du pointeur de fichier.
	(&eacute;quivalent &agrave; SEEK_SET courant+pos). </FONT>
	</DD><DT>
	<FONT SIZE=5>SEEK_END</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>positionnement sur le </FONT><TT><FONT SIZE=5>pos</FONT></TT><FONT SIZE=5>-i&egrave;me
	octet apr&egrave;s la fin du fichier. </FONT>
	</DD></DL>
<P>
<FONT SIZE=5>Remarquer que </FONT><TT><FONT SIZE=5>pos</FONT></TT><FONT SIZE=5>
est un entier sign&eacute; &nbsp;: il est possible se placer sur le
4i&egrave;me octet avant la fin du fichier&nbsp;: </FONT>
</P>
<PRE>
<FONT SIZE=5><B>fseek(f, -4L, SEEK_END);</B></FONT></PRE><H3>
<FONT SIZE=5><!--TOC subsection <FONT SIZE=5>Un exemple d'accès direct sur un fichier d'entiers.</FONT>-->5.1.7&nbsp;&nbsp;
Un exemple d'acc&egrave;s direct sur un fichier d'entiers.</FONT></H3>
<P><!--SEC END --><FONT SIZE=5>La fonction suivante lit le n-i&egrave;me
entier d'un fichier d'entiers pr&eacute;alablement &eacute;crit gr&acirc;ce
&agrave; </FONT><TT><FONT SIZE=5>fwrite</FONT></TT><FONT SIZE=5>&nbsp;:
</FONT>
</P>
<PRE STYLE="margin-left: 1cm; margin-right: 1cm">
<FONT SIZE=5>int lirenieme(int n, FILE *f)</FONT>
<FONT SIZE=5>{</FONT>
<FONT SIZE=5>    int buf;</FONT>

<FONT SIZE=5>    fseek(f, sizeof(int)*(n-1), SEEK_SET);</FONT>
<FONT SIZE=5>    fread(&amp;buf, sizeof(int), 1, f);</FONT>
<FONT SIZE=5>    return buf;</FONT>
<FONT SIZE=5>}  \istd{fseek}\istd{fread}</FONT></PRE><H3>
<FONT SIZE=5><!--TOC subsection <FONT SIZE=5>Les autres fonctions de déplacement du pointeur de fichier.</FONT>-->5.1.8&nbsp;&nbsp;
Les autres fonctions de d&eacute;placement du pointeur de fichier.</FONT></H3>
<P><!--SEC END --><FONT SIZE=5>La fonction </FONT><TT><FONT SIZE=5>ftell</FONT></TT><FONT SIZE=5>
</FONT>
</P>
<PRE>
<FONT SIZE=5>    long int ftell(FILE *);</FONT>
<FONT SIZE=5> </FONT></PRE><P>
<FONT SIZE=5>stdlib!ftell@</FONT><TT><FONT SIZE=5>ftell</FONT></TT><FONT SIZE=5>
retourne la position courante du pointeur.<BR>La fonction </FONT><TT><FONT SIZE=5>rewind</FONT></TT><FONT SIZE=5>
</FONT>
</P>
<PRE>
<FONT SIZE=5><B>    void rewind(FILE *f);</B></FONT>
<FONT SIZE=5><B> </B></FONT></PRE><P>
<FONT SIZE=5>stdlib!rewind@</FONT><TT><FONT SIZE=5>rewind</FONT></TT><FONT SIZE=5>
&eacute;quivalent &agrave;&nbsp;: </FONT><TT><FONT SIZE=5>(void)
fseek (f, 0L, 0)</FONT></TT><FONT SIZE=5> <!--TOC section <FONT SIZE=5>Les tampons de fichiers de stdlib.</FONT>--></FONT></P>
<H2><FONT SIZE=5>5.2&nbsp;&nbsp; Les tampons de fichiers de stdlib.</FONT></H2>
<P><!--SEC END --><FONT SIZE=5>La biblioth&egrave;que standard
utilise des tampons pour minimiser le nombre d'appels syst&egrave;me.
Il est possible de tester l'efficacit&eacute; de cette bufferisation
en comparant la vitesse de recopie d'un m&ecirc;me fichier avec un
tampon de taille 1 octet et un tampon adapt&eacute; &agrave; la
machine, la diff&eacute;rence devient vite tr&egrave;s importante.
Une fa&ccedil;on simple de le percevoir est d'&eacute;crire un
programme </FONT><TT><FONT SIZE=5>com</FONT></TT><FONT SIZE=5> qui
r&eacute;alise des &eacute;critures sur la sortie standard ligne par
ligne, de regarder sa vitesse puis de comparer avec la commande
suivantes&nbsp;:</FONT><TT><FONT SIZE=5>com | cat</FONT></TT><FONT SIZE=5>
la biblioth&egrave;que standard utilisant des buffer diff&eacute;rents
dans les deux cas une diff&eacute;rence de vitese d'ex&eacute;cution
est perceptible (sur une machine lente la diff&eacute;rence de
vitesse est &eacute;vidente, mais elle existe aussi sur une
rapide...).<!--TOC subsection <FONT SIZE=5>Les modes de bufferisation par défaut.</FONT>--></FONT></P>
<H3><FONT SIZE=5>5.2.1&nbsp;&nbsp; Les modes de bufferisation par
d&eacute;faut.</FONT></H3>
<P><FONT SIZE=5><!--SEC END -->Le mode de bufferisation des fichiers
ouverts par la biblioth&egrave;que standard d&eacute;pend du type de
p&eacute;riph&eacute;rique.</FONT></P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>bufferisation Si le
	fichier est un <B>terminal</B> la bufferisation est faite ligne &agrave;
	ligne. En </FONT><EM><FONT SIZE=5>&eacute;criture </FONT></EM><FONT SIZE=5>le
	tampon est vid&eacute; &agrave; chaque &eacute;criture d'un </FONT><CODE><FONT SIZE=5>'\n'</FONT></CODE><FONT SIZE=5>
	, ou quand il est plein (premi&egrave;re des deux occurences). En
	</FONT><EM><FONT SIZE=5>lecture </FONT></EM><FONT SIZE=5>le tampon
	est rempli apr&egrave;s chaque validation (RC), si l'on tape trop de
	caract&egrave;res le terminal proteste (beep) le buffer clavier
	&eacute;tant plein. </FONT>
	</P>
	<LI><P><FONT SIZE=5>Si le fichier est sur un <B>disque magn&eacute;tique</B>
	En </FONT><EM><FONT SIZE=5>&eacute;criture </FONT></EM><FONT SIZE=5>le
	tampon est vid&eacute; avant de d&eacute;border. En </FONT><EM><FONT SIZE=5>lecture
	</FONT></EM><FONT SIZE=5>le tampon est rempli quand il est vide. </FONT>
	</P>
</UL>
<P><FONT SIZE=5>Le shell de login change le mode de bufferisation de
<B>stderr</B> qui est un fichier terminal &agrave; non
bufferis&eacute;.<BR>Nous avons donc &agrave; notre disposition trois
modes de bufferisation standards&nbsp;: </FONT>
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Non bufferis&eacute;
	(sortie erreur standard), </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Bufferis&eacute; par
	ligne (lecture/&eacute;criture sur terminal), </FONT>
	</P>
	<LI><P><FONT SIZE=5>Bufferis&eacute; par blocs (taille des tampons
	du buffer cache). </FONT>
	</P>
</UL>
<P><FONT SIZE=5>Les terminaux acceptent d'autres modes de
bufferisation plus complexes en entr&eacute;e que nous &eacute;tudierons
avec les particularit&eacute;s de ces p&eacute;riph&eacute;riques
(chap&icirc;tre </FONT><A HREF="#terminaux"><FONT SIZE=5>12</FONT></A><FONT SIZE=5>).<BR>Un
exemple de r&eacute;ouverture de la sortie standard, avec perte du
mode de bufferisation&nbsp;: </FONT>
</P>
<PRE STYLE="margin-left: 1cm; margin-right: 1cm">
<FONT SIZE=5>#include &lt;stdio.h&gt;</FONT>
<FONT SIZE=5>main()</FONT>
<FONT SIZE=5>{</FONT>
<FONT SIZE=5>    freopen(&quot;/dev/tty&quot;, &quot;w&quot;, stderr);</FONT>
<FONT SIZE=5>    fprintf(stderr, &quot;texte non termine par un newline &quot;);</FONT>
<FONT SIZE=5>    sleep(12);</FONT>
<FONT SIZE=5>    exit(0); /* realise fclose(stderr) qui realise fflush(stderr) */</FONT>
<FONT SIZE=5>}</FONT></PRE><P>
<FONT SIZE=5>stdlib!freopen@</FONT><TT><FONT SIZE=5>freopen</FONT></TT><FONT SIZE=5>
<BR><BR>Il faut attendre 12 secondes l'affichage.<!--TOC subsection <FONT SIZE=5>Manipulation des tampons de la bibliothèque standard.</FONT>--></FONT></P>
<H3><FONT SIZE=5>5.2.2&nbsp;&nbsp; Manipulation des tampons de la
biblioth&egrave;que standard.</FONT></H3>
<P><!--SEC END --><FONT SIZE=5>Un tampon allou&eacute;
automatiquement (malloc) est associ&eacute; &agrave; chaque ouverture
de fichier par </FONT><TT><FONT SIZE=5>fopen</FONT></TT><FONT SIZE=5>
au moment de la premi&egrave;re entr&eacute;e-sortie sur le
fichier.<BR><BR>La manipulation des tampons de la biblioth&egrave;que
standard comporte deux aspects&nbsp;: </FONT>
</P>
<OL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Manipulation de la
	bufferisation de fa&ccedil;on ponctuelle (vidange). </FONT>
	</P>
	<LI><P><FONT SIZE=5>Positionnement du mode de bufferisation. </FONT>
	</P>
</OL>
<H4><FONT SIZE=5><!--TOC subsubsection <FONT SIZE=5>Manipulations ponctuelles</FONT>-->Manipulations
ponctuelles</FONT></H4>
<P><FONT SIZE=5><!--SEC END -->La fonction suivante permet de vider
le tampon associ&eacute; au FILE * f&nbsp;: </FONT>
</P>
<PRE>
<FONT SIZE=5>#include &lt;stdio.h&gt;</FONT>
<FONT SIZE=5>fflush(FILE *f);</FONT></PRE><P>
<FONT SIZE=5>stdlib!fflush@</FONT><TT><FONT SIZE=5>fflush</FONT></TT><FONT SIZE=5>
En &eacute;criture force la copie du tampon associ&eacute; &agrave;
la structure f dans le tampon syst&egrave;me (ne garantit pas
l'&eacute;criture en cas d'interruption du syst&egrave;me!).<BR>En
lecture d&eacute;truit le contenu du tampon, si l'on est en mode
ligne uniquement jusqu'au premier caract&egrave;re </FONT><CODE><FONT SIZE=5>'\n'</FONT></CODE><FONT SIZE=5>.<BR>La
fonction fclose() r&eacute;alise un fflush() avant de fermer le
fichier.<BR>La fonction exit() appel fclose() sur tous les fichiers
ouvert par fopen (freopen,tmpfile,...) avant de terminer le
processus.<BR>stdlib!fclose@</FONT><TT><FONT SIZE=5>fclose<!--TOC subsubsection <FONT SIZE=5> Manipulations du mode de bufferisation et de la taille du tampon.</FONT>--></FONT></TT><FONT SIZE=5>
</FONT>
</P>
<H4><FONT SIZE=5>Manipulations du mode de bufferisation et de la
taille du tampon.</FONT></H4>
<P><FONT SIZE=5><!--SEC END -->La primitive&nbsp; </FONT>
</P>
<PRE>
<FONT SIZE=5>  int setvbuf(FILE *f,</FONT>
<FONT SIZE=5>        char *adresse,</FONT>
<FONT SIZE=5>        int mode,</FONT>
<FONT SIZE=5>        size_t taille); </FONT>
<FONT SIZE=5> </FONT></PRE><P>
<FONT SIZE=5>stdlib!setvbuf@</FONT><TT><FONT SIZE=5>setvbuf</FONT></TT><FONT SIZE=5>
permet un changement du mode de bufferisation du fichier </FONT><EM><FONT SIZE=5>f
</FONT></EM><FONT SIZE=5>avec un tampon de taille </FONT><EM><FONT SIZE=5>taille</FONT></EM><FONT SIZE=5>
fourni par l'utilisateur &agrave; l'adresse </FONT><EM><FONT SIZE=5>adresse</FONT></EM><FONT SIZE=5>
si elle est non nulle, avec le </FONT><EM><FONT SIZE=5>mode</FONT></EM><FONT SIZE=5>
d&eacute;fini par les macro-d&eacute;finitions suivantes
(</FONT><CODE><TT><FONT SIZE=5>&lt;stdio.h&gt;</FONT></TT></CODE><FONT SIZE=5>)&nbsp;:
</FONT>
</P>
<PRE>
<FONT SIZE=5>_IOFBF        bufferise </FONT>
<FONT SIZE=5>_IONBF        Non bufferise </FONT>
<FONT SIZE=5>_IOMYBUF      Mon buffer</FONT>
<FONT SIZE=5>_IOLBF        bufferise par ligne (ex: les terminaux)</FONT>
<FONT SIZE=5> </FONT></PRE><P>
<FONT SIZE=5>Attention&nbsp;: Il ne faut pas appeler cette fonction
apr&egrave;s l'allocation automatique r&eacute;alis&eacute;e par la
biblioth&egrave;que standard apr&egrave;s le premier appel &agrave;
une fonction d'entr&eacute;e-sortie sur le fichier.<BR>Il est
fortement conseill&eacute; que la zone m&eacute;moire point&eacute;e
par </FONT><EM><FONT SIZE=5>adresse</FONT></EM><FONT SIZE=5> soit au
moins d'une taille &eacute;gale &agrave; </FONT><EM><FONT SIZE=5>taille</FONT></EM><FONT SIZE=5>.<BR><BR>Seul
un passage au mode bufferis&eacute; en ligne ou non bufferis&eacute;
peut &ecirc;tre r&eacute;alis&eacute; apr&egrave;s l'allocation
automatique du tampon, au risque de perdre ce tampon (absence
d&nbsp;'appel de </FONT><TT><FONT SIZE=5>free</FONT></TT><FONT SIZE=5>).
Ce qui permet par exemple de changer le mode de bufferisation de la
sortie standard apr&egrave;s un </FONT><TT><FONT SIZE=5>fork</FONT></TT><FONT SIZE=5>.
Attention ce peut &ecirc;tre dangereux, pour le contenu courant du
tampon comme le montre l'exemple suivant.<BR>Avant cette fonction de
norme POSIX on utilisait trois fonctions&nbsp;: </FONT>
</P>
<PRE STYLE="margin-left: 1cm; margin-right: 1cm">
<FONT SIZE=5>void setbuf(FILE *f, char *buf);</FONT>
<FONT SIZE=5>void setbuffer(FILE *f,char *adresse,size_t t);</FONT>
<FONT SIZE=5>void setlignebuf(FILE *f);</FONT>
<FONT SIZE=5> </FONT></PRE><BLOCKQUOTE>
<FONT SIZE=5>stdlib!setbuf@</FONT><TT><FONT SIZE=5>setbuf</FONT></TT><FONT SIZE=5>
stdlib!setbuffer@</FONT><TT><FONT SIZE=5>setbuffer</FONT></TT><FONT SIZE=5>
stdlib!setlignebuf@</FONT><TT><FONT SIZE=5>setlignebuf</FONT></TT><FONT SIZE=5>
<BR><BR></FONT><BR><BR>
</BLOCKQUOTE>
<PRE STYLE="margin-left: 1cm; margin-right: 1cm">
<FONT SIZE=5>#include &lt;stdio.h&gt;</FONT>
<FONT SIZE=5>main()</FONT>
<FONT SIZE=5>{</FONT>
<FONT SIZE=5>  printf(&quot;BonJour &quot;);</FONT>
<FONT SIZE=5>  switch(fork())</FONT>
<FONT SIZE=5>  {</FONT>
<FONT SIZE=5>    case -1 :</FONT>
<FONT SIZE=5>       exit(1);</FONT>
<FONT SIZE=5>    case  0 :</FONT>
<FONT SIZE=5>       printf(&quot;je suis le fils&quot;);</FONT>
<FONT SIZE=5>/* version 1 sans la ligne suivante version 2 avec  */</FONT>
<FONT SIZE=5>       setbuffer(stdout, NULL, 0); </FONT>
<FONT SIZE=5>       sleep(1);</FONT>
<FONT SIZE=5>       printf(&quot;Encore le fils&quot;);</FONT>
<FONT SIZE=5>       break;</FONT>
<FONT SIZE=5>    default :</FONT>
<FONT SIZE=5>       printf(&quot;je suis le pere&quot;);</FONT>
<FONT SIZE=5>       sleep(2);</FONT>
<FONT SIZE=5>  }</FONT>
<FONT SIZE=5>  printf(&quot;\n&quot;);</FONT>
<FONT SIZE=5>}</FONT>
<FONT SIZE=5>version 1</FONT>
<FONT SIZE=5>fork_stdlib</FONT>
<FONT SIZE=5>BonJour je suis le fils Encore le fils</FONT>
<FONT SIZE=5>BonJour je suis le pere</FONT>
<FONT SIZE=5>version 2</FONT>
<FONT SIZE=5>Encore le fils</FONT>
<FONT SIZE=5>BonJour je suis le pere</FONT></PRE><H2>
<FONT SIZE=5><!--TOC section <FONT SIZE=5>Manipulation des liens d'un fichier</FONT>-->5.3&nbsp;&nbsp;
Manipulation des liens d'un fichier</FONT></H2>
<P><FONT SIZE=5><!--SEC END -->Changer le nom d'un fichier &nbsp;:</FONT></P>
<PRE>
<FONT SIZE=5>int rename(const char *de,const char *vers);</FONT></PRE><P>
<FONT SIZE=5>stdlib!rename@</FONT><TT><FONT SIZE=5>rename</FONT></TT><FONT SIZE=5>
permet de renommer un fichier (ou un r&eacute;pertoire). Il faut que
les deux r&eacute;f&eacute;rences soient de m&ecirc;me type (fichier
ou r&eacute;pertoire) dans le m&ecirc;me syst&egrave;me de
fichiers.<BR>Rappel &nbsp;: ceci n'a d'effet que sur l'arborescence
de fichiers.<BR>D&eacute;truire une r&eacute;f&eacute;rence &nbsp;: </FONT>
</P>
<PRE>
<FONT SIZE=5>int remove(const char *filename);</FONT></PRE><P>
<FONT SIZE=5>stdlib!remove@</FONT><TT><FONT SIZE=5>remove</FONT></TT><FONT SIZE=5>
<BR><BR>D&eacute;truit le lien donn&eacute; en argument, le syst&egrave;me
r&eacute;cup&egrave;re l'inode et les blocs associ&eacute;s au
fichier si c'&eacute;tait le dernier lien.<!--TOC section <FONT SIZE=5>Lancement d'une commande shell</FONT>--></FONT></P>
<H2><FONT SIZE=5>5.4&nbsp;&nbsp; Lancement d'une commande shell</FONT></H2>
<PRE><!--SEC END -->
<FONT SIZE=5>#include &lt;stdlib.h&gt;</FONT>
<FONT SIZE=5>int system(const char *chaine_de_commande);</FONT></PRE><P>
<FONT SIZE=5>stdlib!system@</FONT><TT><FONT SIZE=5>system</FONT></TT><FONT SIZE=5>
Cr&eacute;e un processus ``/bin/posix/sh'' qui ex&eacute;cute la
commande&nbsp;; il y a attente de la fin du shell, (la commande peut
elle &ecirc;tre lanc&eacute;e en mode d&eacute;tach&eacute; ce qui
fait que le shell retourne imm&eacute;diatement sans faire un </FONT><TT><FONT SIZE=5>wait</FONT></TT><FONT SIZE=5>).
Ce m&eacute;canisme est tr&egrave;s co&ucirc;teux. Attention la
commande </FONT><TT><FONT SIZE=5>system</FONT></TT><FONT SIZE=5>
bloque les signaux SIGINT et SIGQUIT, il faut analyser la valeur de
retour de </FONT><TT><FONT SIZE=5>system</FONT></TT><FONT SIZE=5> de
la m&ecirc;me fa&ccedil;ons que celle de </FONT><TT><FONT SIZE=5>wait</FONT></TT><FONT SIZE=5>.
Il est conseill&eacute; de bloquer ces deux signaux avant l'appel de
</FONT><TT><FONT SIZE=5>system </FONT></TT><FONT SIZE=5>.<!--TOC section <FONT SIZE=5>Terminaison d'un processus</FONT>--></FONT></P>
<H2><FONT SIZE=5>5.5&nbsp;&nbsp; Terminaison d'un processus</FONT></H2>
<H5><FONT SIZE=5><!--SEC END --><!--TOC paragraph <FONT SIZE=5>_exit</FONT>-->_exit</FONT></H5>
<P><FONT SIZE=5><!--SEC END -->La primitive de terminaison de
processus de bas niveau&nbsp;: </FONT>
</P>
<PRE>
<FONT SIZE=5>    #include &lt;stdlib.h&gt;</FONT>
<FONT SIZE=5>    void _exit(int valeur);</FONT></PRE><P>
<FONT SIZE=5>appels syst&egrave;mes!_exit@</FONT><TT><FONT SIZE=5>_exit</FONT></TT><FONT SIZE=5>
<BR><BR>La primitive </FONT><TT><FONT SIZE=5>_exit</FONT></TT><FONT SIZE=5>
est la fonction de terminaison &quot;bas niveau&quot; </FONT>
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>elle ferme les
	descripteurs ouverts par </FONT><EM><FONT SIZE=5>open, opendir</FONT></EM><FONT SIZE=5>
	ou h&eacute;rit&eacute;s du processus p&egrave;re. </FONT>
	</P>
	<LI><P><FONT SIZE=5>la </FONT><TT><FONT SIZE=5>valeur</FONT></TT><FONT SIZE=5>
	est fournie au processus p&egrave;re qui la r&eacute;cup&egrave;re
	par l'appel syst&egrave;me </FONT><EM><FONT SIZE=5>wait</FONT></EM><FONT SIZE=5>.
	Cette valeur est le code de retour de processus en shell. </FONT>
	</P>
</UL>
<P><FONT SIZE=5>Cette primitive est automatiquement appel&eacute;e &agrave;
la fin de la fonction </FONT><TT><FONT SIZE=5>main</FONT></TT><FONT SIZE=5>
(sauf en cas d'appels r&eacute;cursifs de </FONT><TT><FONT SIZE=5>main</FONT></TT><FONT SIZE=5>).<!--TOC paragraph <FONT SIZE=5>exit</FONT>--></FONT></P>
<H5><FONT SIZE=5>exit</FONT></H5>
<P><FONT SIZE=5><!--SEC END -->La fonction de terminaison de
processus de stdlib&nbsp;: </FONT>
</P>
<PRE>
<FONT SIZE=5>#include &lt;stdlib.h&gt;</FONT>
<FONT SIZE=5>void exit(int valeur);</FONT></PRE><P>
<FONT SIZE=5>stdlib!exit@</FONT><TT><FONT SIZE=5>exit</FONT></TT><FONT SIZE=5>
la fonction </FONT><EM><FONT SIZE=5>exit</FONT></EM><FONT SIZE=5>&nbsp;:
</FONT>
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>lance les fonctions
	d&eacute;finies par </FONT><EM><FONT SIZE=5>atexit</FONT></EM><FONT SIZE=5>.
	</FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>ferme l'ensemble des
	descripteurs ouverts gr&acirc;ce &agrave; la biblioth&egrave;que
	standard (</FONT><EM><FONT SIZE=5>fopen</FONT></EM><FONT SIZE=5>). </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>d&eacute;truit les
	fichiers fabriqu&eacute;s par la primitive </FONT><EM><FONT SIZE=5>tmpfile</FONT></EM><FONT SIZE=5>
	</FONT>
	</P>
	<LI><P><FONT SIZE=5>appelle </FONT><EM><FONT SIZE=5>_exit </FONT></EM><FONT SIZE=5>avec
	</FONT><TT><FONT SIZE=5>valeur</FONT></TT><FONT SIZE=5>. </FONT>
	</P>
</UL>
<H5><FONT SIZE=5><!--TOC paragraph <FONT SIZE=5>atexit</FONT>-->atexit</FONT></H5>
<P><!--SEC END --><FONT SIZE=5>La primitive </FONT><TT><FONT SIZE=5>atexit</FONT></TT><FONT SIZE=5>
permet de sp&eacute;cifier des fonctions &agrave; appeler en fin
d'ex&eacute;cution, elle sont lanc&eacute;es par </FONT><TT><FONT SIZE=5>exit</FONT></TT><FONT SIZE=5>
dans l'ordre inverse de leur positionnement par </FONT><TT><FONT SIZE=5>atexit</FONT></TT><FONT SIZE=5>.
</FONT>
</P>
<PRE>
<FONT SIZE=5>#include &lt;stdlib.h&gt;</FONT>
<FONT SIZE=5>int atexit(void (*fonction) (void ));</FONT></PRE><P>
<FONT SIZE=5>stdlib!atexit@</FONT><TT><FONT SIZE=5>atexit</FONT></TT><FONT SIZE=5>
Exemple&nbsp;: </FONT>
</P>
<PRE STYLE="margin-left: 1cm; margin-right: 1cm">
<FONT SIZE=5>void bob(void) {printf(&quot;coucou\n&quot;);}</FONT>
<FONT SIZE=5>void bib(void) {printf(&quot;cuicui &quot;);}</FONT>

<FONT SIZE=5>main(int argc)</FONT>
<FONT SIZE=5>{</FONT>
<FONT SIZE=5>  atexit(bob);</FONT>
<FONT SIZE=5>  atexit(bib);</FONT>
<FONT SIZE=5>  if (argc - 1)</FONT>
<FONT SIZE=5>    exit(0);</FONT>
<FONT SIZE=5>  else</FONT>
<FONT SIZE=5>    _exit(0);</FONT>
<FONT SIZE=5>}</FONT>
<FONT SIZE=5>$ make atexit</FONT>
<FONT SIZE=5>cc   atexit.c  -o atexit</FONT>
<FONT SIZE=5>$ atexit</FONT>
<FONT SIZE=5>$ atexit unargument</FONT>
<FONT SIZE=5>cuicui coucou</FONT>
<FONT SIZE=5>$</FONT></PRE><H2>
<FONT SIZE=5><!--TOC section <FONT SIZE=5>Gestion des erreurs</FONT>-->5.6&nbsp;&nbsp;
Gestion des erreurs</FONT></H2>
<P><FONT SIZE=5><!--SEC END -->Les fonctions de la biblioth&egrave;que
standard positionnent deux indicateurs d'erreur, la fonction suivante
les repositionne&nbsp;: </FONT>
</P>
<PRE>
<FONT SIZE=5> void clearerr(FILE *);</FONT></PRE><P>
<FONT SIZE=5>stdlib!clearerr@</FONT><TT><FONT SIZE=5>clearerr</FONT></TT><FONT SIZE=5>
stdlib!feof@</FONT><TT><FONT SIZE=5>feof</FONT></TT><FONT SIZE=5> La
fonction </FONT><TT><FONT SIZE=5>int feof(FILE *)</FONT></TT><FONT SIZE=5>
est vraie si la fin de fichier est atteinte sur ce canal, </FONT><TT><FONT SIZE=5>int
ferror(FILE *)</FONT></TT><FONT SIZE=5> est vraie si une erreur a eu
lieu pendant la derni&egrave;re tentative de lecture ou d'&eacute;criture
sur ce canal.<BR>Une description en langue naturelle de la derni&egrave;re
erreur peut &ecirc;tre obtenue grace &agrave; </FONT>
</P>
<PRE STYLE="margin-left: 1cm; margin-right: 1cm">
<FONT SIZE=5>void perror(const char *message);</FONT></PRE><BLOCKQUOTE>
<FONT SIZE=5>stdlib!perror@</FONT><TT><FONT SIZE=5>perror</FONT></TT><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<P><FONT SIZE=5>l'affichage se fait sur la sortie erreur standard
(</FONT><TT><FONT SIZE=5>stderr</FONT></TT><FONT SIZE=5>).<!--TOC section <FONT SIZE=5>Création et destruction de répertoires</FONT>--></FONT></P>
<H2><FONT SIZE=5>5.7&nbsp;&nbsp; Cr&eacute;ation et destruction de
r&eacute;pertoires</FONT></H2>
<P><!--SEC END --><FONT SIZE=5>Cr&eacute;ation d'un r&eacute;pertoire
vide (m&ecirc;me syntaxe que </FONT><TT><FONT SIZE=5>creat</FONT></TT><FONT SIZE=5>)
&nbsp;: </FONT>
</P>
<PRE>
<FONT SIZE=5>#include &lt;unistd.h&gt;</FONT>
<FONT SIZE=5>int mkdir(char *ref, mode_t  mode);</FONT></PRE><P>
<FONT SIZE=5>stdlib!mkdir@</FONT><TT><FONT SIZE=5>mkdir</FONT></TT><FONT SIZE=5>
<BR><BR>Destruction &nbsp;: </FONT>
</P>
<PRE>
<FONT SIZE=5>int rmdir(char *ref);</FONT></PRE><P>
<FONT SIZE=5>stdlib!rmdir@</FONT><TT><FONT SIZE=5>rmdir</FONT></TT><FONT SIZE=5>
avec les m&ecirc;mes restrictions que pour les shells sur le contenu
du r&eacute;pertoire (impossible de d&eacute;truire un r&eacute;pertoire
non vide).<!--TOC chapter <FONT SIZE=5>Appels système du Système de Gestion de Fichier</FONT>-->
</FONT>
</P>
<H1><FONT SIZE=5>Chapitre&nbsp;6&nbsp;&nbsp; Appels syst&egrave;me du
Syst&egrave;me de Gestion de Fichier</FONT></H1>
<P><FONT SIZE=5><!--SEC END -->Les appels syst&egrave;me
d'entr&eacute;es-sorties ou entr&eacute;es-sorties de bas niveau sont
rudimentaires mais polymorphes, en effet c'est eux qui permettent
d'&eacute;crire des programmes ind&eacute;pendamment des supports
physiques sur lesquels se font les entr&eacute;es/sorties et de
pouvoir facilement changer les supports physiques associ&eacute;s a
une entr&eacute;e-sortie.<BR>Les appels syst&egrave;me du syst&egrave;me
de gestion de fichier sont&nbsp;: </FONT>
</P>
<DL>
	<DT><FONT SIZE=5>appels syst&egrave;mes!introduction@</FONT><TT><FONT SIZE=5>introduction</FONT></TT><FONT SIZE=5>
	</FONT><TT><FONT SIZE=5>open/creat</FONT></TT></DT><DD>
	<FONT SIZE=5>ouverture/cr&eacute;ation d'un fichier </FONT>
	</DD><DT>
	<TT><FONT SIZE=5>read/write</FONT></TT></DT><DD>
	<FONT SIZE=5>lecture/ecriture sur un fichier ouvert </FONT>
	</DD><DT>
	<TT><FONT SIZE=5>lseek</FONT></TT></DT><DD>
	<FONT SIZE=5>d&eacute;placement du pointeur de fichier </FONT>
	</DD><DT>
	<TT><FONT SIZE=5>dup,dup2</FONT></TT></DT><DD>
	<FONT SIZE=5>copie d'ouverture de fichier </FONT>
	</DD><DT>
	<TT><FONT SIZE=5>close</FONT></TT></DT><DD>
	<FONT SIZE=5>fermeture d'un fichier </FONT>
	</DD><DT>
	<TT><FONT SIZE=5>mount</FONT></TT></DT><DD>
	<FONT SIZE=5>chargement d'un disque </FONT>
	</DD><DT>
	<TT><FONT SIZE=5>mknode</FONT></TT></DT><DD>
	<FONT SIZE=5>cr&eacute;ation d'un inode de fichier sp&eacute;cial </FONT>
	</DD><DT>
	<TT><FONT SIZE=5>pipe</FONT></TT></DT><DD>
	<FONT SIZE=5>cr&eacute;ation d'un tube </FONT>
	</DD><DT>
	<TT><FONT SIZE=5>fcntl</FONT></TT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>manipulation des caract&eacute;ristiques des ouvertures
	de fichiers </FONT>
	</DD></DL>
<P>
<FONT SIZE=5>Les appels syst&egrave;me sont r&eacute;alis&eacute;s
par le noyau et retournent -1 en cas d'erreur.</FONT></P>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML028.gif" NAME="Image30" ALIGN=BOTTOM WIDTH=316 HEIGHT=546 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
6.1&nbsp;: Tables du syst&egrave;me de fichiers.</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="Tablesouverturesfichiers"></A>
<BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<H2><!--TOC section <FONT SIZE=5><TT>open</TT></FONT>-->6.1&nbsp;&nbsp;
<TT>open</TT></H2>
<PRE><A NAME="open"></A><!--SEC END -->
<FONT SIZE=5>#include &lt;fcntl.h&gt;</FONT>
<FONT SIZE=5>int open(char *ref, int mode, int perm);</FONT></PRE><P>
<FONT SIZE=5>appels syst&egrave;mes!open@</FONT><TT><FONT SIZE=5>open</FONT></TT><FONT SIZE=5>
Ouverture du fichier de r&eacute;f&eacute;rence (absolue ou relative
&agrave; &quot;.&quot;) </FONT><EM><FONT SIZE=5>ref</FONT></EM><FONT SIZE=5>.<BR>Le
</FONT><EM><FONT SIZE=5>mode</FONT></EM><FONT SIZE=5> d'ouverture est
une conjonction des masques suivants&nbsp;: </FONT>
</P>
<PRE>
<FONT SIZE=5>O_RDONLY  /* open for reading */</FONT>
<FONT SIZE=5>O_WRONLY  /* open for writing */</FONT>
<FONT SIZE=5>O_RDWR    /* open for read &amp; write */</FONT>
<FONT SIZE=5>O_NDELAY  /* non-blocking open */</FONT>
<FONT SIZE=5>O_APPEND  /* append on each write */</FONT>
<FONT SIZE=5>O_CREAT   /* open with file create */</FONT>
<FONT SIZE=5>O_TRUNC   /* open with truncation */</FONT>
<FONT SIZE=5>O_EXCL    /* error on create if file exists*/</FONT></PRE><P>
<FONT SIZE=5>Le param&egrave;tre </FONT><EM><FONT SIZE=5>perm</FONT></EM><FONT SIZE=5>ission
n'a de sens qu'&agrave; la cr&eacute;ation du fichier, il permet de
positionner les valeurs du champ </FONT><TT><FONT SIZE=5>mode</FONT></TT><FONT SIZE=5>
de l'inode. Les droits effectivement positionn&eacute;s d&eacute;pendent
de la valeur de </FONT><EM><FONT SIZE=5>umask</FONT></EM><FONT SIZE=5>,
grace &agrave; la formule </FONT><TT><FONT SIZE=5>droits = perm &amp;
</FONT><CODE><FONT SIZE=5>~ umask</FONT></CODE></TT><FONT SIZE=5>. La
valeur par d&eacute;faut de </FONT><TT><FONT SIZE=5>umask</FONT></TT><FONT SIZE=5>
est 066 (valeur octale).<BR>La valeur de retour de </FONT><TT><FONT SIZE=5>open</FONT></TT><FONT SIZE=5>
est le num&eacute;ro dans la table de descripteurs du processus qui a
&eacute;t&eacute; utilis&eacute; par </FONT><TT><FONT SIZE=5>open</FONT></TT><FONT SIZE=5>.
Ce num&eacute;ro est appel&eacute; descripteur de l'ouverture. Ce
descripteur est utilis&eacute; dans les autres appels syst&egrave;me
pour sp&eacute;cifier l'ouverture de fichier sur laquelle on veut
travailler</FONT><A HREF="#note5" NAME="text5"><FONT SIZE=2><SUP>1</SUP></FONT></A><FONT SIZE=5>,
et -1 en cas d'&eacute;chec de l'ouverture.<!--TOC subsection <FONT SIZE=5>Déroulement interne d'un appel de </FONT><FONT SIZE=5><TT>open</TT></FONT>--></FONT></P>
<H3><FONT SIZE=5>6.1.1&nbsp;&nbsp; D&eacute;roulement interne d'un
appel de </FONT><TT><FONT SIZE=5>open</FONT></TT></H3>
<OL>
	<LI><P STYLE="margin-bottom: 0cm"><!--SEC END --><FONT SIZE=5>Le
	syst&egrave;me d&eacute;termine l'inode du fichier r&eacute;f&eacute;rence
	(</FONT><EM><FONT SIZE=5>namei</FONT></EM><FONT SIZE=5>). </FONT>
	</P>
	<UL>
		<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Soit l'inode est
		dans la table des inodes en m&eacute;moire. </FONT>
		</P>
		<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Soit il alloue une
		entr&eacute;e et recopie l'inode du disque (</FONT><EM><FONT SIZE=5>iget</FONT></EM><FONT SIZE=5>).
		</FONT>
		</P>
	</UL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Le syst&egrave;me
	v&eacute;rifie les droits d'acc&egrave;s dans le mode demand&eacute;.
	</FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Il alloue une entr&eacute;e
	dans la table des fichiers ouverts du syst&egrave;me, et positionne
	le curseur de lecture &eacute;criture dans le fichier (offset = 0,
	sauf dans le cas du mode </FONT><TT><FONT SIZE=5>O_APPEND</FONT></TT><FONT SIZE=5>
	offset=taille du fichier). </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Le syst&egrave;me
	alloue une place dans la table des descripteurs </FONT><TT><FONT SIZE=5>_iob</FONT></TT><FONT SIZE=5>
	du fichier. </FONT>
	</P>
	<LI><P><FONT SIZE=5>Il renvoie au processus le num&eacute;ro de
	descripteur, c'est &agrave; dire le num&eacute;ro de l'entr&eacute;e
	qu'il vient d'allouer dans le tableau </FONT><TT><FONT SIZE=5>_iob</FONT></TT><FONT SIZE=5>.
	</FONT>
	</P>
</OL>
<P><FONT SIZE=5>Si l'op&eacute;ration a &eacute;chou&eacute; dans une
des &eacute;tapes le syst&egrave;me renvoie </FONT><TT><FONT SIZE=5>-1</FONT></TT><FONT SIZE=5>.
</FONT>
</P>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML029.gif" NAME="Image31" ALIGN=BOTTOM WIDTH=353 HEIGHT=297 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
6.2&nbsp;: Avant l'ouverture, descripteurs standard ouverts, puis
apr&egrave;s l'ouverture de ''toto''.</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="ouvertureaa"></A><BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<H2><!--TOC section <FONT SIZE=5><TT>creat</TT></FONT>-->6.2&nbsp;&nbsp;
<TT>creat</TT></H2>
<P><FONT SIZE=5><!--SEC END -->Cr&eacute;ation d'un fichier et
ouverture en &eacute;criture. </FONT>
</P>
<PRE>
<FONT SIZE=5>int creat(char *reference, int permissions);</FONT></PRE><P>
<FONT SIZE=5>appels syst&egrave;mes!creat@</FONT><TT><FONT SIZE=5>creat</FONT></TT><FONT SIZE=5>
</FONT>
</P>
<OL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Le syst&egrave;me
	d&eacute;termine l'inode du catalogue o&ugrave; l'on demande la
	cr&eacute;ation du fichier. </FONT>
	</P>
	<OL TYPE=a>
		<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Si il existe d&eacute;j&agrave;
		une inode pour le fichier </FONT>
		</P>
		<UL>
			<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Le noyau lit
			l'inode en question (allocation dans la table des inodes en
			m&eacute;moire), v&eacute;rifie que c'est un fichier ordinaire
			autoris&eacute; en &eacute;criture par le propri&eacute;taire
			effectif du processus, sinon &eacute;chec. </FONT>
			</P>
			<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Le syst&egrave;me
			lib&egrave;re les blocs de donn&eacute;es et r&eacute;duit la
			taille du fichier &agrave; z&eacute;ro, il ne modifie pas les
			droits qu'avait le fichier ant&eacute;rieurement. </FONT>
			</P>
		</UL>
		<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Si n'existait pas
		d'inode pour le fichier </FONT>
		</P>
		<UL>
			<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Le syst&egrave;me
			teste les droits en &eacute;criture sur le catalogue </FONT>
			</P>
			<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Il alloue une
			nouvelle inode (</FONT><EM><FONT SIZE=5>ialloc</FONT></EM><FONT SIZE=5>)
			</FONT>
			</P>
			<LI><P><FONT SIZE=5>Il alloue une nouvelle entr&eacute;e dans la
			table des inodes en m&eacute;moire. </FONT>
			</P>
		</UL>
	</OL>
</OL>
<P><FONT SIZE=5>M&ecirc;me suite que pour </FONT><TT><FONT SIZE=5>open</FONT></TT><FONT SIZE=5>.
<!--TOC section <FONT SIZE=5><TT>read</TT></FONT>--></FONT></P>
<H2>6.3&nbsp;&nbsp; <TT>read</TT></H2>
<PRE><!--SEC END -->
<FONT SIZE=5>int nbcharlus = read(int d, char *tampon, int nbalire)</FONT></PRE><P>
<FONT SIZE=5>appels syst&egrave;mes!read@</FONT><TT><FONT SIZE=5>read</FONT></TT><FONT SIZE=5>
</FONT>
</P>
<DL>
	<DT><BR><BR><EM><FONT SIZE=5>d</FONT></EM><FONT SIZE=5>escripteur</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>entr&eacute;e de la table des descripteurs
	correspondante au fichier dans lequel doit &ecirc;tre effectu&eacute;e
	la lecture (fourni par </FONT><TT><FONT SIZE=5>open</FONT></TT><FONT SIZE=5>).</FONT></DD><DT>
	<EM><FONT SIZE=5>nbalire</FONT></EM></DT><DD>
	<FONT SIZE=5>nombre de caract&egrave;res &agrave; lire dans le
	fichier. </FONT>
	</DD><DT>
	<EM><FONT SIZE=5>tampon</FONT></EM></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>un tableau de caract&egrave;res allou&eacute; par
	l'utilisateur. Les caract&egrave;res lus sont plac&eacute;s dans ce
	tampon.</FONT></DD><DT>
	<EM><FONT SIZE=5>nbcharlus</FONT></EM></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>nombre de caract&egrave;res effectivement lus, ou -1 en
	cas d'&eacute;chec de l'appel syst&egrave;me, (droits, ...), la fin
	de fichier est atteinte quand le nombre de caract&egrave;res lus est
	inf&eacute;rieur au nombre de caract&egrave;res demand&eacute;s. </FONT>
	</DD></DL>
<P>
<FONT SIZE=5>D&eacute;roulement&nbsp;:</FONT></P>
<OL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>V&eacute;rification
	du descripteur <FONT FACE="symbol">&frac34;&reg;</FONT> acc&egrave;s
	aux tables syst&egrave;me. </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Droits (mode ad&eacute;quat)
	</FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Gr&acirc;ce &agrave;
	l'inode le syst&egrave;me obtient les adresses du (des) bloc(s)
	contenant les donn&eacute;es &agrave; lire. Le syst&egrave;me
	effectue la lecture de ces blocs. </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Le syst&egrave;me
	recopie les donn&eacute;es du buffer cache vers le tampon de
	l'utilisateur. </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Le curseur dans le
	fichier est remit &agrave; jour dans l'entr&eacute;e de la table des
	fichiers ouverts. </FONT>
	</P>
	<LI><P><FONT SIZE=5>Le syst&egrave;me renvoie le nombre de
	caract&egrave;res effectivement lus. </FONT>
	</P>
</OL>
<H2><!--TOC section <FONT SIZE=5><TT>write</TT></FONT>-->6.4&nbsp;&nbsp;
<TT>write</TT></H2>
<PRE><!--SEC END -->
<FONT SIZE=5>int nbcecrits = write(int desc, char *tampon, int nbaecrire);</FONT></PRE><P>
<FONT SIZE=5>appels syst&egrave;mes!write@</FONT><TT><FONT SIZE=5>write</FONT></TT><FONT SIZE=5>
M&ecirc;me d&eacute;roulement que </FONT><TT><FONT SIZE=5>read</FONT></TT><FONT SIZE=5>
mais avec une allocation &eacute;ventuelle de bloc-disque dans le cas
d'un ajout au-del&agrave; de la fin du fichier.<BR>Dans le cas o&ugrave;
l'appel concerne un p&eacute;riph&eacute;rique en mode caract&egrave;re&nbsp;:
le syst&egrave;me active la fonction </FONT><TT><FONT SIZE=5>write</FONT></TT><FONT SIZE=5>
(r&eacute;ciproquement </FONT><TT><FONT SIZE=5>read</FONT></TT><FONT SIZE=5>
pour une lecture) du p&eacute;riph&eacute;rique qui utilise
directement l'adresse du tampon utilisateur.<BR>Remarquons ici encore
le polymorphisme de ces deux appels syst&egrave;me qui permet de lire
et d'&eacute;crire sur une grande vari&eacute;t&eacute; de
p&eacute;riph&eacute;riques en utilisant une seule syntaxe. Le code C
utilisant l'appel syst&egrave;me marchera donc indiff&eacute;remment
sur tous les types de p&eacute;riph&eacute;riques qui sont d&eacute;finis
dans le syst&egrave;me de fichier. Par exemple, il existe deux
p&eacute;riph&eacute;riques &quot;logiques&quot; qui sont /dev/null
et /dev/z&eacute;ro (que l'on ne trouve pas sur toutes les machines).
Le premier est toujours vide en lecture et les &eacute;critures n'ont
aucun effet (il est donc possible de d&eacute;verser n'importe quoi
sur ce p&eacute;riph&eacute;rique). Le deuxi&egrave;me fournit en
lecture une infinit&eacute; de z&eacute;ro et n'accepte pas
l'&eacute;criture.<!--TOC section <FONT SIZE=5><TT>lseek</TT></FONT>--></FONT></P>
<H2>6.5&nbsp;&nbsp; <TT>lseek</TT></H2>
<PRE><!--SEC END -->
<FONT SIZE=5>#include &lt;fcntl.h&gt;  </FONT>
<FONT SIZE=5>off_t  lseek(int d, off_t offset, int direction)</FONT></PRE><P>
<TT><FONT SIZE=5>lseek</FONT></TT><FONT SIZE=5> permet de d&eacute;placer
le curseur de fichier dans la <B>table des fichiers ouverts</B> du
syst&egrave;me. </FONT><EM><FONT SIZE=5>offset</FONT></EM><FONT SIZE=5>
un d&eacute;placement en octets.<BR></FONT><EM><FONT SIZE=5>d </FONT></EM><FONT SIZE=5>le
descripteur.<BR></FONT><EM><FONT SIZE=5>direction </FONT></EM><FONT SIZE=5>une
des trois macros L_SET, L_INCR, L_XTND.</FONT></P>
<DL>
	<DT><FONT SIZE=5>L_SET</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>la nouvelle position est </FONT><EM><FONT SIZE=5>offset</FONT></EM><FONT SIZE=5>
	sauf si </FONT><EM><FONT SIZE=5>offset</FONT></EM><FONT SIZE=5> est
	sup&eacute;rieur &agrave; la taille du fichier, auquel cas la
	position est &eacute;gale &agrave; la taille du fichier. Si l'offset
	est n&eacute;gatif, alors la position est z&eacute;ro.</FONT></DD><DT>
	<FONT SIZE=5>L_INCR</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>la position courante est incr&eacute;ment&eacute;e de
	</FONT><EM><FONT SIZE=5>offset</FONT></EM><FONT SIZE=5> place (m&ecirc;me
	contrainte sur la position maximum et la position minimum).</FONT></DD><DT>
	<FONT SIZE=5>L_XTND</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>D&eacute;placement par rapport &agrave; la fin du
	fichier, cette option permet d'augmenter la taille du fichier (ne
	pas cr&eacute;er de fichiers virtuellement gros avec ce m&eacute;canisme,
	ils posent des probl&egrave;mes de sauvegarde). </FONT>
	</DD></DL>
<P>
<FONT SIZE=5>La valeur de retour de lseek est la nouvelle position du
curseur dans le fichier ou -1 si l'appel a &eacute;chou&eacute;.<!--TOC section <FONT SIZE=5><TT>dup</TT></FONT><FONT SIZE=5> et </FONT><FONT SIZE=5><TT>dup2</TT></FONT>--></FONT></P>
<H2>6.6&nbsp;&nbsp; <TT>dup</TT> et <TT>dup2</TT></H2>
<P><FONT SIZE=5><!--SEC END -->Les appels dup et dup2 permettent de
dupliquer des entr&eacute;es de la table des descripteurs du
processus.</FONT></P>
<PRE>
<FONT SIZE=5>int  descripteur2 = dup(int descripteur1);</FONT></PRE><P>
<FONT SIZE=5>appels syst&egrave;mes!dup@</FONT><TT><FONT SIZE=5>dup</FONT></TT><FONT SIZE=5>
</FONT>
</P>
<OL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>v&eacute;rification
	que descripteur est le num&eacute;ro d'une entr&eacute;e non nulle. </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>recopie dans la
	<B>premi&egrave;re entr&eacute;e</B> libre du tableau des
	descripteurs l'entr&eacute;e correspondant &agrave; descripteur1. </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>le compteur de
	descripteurs de l'entr&eacute;e associ&eacute;e &agrave;
	descripteur1 dans la table des ouvertures de fichiers est
	incr&eacute;ment&eacute;. </FONT>
	</P>
	<LI><P><FONT SIZE=5>renvoi de l'indice dans la table des
	descripteurs de l'entr&eacute;e nouvellement allou&eacute;e. </FONT>
	</P>
</OL>
<P><FONT SIZE=5>Redirection temporaire de la sortie standard dans un
fichier&nbsp;: </FONT>
</P>
<PRE>
<FONT SIZE=5>tempout = open(&quot;sortie_temporaire&quot;,1);</FONT>
<FONT SIZE=5>oldout = dup(1);</FONT>
<FONT SIZE=5>close(1);</FONT>
<FONT SIZE=5>newout = dup(tempout); /* renvoie 1  */</FONT>
<FONT SIZE=5>write(1,&quot;xxxx&quot;,4); /* ecriture dans le fichier temporaire */</FONT>
<FONT SIZE=5>close(tempout);</FONT>
<FONT SIZE=5>close(1);</FONT>
<FONT SIZE=5>newout = dup(oldout);</FONT>
<FONT SIZE=5>close(oldout);</FONT></PRE><P>
<FONT SIZE=5>Il est aussi possible de choisir le descripteur cible
avec </FONT>
</P>
<PRE>
<FONT SIZE=5>int ok = dup2(int source, int destination);</FONT></PRE><P>
<FONT SIZE=5>appels syst&egrave;mes!dup2@</FONT><TT><FONT SIZE=5>dup2</FONT></TT><FONT SIZE=5>
Recopie du descripteur </FONT><TT><FONT SIZE=5>source</FONT></TT><FONT SIZE=5>
dans l'entr&eacute;e </FONT><TT><FONT SIZE=5>destination</FONT></TT><FONT SIZE=5>
de la table des descripteurs. Si </FONT><TT><FONT SIZE=5>destination</FONT></TT><FONT SIZE=5>
d&eacute;signe le descripteur d'un fichier ouvert, celui-ci est
pr&eacute;alablement ferm&eacute; avant duplication. Si </FONT><TT><FONT SIZE=5>destination</FONT></TT><FONT SIZE=5>
n'est pas un num&eacute;ro de descripteur valide, il y a une erreur,
retour -1.<!--TOC section <FONT SIZE=5><TT>close</TT></FONT>--></FONT></P>
<H2>6.7&nbsp;&nbsp; <TT>close</TT></H2>
<P><FONT SIZE=5><!--SEC END -->Fermeture d'un fichier. </FONT>
</P>
<PRE>
<FONT SIZE=5>int ok = close(descripteur);</FONT></PRE><P>
<FONT SIZE=5>appels syst&egrave;mes!close@</FONT><TT><FONT SIZE=5>close</FONT></TT><FONT SIZE=5>
</FONT>
</P>
<OL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>si </FONT><EM><FONT SIZE=5>descripteur
	</FONT></EM><FONT SIZE=5>n'est pas un descripteur valide retour -1 </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>l'entr&eacute;e
	d'indice </FONT><TT><FONT SIZE=5>descripteur</FONT></TT><FONT SIZE=5>
	de la table est lib&eacute;r&eacute;e. </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Le compteur de
	l'entr&eacute;e de la table des fichiers ouvert associ&eacute; &agrave;
	</FONT><TT><FONT SIZE=5>descripteur</FONT></TT><FONT SIZE=5> est
	d&eacute;cr&eacute;ment&eacute;.<BR><BR></FONT><EM><FONT SIZE=5>Si
	il passe &agrave; Z&eacute;ro alors</FONT></EM><FONT SIZE=5> </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>l'entr&eacute;e de la
	table des fichiers ouverts est lib&eacute;r&eacute;e et le compteur
	des ouvertures de l'inode en m&eacute;moire est d&eacute;cr&eacute;ment&eacute;.<BR><BR></FONT><EM><FONT SIZE=5>Si
	il passe &agrave; Z&eacute;ro alors</FONT></EM><FONT SIZE=5> </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>l'entr&eacute;e dans
	la table des inodes en m&eacute;moire est lib&eacute;r&eacute;e.<BR><BR></FONT><EM><FONT SIZE=5>Si
	de plus le compteur de liens de l'inode est &agrave; 0 alors</FONT></EM><FONT SIZE=5>
	</FONT>
	</P>
	<LI><P><FONT SIZE=5>le fichier est lib&eacute;r&eacute;&nbsp;:
	r&eacute;cup&eacute;ration de l'inode et des blocs. </FONT>
	</P>
</OL>
<P><FONT SIZE=5>Dans le cas d'une ouverture en &eacute;criture &nbsp;:
le dernier bloc du buffer cache dans lequel on a &eacute;crit est
marqu&eacute; ``a &eacute;crire''.</FONT></P>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML030.gif" NAME="Image32" ALIGN=BOTTOM WIDTH=319 HEIGHT=301 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
6.3&nbsp;: Redirection de la sortie standard sur ''toto''.</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="dupclose"></A><BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<P STYLE="margin-left: 6.4cm; margin-right: 6.4cm; border-top: none; border-bottom: 1.10pt double #808080; border-left: none; border-right: none; padding: 0cm">
<FONT SIZE=1 STYLE="font-size: 6pt"><!--BEGIN NOTES chapter--></FONT><BR><BR>
</P>
<DL>
	<DT><A HREF="#text5" NAME="note5"><FONT SIZE=5>1</FONT></A></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>Un m&ecirc;me fichier peut &ecirc;tre ouvert plusieurs
	fois. </FONT>
	</DD></DL>
<H1>
<FONT SIZE=5><!--END NOTES--><!--TOC chapter <FONT SIZE=5>Les processus</FONT>-->Chapitre&nbsp;7&nbsp;&nbsp;
Les processus</FONT></H1>
<H2><A NAME="cha:processus"></A><FONT SIZE=5><!--SEC END --><!--TOC section <FONT SIZE=5>Introduction aux processus</FONT>-->7.1&nbsp;&nbsp;
Introduction aux processus</FONT></H2>
<P><!--SEC END --><FONT SIZE=5>processus Un processus est un ensemble
d'octets (en langage machine) en cours d'ex&eacute;cution, en
d'autres termes, c'est l'ex&eacute;cution d'un programme.<BR>Un
processus UNIX se d&eacute;compose en&nbsp;: </FONT>
</P>
<OL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>processus!decomposition
	un espace d'adressage (visible par l'utilisateur/programmeur) </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Le bloc de contr&ocirc;le
	du processus (BCP) lui-m&ecirc;me d&eacute;compos&eacute; en&nbsp;: </FONT>
	</P>
	<UL>
		<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>une entr&eacute;e
		dans la table des processus du noyau </FONT><TT><FONT SIZE=5>struct
		proc</FONT></TT><FONT SIZE=5><BR>d&eacute;finie dans </FONT><CODE><TT><FONT SIZE=5>&lt;sys/proc.h&gt;</FONT></TT></CODE><FONT SIZE=5>.
		processus!proc@</FONT><TT><FONT SIZE=5>struct proc</FONT></TT><FONT SIZE=5>
		</FONT>
		</P>
		<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>une structure </FONT><TT><FONT SIZE=5>struct
		user</FONT></TT><FONT SIZE=5> appel&eacute;e </FONT><TT><FONT SIZE=5>zone
		u</FONT></TT><FONT SIZE=5> d&eacute;finie dans </FONT><CODE><FONT SIZE=5>&lt;sys/user.h&gt;</FONT></CODE><FONT SIZE=5>
		</FONT>
		</P>
	</UL>
	<P><FONT SIZE=5>processus!user@</FONT><TT><FONT SIZE=5>struct user</FONT></TT><FONT SIZE=5>
	</FONT>
	</P>
</OL>
<P><FONT SIZE=5>Les processus sous Unix apportent&nbsp;:</FONT></P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>La multiplicit&eacute;
	des ex&eacute;cutions<BR>Plusieurs processus peuvent &ecirc;tre
	l'ex&eacute;cution d'un m&ecirc;me programme.</FONT></P>
	<LI><P><FONT SIZE=5>La protection des ex&eacute;cutions<BR>Un
	processus ne peut ex&eacute;cuter que ses instructions propres et ce
	de fa&ccedil;on s&eacute;quentielle; il ne peut pas ex&eacute;cuter
	des instructions appartenant &agrave; un autre processus.<BR>Les
	processus sous UNIX communiquent entre eux et avec le reste du monde
	gr&acirc;ce aux appels syst&egrave;me. </FONT>
	</P>
</UL>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML031.gif" NAME="Image33" ALIGN=BOTTOM WIDTH=278 HEIGHT=180 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
7.1&nbsp;: La table des processus est interne au noyau.</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="tabledesprocessus"></A>
<BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<H3><!--TOC subsection <FONT SIZE=5>Création d'un processus - </FONT><FONT SIZE=5><TT>fork()</TT></FONT><FONT SIZE=5> </FONT>--><FONT SIZE=5>7.1.1&nbsp;&nbsp;
Cr&eacute;ation d'un processus - </FONT><TT><FONT SIZE=5>fork()</FONT></TT><FONT SIZE=5>
</FONT>
</H3>
<P><!--SEC END --><FONT SIZE=5>processus!cr&eacute;ation <BR><BR>Sous
UNIX la cr&eacute;ation de processus est r&eacute;alis&eacute;e par
l'appel syst&egrave;me&nbsp;: </FONT>
</P>
<PRE>
<FONT SIZE=5>           int fork(void);</FONT></PRE><P>
<FONT SIZE=5>appels syst&egrave;mes!fork@</FONT><TT><FONT SIZE=5>fork</FONT></TT><FONT SIZE=5>
<BR><BR>Tous les processus sauf le processus d'identification 0, sont
cr&eacute;&eacute;s par un appel &agrave; </FONT><EM><FONT SIZE=5>fork</FONT></EM><FONT SIZE=5>.<BR>Le
processus qui appelle le fork est appel&eacute; processus </FONT><EM><FONT SIZE=5>p&egrave;re</FONT></EM><FONT SIZE=5>.<BR>Le
nouveau processus est appel&eacute; processus </FONT><EM><FONT SIZE=5>fils</FONT></EM><FONT SIZE=5>.<BR>Tout
processus a un seul processus p&egrave;re.<BR>Tout processus peut
avoir z&eacute;ro ou plusieurs processus fils.<BR>Chaque processus
est identifi&eacute; par un num&eacute;ro unique, son <B>PID</B>.<BR>Le
processus de PID=0 est cr&eacute;&eacute; &quot;manuellement&quot; au
d&eacute;marrage de la machine, ce processus a toujours un r&ocirc;le
sp&eacute;cial</FONT><A HREF="#note6" NAME="text6"><FONT SIZE=2><SUP>1</SUP></FONT></A><FONT SIZE=5>
pour le syst&egrave;me, de plus pour le bon fonctionement des
programmes utilisant </FONT><TT><FONT SIZE=5>fork()</FONT></TT><FONT SIZE=5>
il faut que le PID z&eacute;ro reste toujours utilis&eacute;. Le
processus z&eacute;ro cr&eacute;e, gr&acirc;ce &agrave; un appel de
fork, le processus init de PID=1.<BR>Le processus de PID=1 de nom
<I>init</I> est l'anc&ecirc;tre de tous les autres processus (le
processus 0 ne r&eacute;alisant plus de </FONT><TT><FONT SIZE=5>fork()</FONT></TT><FONT SIZE=5>),
c'est lui qui accueille tous les processus orphelins de p&egrave;re
(ceci a fin de collecter les information &agrave; la mort de chaque
processus).<!--TOC section <FONT SIZE=5>Format d'un fichier exécutable</FONT>--></FONT></P>
<H2><FONT SIZE=5>7.2&nbsp;&nbsp; Format d'un fichier ex&eacute;cutable</FONT></H2>
<P><!--SEC END --><FONT SIZE=5>processus!format de fichier Les
compilateurs nous permettent de cr&eacute;er des fichiers
ex&eacute;cutables. Ces fichiers ont le format suivant qui permet au
noyau de les transformer en processus&nbsp;: </FONT>
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Une en-t&ecirc;te qui
	d&eacute;crit l'ensemble du fichier, ses attributs et sa carte des
	sections. </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>La taille &agrave;
	allouer pour les variables non initialis&eacute;es. </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Une section TEXT qui
	contient le code (en langage machine) processus!$TEXT$ </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Une section donn&eacute;es
	(DATA) cod&eacute;e en langage machine qui contient les donn&eacute;es
	initialis&eacute;es. processus!$DATA$ </FONT>
	</P>
	<LI><P><FONT SIZE=5>Eventuellement d'autres sections&nbsp;: Table
	des symboles pour le d&eacute;bugeur, Images, ICONS, Table des
	cha&icirc;nes, etc. </FONT>
	</P>
</UL>
<P><FONT SIZE=5>Pour plus d'informations se reporter au manuel
a.out.h sur la machine.<!--TOC section <FONT SIZE=5>Chargement/changement d'un exécutable</FONT>--></FONT></P>
<H2><FONT SIZE=5>7.3&nbsp;&nbsp; Chargement/changement d'un
ex&eacute;cutable</FONT></H2>
<P><!--SEC END --><FONT SIZE=5>L'appel syst&egrave;me </FONT><TT><FONT SIZE=5>execve</FONT></TT><FONT SIZE=5>
change l'ex&eacute;cutable du processus courant en chargeant un
nouvel ex&eacute;cutable. Les r&eacute;gions associ&eacute;e au
processus sont pr&eacute;alablement lib&eacute;r&eacute;es&nbsp;: </FONT>
</P>
<PRE>
<FONT SIZE=5>int execve(/* plusieurs formats */);</FONT></PRE><P>
<FONT SIZE=5>appels syst&egrave;mes!execve@</FONT><TT><FONT SIZE=5>execve</FONT></TT><FONT SIZE=5>
processus!recouvrement <BR><BR>Pour chaque section de l'ex&eacute;cutable
une r&eacute;gion en m&eacute;moire est allou&eacute;e.<BR>Soit au
moins les r&eacute;gions&nbsp;: </FONT>
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>le <B>code</B> </FONT>
	</P>
	<LI><P><FONT SIZE=5>les <B>donn&eacute;es</B> initialis&eacute;es </FONT>
	</P>
</UL>
<P><FONT SIZE=5>Mais aussi les r&eacute;gions&nbsp;: </FONT>
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>des <B>piles</B> </FONT>
	</P>
	<LI><P><FONT SIZE=5>du <B>tas</B> </FONT>
	</P>
</UL>
<P><FONT SIZE=5>piletas</FONT><BR><BR><FONT SIZE=5>La r&eacute;gion
de la <B>pile</B>&nbsp;:<BR>C'est une pile de structures de pile qui
sont empil&eacute;es et d&eacute;pil&eacute;es lors de l'appel ou le
retour de fonction. Le pointeur de pile, un des registres de l'unit&eacute;
centrale, indique la profondeur courante de la pile.<BR>Le code du
programme g&egrave;re les extensions de pile (appel ou retour de
fonction), c'est le noyau qui alloue l'espace n&eacute;cessaire &agrave;
ces extensions. Sur certains syst&egrave;mes on trouve une fonction
</FONT><TT><FONT SIZE=5>alloca()</FONT></TT><FONT SIZE=5> qui permet
de faire des demandes de m&eacute;moire sur la pile.<BR>Un processus
UNIX pouvant s'ex&eacute;cuter en deux modes (noyau, utilisateur),
une pile priv&eacute;e sera utilis&eacute;e dans chaque mode.<BR>La
pile noyau sera vide quand le processus est en mode utilisateur.<BR>Le
<B>tas</B> est une zone o&ugrave; est r&eacute;alis&eacute;e
l'allocation dynamique avec les fonctions </FONT><TT><FONT SIZE=5>Xalloc()</FONT></TT><FONT SIZE=5>.
stdlib!Xalloc@</FONT><TT><FONT SIZE=5>Xalloc</FONT></TT><FONT SIZE=5>
</FONT>
</P>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML032.gif" NAME="Image34" ALIGN=BOTTOM WIDTH=353 HEIGHT=196 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
7.2&nbsp;: La structure interne des processus.</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="structureprocessus"></A>
<BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<H2><FONT SIZE=5><!--TOC section <FONT SIZE=5>zone u et table des processus</FONT>-->7.4&nbsp;&nbsp;
zone u et table des processus</FONT></H2>
<P><!--SEC END --><FONT SIZE=5>Tous les processus sont associ&eacute;s
&agrave; une entr&eacute;e dans la </FONT><EM><FONT SIZE=5>table des
processus</FONT></EM><FONT SIZE=5> qui est interne au noyau. De plus,
le noyau alloue pour chaque processus une structure appel&eacute;e
</FONT><EM><FONT SIZE=5>zone u</FONT></EM><FONT SIZE=5> , qui
contient des donn&eacute;es priv&eacute;es du processus, uniquement
manipulables par le noyau. processus!zone u processus!table des
processus processus!table des r&eacute;gions par processus La </FONT><EM><FONT SIZE=5>table
des processus</FONT></EM><FONT SIZE=5> nous permet d'acc&eacute;der &agrave;
la </FONT><EM><FONT SIZE=5>table des r&eacute;gions par processus</FONT></EM><FONT SIZE=5>
qui permet d'acc&eacute;der &agrave; la </FONT><EM><FONT SIZE=5>table
des r&eacute;gions</FONT></EM><FONT SIZE=5>. Ce double niveau
d'indirection permet de faire partager des r&eacute;gions.<BR>Dans
l'organisation avec une m&eacute;moire virtuelle, la table des
r&eacute;gions est mat&eacute;rialis&eacute;e logiquement dans la
table de pages.<BR>Les </FONT><EM><FONT SIZE=5>structures de r&eacute;gions</FONT></EM><FONT SIZE=5>
de la table des r&eacute;gions contiennent des informations sur le
type, les droits d'acc&egrave;s et la localisation (adresses en
m&eacute;moire ou adresses sur disque) de la r&eacute;gion.<BR><BR>Seule
la <B>zone u</B> du processus courant est manipulable par le noyau,
les autres sont <B>inaccessibles.</B> L'adresse de la zone u est
plac&eacute;e dans le mot d'&eacute;tat du processus.</FONT></P>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML033.gif" NAME="Image35" ALIGN=BOTTOM WIDTH=315 HEIGHT=189 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
7.3&nbsp;: Table des r&eacute;gions, table des r&eacute;gions par
processus</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="tabledesregions"></A><BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<H2><!--TOC section <FONT SIZE=5><TT>fork</TT></FONT><FONT SIZE=5> et </FONT><FONT SIZE=5><TT>exec</TT></FONT><FONT SIZE=5> (revisités)</FONT>-->7.5&nbsp;&nbsp;
<TT>fork</TT> et <TT>exec</TT> (revisit&eacute;s)</H2>
<P><!--SEC END --><FONT SIZE=5>Quand un processus r&eacute;alise un
</FONT><TT><FONT SIZE=5>fork</FONT></TT><FONT SIZE=5>, le contenu de
l'entr&eacute;e de la table des r&eacute;gions est dupliqu&eacute;,
chaque r&eacute;gion est ensuite, en fonction de son type, partag&eacute;e
ou copi&eacute;e. appels syst&egrave;mes!fork@</FONT><TT><FONT SIZE=5>fork</FONT></TT><FONT SIZE=5>
appels syst&egrave;mes!exec@</FONT><TT><FONT SIZE=5>exec</FONT></TT><FONT SIZE=5>
</FONT>
</P>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML034.gif" NAME="Image36" ALIGN=BOTTOM WIDTH=315 HEIGHT=189 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
7.4&nbsp;: Changement de r&eacute;gions au cours d'un </FONT><TT><FONT SIZE=5>fork</FONT></TT><FONT SIZE=5>.</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="tabledesregionsfork"></A>
<BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<P><FONT SIZE=5>Quand un processus r&eacute;alise un </FONT><TT><FONT SIZE=5>exec</FONT></TT><FONT SIZE=5>,
il y a lib&eacute;ration des r&eacute;gions et r&eacute;allocation de
nouvelles r&eacute;gions en fonction des valeurs d&eacute;finies dans
le nouvel ex&eacute;cutable.</FONT></P>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML035.gif" NAME="Image37" ALIGN=BOTTOM WIDTH=315 HEIGHT=188 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
7.5&nbsp;: Changement de r&eacute;gions au cours d'un </FONT><TT><FONT SIZE=5>exec</FONT></TT><FONT SIZE=5>.</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="tabledesregionsexec"></A>
<BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<H2><FONT SIZE=5><!--TOC section <FONT SIZE=5>Le contexte d'un processus</FONT>-->7.6&nbsp;&nbsp;
Le contexte d'un processus</FONT></H2>
<P><FONT SIZE=5><!--SEC END -->Le contexte d'un processus est
l'ensemble des donn&eacute;es qui permettent de reprendre l'ex&eacute;cution
d'un processus qui a &eacute;t&eacute; interrompu.<BR><BR>Le contexte
d'un processus est l'ensemble de </FONT>
</P>
<OL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>son &eacute;tat </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>son mot d'&eacute;tat&nbsp;:
	en particulier processus!mot d'&eacute;tat </FONT>
	</P>
	<UL>
		<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>La valeur des
		registres actifs </FONT>
		</P>
		<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Le compteur ordinal </FONT>
		</P>
	</UL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>les valeurs des
	variables globales statiques ou dynamiques </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>son entr&eacute;e
	dans la table des processus </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>sa zone u </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Les piles user et
	system </FONT>
	</P>
	<LI><P><FONT SIZE=5>les zones de code et de donn&eacute;es. </FONT>
	</P>
</OL>
<P><FONT SIZE=5>Le noyau et ses variables ne font partie du contexte
d'aucun processus! <BR><BR>L'ex&eacute;cution d'un processus se fait
dans son contexte.<BR><BR>Quand il y a changement de processus
courant, il y a r&eacute;alisation d'une <B>commutation de mot d'&eacute;tat</B>
et d'un <B>changement de contexte</B>. processus!commutation de mot
d'&eacute;tat processus!changement de contexte Le noyau s'ex&eacute;cute
alors dans le nouveau contexte.<!--TOC section <FONT SIZE=5>Commutation de mot d'état et interruptions.</FONT>--></FONT></P>
<H2><FONT SIZE=5>7.7&nbsp;&nbsp; Commutation de mot d'&eacute;tat et
interruptions.</FONT></H2>
<P><FONT SIZE=5><!--SEC END -->Ces fonctions de tr&egrave;s bas
niveau sont fondamentales pour pouvoir programmer un syst&egrave;me
d'exploitation. <BR><BR>Pour &ecirc;tre ex&eacute;cut&eacute; et
donner naissance &agrave; un processus, un programme et ses donn&eacute;es
doivent &ecirc;tre charg&eacute;s en m&eacute;moire centrale. Les
instructions du programme sont transf&eacute;r&eacute;es une &agrave;
une de la m&eacute;moire centrale sur l'unit&eacute; centrale o&ugrave;
elles sont ex&eacute;cut&eacute;es.<BR><BR>L'unit&eacute;
centrale&nbsp;:<BR>Elle comprend des circuits logiques et
arithm&eacute;tiques qui effectuent les instructions mais aussi des
m&eacute;moires appel&eacute;es registres.<BR><BR>Certains de ces
registres sont sp&eacute;cialis&eacute;s directement par les
constructeurs de l'unit&eacute; centrale, d'autres le sont par le
programmeur du noyau. Quelques registres sp&eacute;cialis&eacute;s&nbsp;:
</FONT>
</P>
<DL>
	<DT><FONT SIZE=5>L'accumulateur</FONT></DT><DD>
	<FONT SIZE=5>qui re&ccedil;oit le r&eacute;sultat d'une instruction;
	sur les machines &agrave; registres multiples, le jeu d'instructions
	permet souvent d'utiliser n'importe lequel des registres comme
	accumulateur. processus!accumulateur </FONT>
	</DD><DT>
	<FONT SIZE=5>le registre d'instruction</FONT></DT><DD>
	<FONT SIZE=5>(qui contient l'instruction en cours) </FONT>
	</DD><DT>
	<FONT SIZE=5>le compteur ordinal</FONT></DT><DD>
	<FONT SIZE=5>(adresse de l'instruction en m&eacute;moire)
	processus!compteur ordinal Ce compteur change au cours de la
	r&eacute;alisation d'une instruction pour pointer sur la prochaine
	instruction &agrave; ex&eacute;cuter, la majorit&eacute; des
	instructions ne font qu'incr&eacute;menter ce compteur, les
	instructions de branchement r&eacute;alisent des op&eacute;rations
	plus complexes sur ce compteur€: affectation, incr&eacute;mentation
	ou d&eacute;cr&eacute;mentation plus importantes. </FONT>
	</DD><DT>
	<FONT SIZE=5>le registre d'adresse</FONT></DT><DT>
	<FONT SIZE=5>les registres de donn&eacute;es</FONT></DT><DD>
	<FONT SIZE=5>qui sont utilis&eacute;s pour lire ou &eacute;crire une
	donn&eacute;e &agrave; une adresse sp&eacute;cifi&eacute;e en
	m&eacute;moire. </FONT>
	</DD><DT>
	<FONT SIZE=5>les registres d'&eacute;tat</FONT></DT><DD>
	<FONT SIZE=5>du processeur&nbsp;: (actif, mode (user/system),
	retenue, vecteur d'interruptions, etc) </FONT>
	</DD><DT>
	<FONT SIZE=5>les registres d'&eacute;tat du processus</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>droits, adresses, priorit&eacute;s, etc </FONT>
	</DD></DL>
<P>
<FONT SIZE=5>Ces registres forment le contexte <B>d'unit&eacute;
centrale d'un processus</B>. processus!context A tout moment, un
processus est caract&eacute;ris&eacute; par ces deux contextes&nbsp;:
le contexte d'unit&eacute; centrale qui est compos&eacute; des m&ecirc;mes
donn&eacute;es pour tous les processus et le contexte qui d&eacute;pend
du code du programme ex&eacute;cut&eacute;. Pour pouvoir ex&eacute;cuter
un nouveau processus, il faut pouvoir <B>sauvegarder</B> le contexte
d'unit&eacute; centrale du processus courant (mot d'&eacute;tat),
puis charger le nouveau mot d'&eacute;tat du processus &agrave;
ex&eacute;cuter. Cette op&eacute;ration d&eacute;licate r&eacute;alis&eacute;e
de fa&ccedil;on mat&eacute;rielle est appel&eacute;e <B>commutation
de mot d'&eacute;tat.</B> Elle doit se faire de fa&ccedil;on non
interruptible&nbsp;! processus!commutation de mot d'&eacute;tat Cette
&quot;Super instruction&quot; utilise 2 adresses qui sont
respectivement&nbsp;:<BR>l'adresse de sauvegarde du mot d'&eacute;tat
<BR>l'adresse de lecture du nouveau mot d'&eacute;tat<BR>Le compteur
ordinal faisant partie du mot d'&eacute;tat, ce changement provoque
l'ex&eacute;cution dans le nouveau processus. <BR><BR>C'est le
nouveau processus qui devra r&eacute;aliser la sauvegarde du contexte
global. En g&eacute;n&eacute;ral c'est le noyau qui r&eacute;alise
cette sauvegarde, le noyau n'ayant pas un contexte du m&ecirc;me
type.<BR><BR>Le processus interrompu pourra ainsi reprendre
exactement o&ugrave; il avait abandonn&eacute;.<BR><BR>Les fonctions
</FONT><TT><FONT SIZE=5>setjmp</FONT></TT><FONT SIZE=5>/</FONT><TT><FONT SIZE=5>longjmp</FONT></TT><FONT SIZE=5>
permettent de sauvegarder et de r&eacute;initialiser le contexte
d'unit&eacute; central du processus courant, en particulier le
pointeur de pile.<!--TOC section <FONT SIZE=5>Les interruptions</FONT>--></FONT></P>
<H2><FONT SIZE=5>7.8&nbsp;&nbsp; Les interruptions</FONT></H2>
<P><!--SEC END --><EM><FONT SIZE=5>Une interruption est une
commutation de mot d'&eacute;tat provoqu&eacute;e par un signal
produit par le mat&eacute;riel.</FONT></EM><FONT SIZE=5><BR>Ce signal
&eacute;tant la cons&eacute;quence d'un &eacute;v&eacute;nement
ext&eacute;rieur ou int&eacute;rieur, il modifie l'&eacute;tat d'un
indicateur qui est r&eacute;guli&egrave;rement test&eacute; par
l'unit&eacute; centrale.<BR>Une fois que le signal est d&eacute;tect&eacute;,
il faut d&eacute;terminer la cause de l'interruption. Pour cela on
utilise un indicateur, pour les diff&eacute;rentes causes, On parle
alors du <B>vecteur d'interruptions</B>.<BR>interruption Trois grands
types d'interruptions&nbsp;: </FONT>
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5><B>externes</B>
	(ind&eacute;pendantes du processus) interventions de l'op&eacute;rateur,
	pannes,etc </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5><B>d&eacute;routements</B>
	erreur interne du processeur, d&eacute;bordement, division par z&eacute;ro,
	page fault etc (causes qui entraine la r&eacute;alisation d'une
	sauvegarde sur disque de l'image m&eacute;moire &quot;core dumped&quot;
	en g&eacute;n&eacute;ral) </FONT>
	</P>
	<LI><P><FONT SIZE=5><B>appels syst&egrave;mes</B> demande
	d'entr&eacute;e-sortie par exemple. </FONT>
	</P>
</UL>
<P><FONT SIZE=5>Suivant les machines et les syst&egrave;mes un nombre
variable de niveaux d'interruption est utilis&eacute;.</FONT></P>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML036.gif" NAME="Image38" ALIGN=BOTTOM WIDTH=320 HEIGHT=155 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
7.6&nbsp;: Sous UNIX, on trouvera en g&eacute;n&eacute;ral 6 niveaux
d'interruption</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="niveauinterruptions"></A>
<BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<P><FONT SIZE=5>processus!niveau d'interruption Ces diff&eacute;rentes
interruptions ne r&eacute;alisent pas n&eacute;cessairement un
changement de contexte complet du processus courant.</FONT></P>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML037.gif" NAME="Image39" ALIGN=BOTTOM WIDTH=318 HEIGHT=213 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
7.7&nbsp;: Le traitement d'une interruption.</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="traitementinterruption"></A>
<BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<P><FONT SIZE=5>Il est possible que plusieurs niveaux d'interruption
soient positionn&eacute;s quand le syst&egrave;me les consulte. C'est
le niveau des diff&eacute;rentes interruptions qui va permettre au
syst&egrave;me de s&eacute;lectionner l'interruption &agrave; traiter
en priorit&eacute;.<BR><BR>L'horloge est l'interruption la plus
prioritaire sur un syst&egrave;me Unix.<!--TOC section <FONT SIZE=5>Le problème des cascades d'interruptions</FONT>--></FONT></P>
<H2><FONT SIZE=5>7.9&nbsp;&nbsp; Le probl&egrave;me des cascades
d'interruptions</FONT></H2>
<P><!--SEC END --><FONT SIZE=5>Si pendant le traitement d'une
interruption, une autre interruption se produit, et que ceci se
r&eacute;p&egrave;te pendant le traitement de la nouvelle
interruption, le syst&egrave;me ne fait plus progresser les processus
ni les interruptions en cours de traitement ...<BR><BR>Il est donc
n&eacute;cessaire de pouvoir retarder ou annuler la prise en compte
d'un ou plusieurs signaux d'interruptions. C'est le r&ocirc;le des
deux m&eacute;canismes de <B>masquage</B> et de <B>d&eacute;sarmement</B>
d'un niveau d'interruption. masquer Masquer, c'est ignorer
temporairement un niveau d'interruption.<BR><BR>Si ce masquage est
fait dans le mot d'&eacute;tat d'un traitement d'interruption, &agrave;
la nouvelle commutation d'&eacute;tat, le masquage dispara&icirc;t;
les interruptions peuvent de nouveau &ecirc;tre prises en compte.
d&eacute;sarmer D&eacute;sarmer, c'est rendre le positionnement de
l'interruption caduque. (Il est clair que ceci ne peut s'appliquer
aux d&eacute;routements).<!--TOC subsection <FONT SIZE=5> Etats et transitions d'un processus</FONT>--></FONT></P>
<H3><FONT SIZE=5>7.9.1&nbsp;&nbsp; Etats et transitions d'un
processus</FONT></H3>
<P><!--SEC END --><FONT SIZE=5>processus!&eacute;tats </FONT>
</P>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML038.gif" NAME="Image40" ALIGN=BOTTOM WIDTH=360 HEIGHT=396 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
7.8&nbsp;: Diagramme d'&eacute;tat des processus</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="etats"></A><BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<P><FONT SIZE=5>Nous nous pla&ccedil;ons dans le cas d'un syst&egrave;me
qui utilise un m&eacute;canisme de swap pour g&eacute;rer la m&eacute;moire;
nous &eacute;tudierons ensuite le cas des syst&egrave;mes de gestion
pagin&eacute;e de la m&eacute;moire (les couples d'&eacute;tats 3,5
et 4,6 y sont fusionn&eacute;s).<!--TOC subsection <FONT SIZE=5>Listes des états d'un processus</FONT>--></FONT></P>
<H3><FONT SIZE=5>7.9.2&nbsp;&nbsp; Listes des &eacute;tats d'un
processus</FONT></H3>
<P><!--SEC END --><FONT SIZE=5>processus!mode d'un </FONT>
</P>
<OL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>le processus
	s'ex&eacute;cute en mode utilisateur </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>le processus
	s'ex&eacute;cute en mode noyau </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>le processus ne
	s'ex&eacute;cute pas mais est &eacute;ligible (pr&ecirc;t &agrave;
	s'ex&eacute;cuter) </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>le processus est
	endormi en m&eacute;moire centrale </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>le processus est pr&ecirc;t
	mais le swappeur doit le transf&eacute;rer en m&eacute;moire
	centrale pour le rendre &eacute;ligible. (ce mode est diff&eacute;rent
	dans un syst&egrave;me &agrave; pagination). </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>le processus est
	endormi en zone de swap (sur disque par exemple). </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>le processus passe du
	mode noyau au mode utilisateur mais est pr&eacute;empt&eacute;</FONT><A HREF="#note7" NAME="text7"><FONT SIZE=2><SUP>2</SUP></FONT></A><FONT SIZE=5>
	et a effectu&eacute; un changement de contexte pour &eacute;lire un
	autre processus. </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>naissance d'un
	processus, ce processus n'est pas encore pr&ecirc;t et n'est pas
	endormi, c'est l'&eacute;tat initial de tous processus sauf le
	</FONT><EM><FONT SIZE=5>swappeur</FONT></EM><FONT SIZE=5>. </FONT>
	</P>
	<LI><P><EM><FONT SIZE=5>zombie </FONT></EM><FONT SIZE=5>le processus
	vient de r&eacute;aliser un exit, il appara&icirc;t uniquement dans
	la table des processus o&ugrave; il est conserv&eacute; le temps
	pour son processus p&egrave;re de r&eacute;cup&egrave;rer le code de
	retour et d'autres informations de gestion (co&ucirc;t de
	l'ex&eacute;cution sous forme de temps, et d'utilisation des
	ressources ). </FONT>
	</P>
</OL>
<P><FONT SIZE=5>L'&eacute;tat </FONT><EM><FONT SIZE=5>zombie</FONT></EM><FONT SIZE=5>
est l'&eacute;tat final des processus, les processus restent dans cet
&eacute;tat jusqu'&agrave; ce que leur p&egrave;re lise leur valeur
de retour (exit status).<!--TOC section <FONT SIZE=5>Lecture du diagramme d'état.</FONT>--></FONT></P>
<H2><FONT SIZE=5>7.10&nbsp;&nbsp; Lecture du diagramme d'&eacute;tat.</FONT></H2>
<P><!--SEC END --><FONT SIZE=5>Le diagramme des transitions d'&eacute;tat
permet de d&eacute;crire l'ensemble des &eacute;tats possibles d'un
processus. Il est clair que tout processus ne passera pas
n&eacute;cessairement par tous ces diff&eacute;rents &eacute;tats.<BR><BR>La
naissance d'un processus a lieu dans l'&eacute;tat 8 apr&egrave;s
l'appel syst&egrave;me </FONT><TT><FONT SIZE=5>fork</FONT></TT><FONT SIZE=5>
ex&eacute;cut&eacute; par un autre processus. Il devient au bout d'un
certain temps &quot;pr&ecirc;t &agrave; s'ex&eacute;cuter&quot;. Il
passe alors dans l'&eacute;tat &quot;ex&eacute;cut&eacute; en mode
noyau&quot; o&ugrave; il termine sa partie de l'appel syst&egrave;me
</FONT><TT><FONT SIZE=5>fork</FONT></TT><FONT SIZE=5>. Puis le
processus termine l'appel syst&egrave;me et passe dans l'&eacute;tat
&quot;ex&eacute;cut&eacute; en mode utilisateur&quot;. appels
syst&egrave;mes!fork@</FONT><TT><FONT SIZE=5>fork</FONT></TT><FONT SIZE=5>
Pass&eacute; une certaine p&eacute;riode de temps (variable d'un
syst&egrave;me &agrave; l'autre), l'horloge peut <I><FONT COLOR="#800000">interrompre</FONT></I>
le processeur. Le processus rentre alors en mode noyau,
l'interruption est alors r&eacute;alis&eacute;e avec le processus en
mode noyau.<BR><BR>Au retour de l'interruption, le processus peut
&ecirc;tre </FONT><TT><FONT SIZE=5>pr&eacute;empt&eacute;</FONT></TT><FONT SIZE=5>
(&eacute;tant rest&eacute; tout son quantum de temps sur le cpu),
c'est &agrave; dire, il reste pr&ecirc;t &agrave; s'ex&eacute;cuter
mais un autre processus est &eacute;lu. Cet &eacute;tat 7 est
logiquement &eacute;quivalent &agrave; l'&eacute;tat 3, mais il
existe pour mat&eacute;rialiser le fait qu'un processus ne peut &ecirc;tre
pr&eacute;empt&eacute; qu'au moment o&ugrave; il retourne du mode
noyau au mode utilisateur. Quand un processus pr&eacute;empt&eacute;
est r&eacute;&eacute;lu, il retourne directement en mode
utilisateur.<BR><BR>Un appel syst&egrave;me ne peut &ecirc;tre
pr&eacute;empt&eacute;. On peut d&eacute;tecter en pratique cette
r&egrave;gle, en effet on constate un ralentissement du d&eacute;bit
de la machine pendant la r&eacute;alisation d'un core de grande
taille.<BR><BR>Quand un processus ex&eacute;cute un appel syst&egrave;me,
il passe du mode utilisateur au mode syst&egrave;me. Supposons que
l'appel syst&egrave;me r&eacute;alise une entr&eacute;e-sortie sur le
disque et que le processus doive attendre la fin de l'entr&eacute;e-sortie.
Le processus est mis en sommeil (sleep) et passe dans l'&eacute;tat
endormi en m&eacute;moire. Quand l'entr&eacute;e-sortie se termine,
une interruption a lieu, le traitement de l'interruption consistant &agrave;
faire passer le processus dans le mode pr&ecirc;t &agrave; s'ex&eacute;cuter
(en m&eacute;moire).<!--TOC section <FONT SIZE=5>Un exemple d'exécution</FONT>--></FONT></P>
<H2><FONT SIZE=5>7.11&nbsp;&nbsp; Un exemple d'ex&eacute;cution</FONT></H2>
<P><FONT SIZE=5><!--SEC END -->Pla&ccedil;ons-nous dans la situation
suivante&nbsp;: l'ensemble de la m&eacute;moire est occup&eacute; par
des processus, mais, le processus le plus prioritaire est un
processus dans l'&eacute;tat 5, soit&nbsp;: &quot;pr&ecirc;t &agrave;
s'ex&eacute;cuter en zone de swap&quot;. Pour pouvoir ex&eacute;cuter
ce processus, il faut le placer dans l'&eacute;tat 3, soit&nbsp;:
&quot;pr&ecirc;t &agrave; s'ex&eacute;cuter en m&eacute;moire&quot;.
Pour cela le syst&egrave;me doit lib&eacute;rer de la m&eacute;moire
(faire de la place), en faisant passer des processus des &eacute;tats
3 ou 4 en zone de swap (swapout) donc les faire passer dans les &eacute;tats
5 et 6.<BR><BR>C'est au swappeur de r&eacute;aliser les deux
op&eacute;rations&nbsp;: </FONT>
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>S&eacute;lectionner
	une victime (le processus le plus appropri&eacute;), pour un
	transfert hors m&eacute;moire centrale (swapout). </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>r&eacute;aliser ce
	transfert. </FONT>
	</P>
	<LI><P><FONT SIZE=5>une fois qu'une place suffisante est lib&eacute;r&eacute;e,
	le processus qui a provoqu&eacute; le swapout est charg&eacute; en
	m&eacute;moire (swapin). </FONT>
	</P>
</UL>
<P><FONT SIZE=5>processus!swapin processus!swapout <BR><BR>Le
processus a un contr&ocirc;le sur un nombre r&eacute;duit de
transitions&nbsp;: il peut faire un appel syst&egrave;me, r&eacute;aliser
un </FONT><TT><FONT SIZE=5>exit</FONT></TT><FONT SIZE=5>, r&eacute;aliser
un </FONT><TT><FONT SIZE=5>sleep</FONT></TT><FONT SIZE=5>, les autres
transitions lui sont dict&eacute;es par les circonstances. appels
syst&egrave;mes!sleep@</FONT><TT><FONT SIZE=5>sleep</FONT></TT><FONT SIZE=5>
<BR><BR>L'appel &agrave; </FONT><TT><FONT SIZE=5>exit()</FONT></TT><FONT SIZE=5>
fait passer dans l'&eacute;tat zombie, il est possible de passer &agrave;
l'&eacute;tat zombie sans que le processus ait explicitement appel&eacute;
</FONT><TT><FONT SIZE=5>exit()</FONT></TT><FONT SIZE=5> (&agrave; la
r&eacute;ception de certains signaux par exemple). appels
syst&egrave;mes!exit@</FONT><TT><FONT SIZE=5>exit</FONT></TT><FONT SIZE=5>
Toutes les autres transitions d'&eacute;tat sont s&eacute;lectionn&eacute;es
et r&eacute;alis&eacute;es par le noyau selon des r&egrave;gles bien
pr&eacute;cises. Une de ces r&egrave;gles est par exemple qu'un
processus en mode noyau ne peut &ecirc;tre pr&eacute;empt&eacute;</FONT><A HREF="#note8" NAME="text8"><FONT SIZE=2><SUP>3</SUP></FONT></A><FONT SIZE=5>.
Certaines de ces r&egrave;gles sont d&eacute;finies par l'algorithme
d'ordonnancement utilis&eacute;.<!--TOC section <FONT SIZE=5>La table des processus</FONT>--></FONT></P>
<H2><FONT SIZE=5>7.12&nbsp;&nbsp; La table des processus</FONT></H2>
<P><!--SEC END --><FONT SIZE=5>La table des processus est dans la
m&eacute;moire du noyau. C'est un tableau de structure proc
(</FONT><CODE><FONT SIZE=5>&lt;sys/proc.h&gt;</FONT></CODE><FONT SIZE=5>).
Cette structure contient les informations qui doivent toujours &ecirc;tre
accessibles par le noyau. </FONT>
</P>
<DL>
	<DT><FONT SIZE=5>processus!&eacute;tats &eacute;tat</FONT></DT><DD>
	<FONT SIZE=5>se reporter au diagramme, ce champ permet au noyau de
	prendre des d&eacute;cisions sur les changements d'&eacute;tat &agrave;
	effectuer sur le processus. </FONT>
	</DD><DT>
	<FONT SIZE=5>adresse de la zone u</FONT></DT><DT>
	<FONT SIZE=5>adresses</FONT></DT><DD>
	<FONT SIZE=5>taille et localisation en m&eacute;moire (centrale,
	secondaire). Ces informations permettent de transf&eacute;rer un
	processus en ou hors m&eacute;moire centrale. </FONT>
	</DD><DT>
	<FONT SIZE=5>UID</FONT></DT><DD>
	<FONT SIZE=5>propri&eacute;taire du processus, permet de savoir si
	le processus est autoris&eacute; &agrave; envoyer des signaux et &agrave;
	qui il peut les envoyer. </FONT>
	</DD><DT>
	<FONT SIZE=5>PID,PPID</FONT></DT><DD>
	<FONT SIZE=5>l'identificateur du processus et de son p&egrave;re.
	Ces deux valeurs sont initialis&eacute;es dans l'&eacute;tat 8,
	cr&eacute;ation pendant l'appel syst&egrave;me </FONT><TT><FONT SIZE=5>fork</FONT></TT><FONT SIZE=5>.
	</FONT>
	</DD><DT>
	<FONT SIZE=5>&eacute;v&egrave;nement</FONT></DT><DD>
	<FONT SIZE=5>un descripteur de l'&eacute;v&egrave;nement attendu
	quand le processus est dans un mode endormi. </FONT>
	</DD><DT>
	<FONT SIZE=5>Priorit&eacute;s</FONT></DT><DD>
	<FONT SIZE=5>Plusieurs param&egrave;tres sont utilis&eacute;s par
	l'ordonnanceur pour s&eacute;lectionner l'&eacute;lu parmi les
	processus pr&ecirc;ts. </FONT>
	</DD><DT>
	<FONT SIZE=5>vecteur d'interruption du processus</FONT></DT><DD>
	<FONT SIZE=5>ensemble des signaux re&ccedil;us par le processus mais
	pas encore trait&eacute;s. </FONT>
	</DD><DT>
	<FONT SIZE=5>divers</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>des compteurs utilis&eacute;s pour la comptabilit&eacute;
	(pour faire payer le temps CPU utilis&eacute;) et que l'on peut
	manipuler par la commande </FONT><TT><FONT SIZE=5>alarm</FONT></TT><FONT SIZE=5>,
	des donn&eacute;es utilis&eacute;es par l'impl&eacute;mentation
	effective du syst&egrave;me, etc. </FONT>
	</DD></DL>
<H2>
<FONT SIZE=5><!--TOC section <FONT SIZE=5>La zone u</FONT>-->7.13&nbsp;&nbsp;
La zone u</FONT></H2>
<P><!--SEC END --><FONT SIZE=5>processus!zone u|( La zone u de type
</FONT><TT><FONT SIZE=5>struct user</FONT></TT><FONT SIZE=5> d&eacute;finie
dans </FONT><CODE><TT><FONT SIZE=5>&lt;sys/user.h&gt;</FONT></TT></CODE><FONT SIZE=5>
est la zone utilis&eacute;e quand un processus s'ex&eacute;cute que
ce soit en mode noyau ou mode utilisateur. Une unique zone u est
accessible &agrave; la fois &nbsp;: celle de l'unique processus en
cours d'ex&eacute;cution (dans un des &eacute;tats 1 ou 2).<BR>Contenu
de la zone u&nbsp;: </FONT>
</P>
<DL>
	<DT><FONT SIZE=5>pointeur</FONT></DT><DD>
	<FONT SIZE=5>sur la structure de processus de la table des
	processus. </FONT>
	</DD><DT>
	<FONT SIZE=5>uid r&eacute;el et effectif</FONT></DT><DD>
	<FONT SIZE=5>de l'utilisateur qui d&eacute;termine les divers
	privil&egrave;ges donn&eacute;s au processus, tels que les droits
	d'acc&egrave;s &agrave; un fichier, les changements de priorit&eacute;,
	etc. </FONT>
	</DD><DT>
	<FONT SIZE=5>Compteurs des temps</FONT></DT><DD>
	<FONT SIZE=5>(users et system) consomm&eacute;s par le processus </FONT>
	</DD><DT>
	<FONT SIZE=5>Masque de signaux</FONT></DT><DD>
	<FONT SIZE=5>Sur syst&egrave;me V sous BSD dans la structure proc </FONT>
	</DD><DT>
	<FONT SIZE=5>Terminal</FONT></DT><DD>
	<FONT SIZE=5>terminal de contr&ocirc;le du processus si celui-ci
	existe. </FONT>
	</DD><DT>
	<FONT SIZE=5>erreur</FONT></DT><DD>
	<FONT SIZE=5>stockage de la derni&egrave;re erreur rencontr&eacute;e
	pendant un appel syst&egrave;me. </FONT>
	</DD><DT>
	<FONT SIZE=5>retour</FONT></DT><DD>
	<FONT SIZE=5>stockage de valeur de retour du dernier appel syst&egrave;me.
	</FONT>
	</DD><DT>
	<FONT SIZE=5>E/S</FONT></DT><DD>
	<FONT SIZE=5>les structures associ&eacute;es aux entr&eacute;es-sorties,
	les param&egrave;tres utilis&eacute;s par la biblioth&egrave;que
	standard, adresses des buffers, tailles et adresses de zones &agrave;
	copier, etc. </FONT>
	</DD><DT>
	<FONT SIZE=5>&quot;.&quot; et &quot;/&quot; </FONT>
	</DT><DD>
	<FONT SIZE=5>le r&eacute;pertoire courant et la racine courante
	(c.f. chroot()) </FONT>
	</DD><DT>
	<FONT SIZE=5>la table des descripteurs</FONT></DT><DD>
	<FONT SIZE=5>position variable d'un impl&eacute;mentation &agrave;
	l'autre. </FONT>
	</DD><DT>
	<FONT SIZE=5>limites</FONT></DT><DD>
	<FONT SIZE=5>de la taille des fichiers de la m&eacute;moire
	utilisable etc &frac14;(c.f. </FONT><EM><FONT SIZE=5>ulimit</FONT></EM><FONT SIZE=5>
	en Bourne shell et </FONT><EM><FONT SIZE=5>limit</FONT></EM><FONT SIZE=5>
	en Csh ). </FONT>
	</DD><DT>
	<FONT SIZE=5>umask</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>masque de cr&eacute;ation de fichiers. </FONT>
	</DD></DL>
<P>
<FONT SIZE=5>processus!zone u|) <!--TOC section <FONT SIZE=5>Accès aux structures </FONT><FONT SIZE=5><TT>proc</TT></FONT><FONT SIZE=5> et </FONT><FONT SIZE=5><TT>user</TT></FONT><FONT SIZE=5> du processus courant</FONT>--></FONT></P>
<H2>7.14&nbsp;&nbsp; Acc&egrave;s aux structures <TT>proc</TT> et
<TT>user</TT> du processus courant</H2>
<P><!--SEC END --><FONT SIZE=5>Les informations de la table des
processus peuvent &ecirc;tre lues gr&acirc;ce &agrave; la commande
shell </FONT><TT><FONT SIZE=5>ps</FONT></TT><FONT SIZE=5>. Ou par des
appels syst&egrave;me. Par contre, les informations contenues dans la
zone u ne sont accessibles que par une r&eacute;ponse du processus
lui-m&ecirc;me (en progammation objet, on dit que ce sont des
variables d'instances priv&eacute;es), d'o&ugrave; les appels syst&egrave;me
suivants&nbsp;:<BR></FONT><TT><FONT SIZE=5>times, chroot, chdir,
fchdir, getuid, getgid, ..., setuid, ..., ulimit, nice, brk,
sbrk</FONT></TT><FONT SIZE=5>.<BR>Qui permettent de lire ou de
changer le contenu des deux structures.<!--TOC subsection <FONT SIZE=5>Les informations temporelles.</FONT>--></FONT></P>
<H3><FONT SIZE=5>7.14.1&nbsp;&nbsp; Les informations temporelles.</FONT></H3>
<PRE><!--SEC END -->
<FONT SIZE=5>#include &lt;sys/times.h&gt;</FONT>
<FONT SIZE=5>clock_t times(struct tms *buffer);</FONT></PRE><P>
<FONT SIZE=5>appels syst&egrave;mes!times@</FONT><TT><FONT SIZE=5>times</FONT></TT><FONT SIZE=5>
<BR><BR></FONT><EM><FONT SIZE=5>times</FONT></EM><FONT SIZE=5>
remplit la structure point&eacute;e par </FONT><TT><FONT SIZE=5>buffer</FONT></TT><FONT SIZE=5>
avec des informations sur le temps machine utilis&eacute; dans les
&eacute;tat 1 et 2.<BR>La structure&nbsp;&nbsp;:</FONT></P>
<PRE>
<FONT SIZE=5>struct tms {</FONT>
<FONT SIZE=5>       clock_t    tms_utime;      /* user time */</FONT>
<FONT SIZE=5>       clock_t    tms_stime;      /* system time */</FONT>
<FONT SIZE=5>       clock_t    tms_cutime;     /* user time, children */</FONT>
<FONT SIZE=5>       clock_t    tms_cstime;     /* system time, children */</FONT>
<FONT SIZE=5>      };</FONT></PRE><P>
<FONT SIZE=5>contient des temps indiqu&eacute;s en microsecondes 10-6
secondes, la pr&eacute;cision de l'horloge est par defaut sur les
HP9000 700/800 de 10 microsecondes.<!--TOC subsection <FONT SIZE=5>Changement du répertoire racine pour un processus.</FONT>--></FONT></P>
<H3><FONT SIZE=5>7.14.2&nbsp;&nbsp; Changement du r&eacute;pertoire
racine pour un processus.</FONT></H3>
<PRE><!--SEC END -->
<FONT SIZE=5>#include &lt;unistd.h&gt;</FONT>
<FONT SIZE=5>int chroot(const char *path);</FONT></PRE><P>
<FONT SIZE=5>appels syst&egrave;mes!chroot@</FONT><TT><FONT SIZE=5>chroot</FONT></TT><FONT SIZE=5>
<BR><BR>permet de d&eacute;finir un nouveau point de d&eacute;part
pour les r&eacute;f&eacute;rences absolues (commen&ccedil;ant par /).
La r&eacute;f&eacute;rence .. de ce r&eacute;pertoire racine est
associ&eacute;e &agrave; lui-m&ecirc;me, il n'est donc pas possible
de sortir du sous-arbre d&eacute;fini par </FONT><TT><FONT SIZE=5>chroot</FONT></TT><FONT SIZE=5>.
Cet appel est utilis&eacute; pour rsh et ftp, et les comptes pour
invit&eacute;s.<BR><BR>Les appels suivants permettent de changer le
r&eacute;pertoire de travail de r&eacute;f&eacute;rence ``.'' et donc
l'interpr&eacute;tation des r&eacute;f&eacute;rences relatives&nbsp;:
</FONT>
</P>
<PRE>
<FONT SIZE=5>int chdir(char *ref);</FONT>
<FONT SIZE=5>int fchdir(int descripteur);</FONT></PRE><P>
<FONT SIZE=5>appels syst&egrave;mes!chdir@</FONT><TT><FONT SIZE=5>chdir</FONT></TT><FONT SIZE=5>
appels syst&egrave;mes!fchdir@</FONT><TT><FONT SIZE=5>fchdir</FONT></TT><FONT SIZE=5>
<!--TOC subsection <FONT SIZE=5>Récupération du PID d'un processus</FONT>--></FONT></P>
<H3><FONT SIZE=5>7.14.3&nbsp;&nbsp; R&eacute;cup&eacute;ration du PID
d'un processus</FONT></H3>
<PRE><!--SEC END -->
<FONT SIZE=5>#include &lt;unistd.h&gt;</FONT>
<FONT SIZE=5>pid_t   getpid(void);</FONT>
<FONT SIZE=5>pid_t   getpgrp(void);</FONT>
<FONT SIZE=5>pid_t   getppid(void);</FONT>
<FONT SIZE=5>pid_t   getpgrp2(pid_t pid);</FONT></PRE><P>
<FONT SIZE=5>appels syst&egrave;mes!getpgrp2@</FONT><TT><FONT SIZE=5>getpgrp2</FONT></TT><FONT SIZE=5>
appels syst&egrave;mes!getppid@</FONT><TT><FONT SIZE=5>getppid</FONT></TT><FONT SIZE=5>
appels syst&egrave;mes!getpgrp@</FONT><TT><FONT SIZE=5>getpgrp</FONT></TT><FONT SIZE=5>
appels syst&egrave;mes!getpid@</FONT><TT><FONT SIZE=5>getpid</FONT></TT><FONT SIZE=5>
L'appel </FONT><TT><FONT SIZE=5>getpid()</FONT></TT><FONT SIZE=5>
retourne le PID du processus courant, </FONT><TT><FONT SIZE=5>getppid</FONT></TT><FONT SIZE=5>
le PID du processus p&egrave;re, </FONT><TT><FONT SIZE=5>getpgrp</FONT></TT><FONT SIZE=5>
le PID du groupe du processus courant, </FONT><TT><FONT SIZE=5>getpgrp2</FONT></TT><FONT SIZE=5>
le PID du groupe du processus pid (si pid=0 alors &eacute;quivalent &agrave;
</FONT><TT><FONT SIZE=5>getpgrp</FONT></TT><FONT SIZE=5>).<!--TOC subsection <FONT SIZE=5>Positionement de l'euid, ruid et suid</FONT>--></FONT></P>
<H3><FONT SIZE=5>7.14.4&nbsp;&nbsp; Positionement de l'euid, ruid et
suid</FONT></H3>
<P><FONT SIZE=5><!--SEC END -->L'uid d'un processus est
l'identification de l'utilisateur ex&eacute;cutant le processus. Le
syst&egrave;me utilise trois uid qui sont&nbsp;:</FONT></P>
<DL>
	<DT><FONT SIZE=5>euid</FONT></DT><DD>
	<FONT SIZE=5>uid effective utilis&eacute; pour les tests d'acc&egrave;s.
	</FONT>
	</DD><DT>
	<FONT SIZE=5>ruid</FONT></DT><DD>
	<FONT SIZE=5>uid r&eacute;elle, uid &agrave; qui est factur&eacute;
	le temps de calcul. </FONT>
	</DD><DT>
	<FONT SIZE=5>suid</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>uid sauvegard&eacute;e, pour pouvoir revenir en arri&egrave;re
	apr&egrave;s un setuid. </FONT>
	</DD></DL>
<PRE>
<FONT SIZE=5>#include &lt;unistd.h&gt;</FONT>
<FONT SIZE=5>int setuid(uid_t uid);</FONT>
<FONT SIZE=5>int setgid(gid_t gid);</FONT></PRE><P>
<FONT SIZE=5>appels syst&egrave;mes!setgid@</FONT><TT><FONT SIZE=5>setgid</FONT></TT><FONT SIZE=5>
appels syst&egrave;mes!setuid@</FONT><TT><FONT SIZE=5>setuid</FONT></TT><FONT SIZE=5>
<BR><BR>Fonctionnement&nbsp;:<BR>si euid == 0 (euid de root) les
trois uid sont positionn&eacute;s &agrave; la valeur de uid<BR>sinon
si uid est &eacute;gal &agrave; ruid ou suid alors euid devient uid.
ruid et suid ne changent pas. sinon rien! pas de changements.<BR>Syntaxe
identique pour setgid et gid.<BR><BR>La commande </FONT><EM><FONT SIZE=5>setreuid()</FONT></EM><FONT SIZE=5>
permet de changer le propi&eacute;taire r&eacute;el du processus,
elle est utilis&eacute; pendant le login, seul le super utilisateur
peut l'ex&eacute;cuter avec succ&egrave;s.<!--TOC section <FONT SIZE=5>Tailles limites d'un processus</FONT>--></FONT></P>
<H2><FONT SIZE=5>7.15&nbsp;&nbsp; Tailles limites d'un processus</FONT></H2>
<PRE><!--SEC END -->
<FONT SIZE=5>#include &lt;ulimit.h&gt;</FONT>
<FONT SIZE=5>long ulimit(int cmd,...);</FONT></PRE><P>
<FONT SIZE=5>appels syst&egrave;mes!ulimit@</FONT><TT><FONT SIZE=5>ulimit</FONT></TT><FONT SIZE=5>
<BR><BR>La commande </FONT><EM><FONT SIZE=5>cmd</FONT></EM><FONT SIZE=5>
est </FONT>
</P>
<DL>
	<DT><FONT SIZE=5>UL_GETFSIZE</FONT></DT><DD>
	<FONT SIZE=5>retourne le taille maximum des fichiers en blocs. </FONT>
	</DD><DT>
	<FONT SIZE=5>UL_SETFSIZE</FONT></DT><DD>
	<FONT SIZE=5>positionne cette valeur avec le deuxi&egrave;me
	argument. </FONT>
	</DD><DT>
	<FONT SIZE=5>UL_GETMAXBRK</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>valeur maximale pour l'appel d'allocation dynamique de
	m&eacute;moire&nbsp;: brk. </FONT>
	</DD></DL>
<P>
<FONT SIZE=5>Ces valeurs sont h&eacute;rit&eacute;es du processus
p&egrave;re.<BR><BR>La valeur FSIZE (taille maximum des fichiers sur
disques en blocs) peut &ecirc;tre chang&eacute;e en ksh avec ulimit
[n].<!--TOC subsection <FONT SIZE=5>Manipulation de la taille d'un processus.</FONT>--></FONT></P>
<H3><FONT SIZE=5>7.15.1&nbsp;&nbsp; Manipulation de la taille d'un
processus.</FONT></H3>
<PRE><!--SEC END -->
<FONT SIZE=5>#include &lt;unistd.h&gt;</FONT>
<FONT SIZE=5>int brk(const void *endds);</FONT>
<FONT SIZE=5>void *sbrk(int incr);</FONT></PRE><P>
<FONT SIZE=5>appels syst&egrave;mes!brk@</FONT><TT><FONT SIZE=5>brk</FONT></TT><FONT SIZE=5>
appels syst&egrave;mes!sbrk@</FONT><TT><FONT SIZE=5>sbrk</FONT></TT><FONT SIZE=5>
Les deux appels permettent de changer la taille du processus.
L'adresse manipul&eacute;e par les deux appels est la premi&egrave;re
adresse qui est en dehors du processus. Ainsi on r&eacute;alise des
augmentations de la taille du processus avec des appels &agrave; </FONT><TT><FONT SIZE=5>sbrk</FONT></TT><FONT SIZE=5>
et on utilise les adresses retourn&eacute;es par </FONT><TT><FONT SIZE=5>sbrk</FONT></TT><FONT SIZE=5>
pour les appels &agrave; </FONT><TT><FONT SIZE=5>brk</FONT></TT><FONT SIZE=5>
pour r&eacute;duire la taille du processus. On utilisera de
pr&eacute;f&eacute;rence pour les appels &agrave; </FONT><TT><FONT SIZE=5>sbrk</FONT></TT><FONT SIZE=5>
des valeurs de </FONT><TT><FONT SIZE=5>incr</FONT></TT><FONT SIZE=5>
qui sont des multiples de la taille de page. Le syst&egrave;me
r&eacute;alisant des d&eacute;placement du point de rupture par
nombre entier de pages (ce qui est logique dans un syst&egrave;me de
m&eacute;moire pagin&eacute;). A ne pas utiliser en conjonction avec
les fonctions d'allocation standard </FONT><TT><FONT SIZE=5>malloc,
calloc, realloc, free</FONT></TT><FONT SIZE=5>.<!--TOC subsection <FONT SIZE=5>Manipulation de la valeur nice</FONT>--></FONT></P>
<H3><FONT SIZE=5>7.15.2&nbsp;&nbsp; Manipulation de la valeur nice</FONT></H3>
<P><!--SEC END --><FONT SIZE=5>Permet de changer la valeur de </FONT><EM><FONT SIZE=5>nice</FONT></EM><FONT SIZE=5>
utilis&eacute;e par le processus. Si l'on a des droits privil&eacute;gi&eacute;s
la valeur peut &ecirc;tre n&eacute;gative. La valeur de nice est
toujours comprise entre 0 et 39. </FONT>
</P>
<PRE>
<FONT SIZE=5>#include &lt;unistd.h&gt;</FONT>
<FONT SIZE=5>int  nice(int valeur);</FONT></PRE><P>
<FONT SIZE=5>appels syst&egrave;mes!nice@</FONT><TT><FONT SIZE=5>nice</FONT></TT><FONT SIZE=5>
<BR><BR>La commande shell </FONT><TT><FONT SIZE=5>renice</FONT></TT><FONT SIZE=5>
permet de changer le nice d'un processus actif.<!--TOC subsection <FONT SIZE=5>Manipulation de la valeur umask</FONT>--></FONT></P>
<H3><FONT SIZE=5>7.15.3&nbsp;&nbsp; Manipulation de la valeur umask</FONT></H3>
<P><!--SEC END --><FONT SIZE=5>L'appel </FONT><TT><FONT SIZE=5>umask
</FONT></TT><FONT SIZE=5>permet de sp&eacute;cifier quels droits
doivent &ecirc;tre interdits en cas de cr&eacute;ation de fichier.
cf. </FONT><A HREF="#open"><FONT SIZE=5>6.1</FONT></A><FONT SIZE=5> </FONT>
</P>
<PRE>
<FONT SIZE=5>#include &lt;sys/stat.h&gt;</FONT>
<FONT SIZE=5>mode_t umask(mode_t mask);</FONT></PRE><P>
<FONT SIZE=5>appels syst&egrave;mes!umask@</FONT><TT><FONT SIZE=5>umask</FONT></TT><FONT SIZE=5>
la valeur retourn&eacute;e est l'ancienne valeur.<!--TOC section <FONT SIZE=5>L'appel système </FONT><FONT SIZE=5><TT>fork</TT></FONT>--></FONT></P>
<H2>7.16&nbsp;&nbsp; L'appel syst&egrave;me <TT>fork</TT></H2>
<P><!--SEC END --><FONT SIZE=5>l'appel syst&egrave;me </FONT><TT><FONT SIZE=5>fork</FONT></TT><FONT SIZE=5>
permet le cr&eacute;ation d'un processus cl&ocirc;ne du processus
courrant. </FONT>
</P>
<PRE>
<FONT SIZE=5>pid_t  fork(void);</FONT></PRE><P>
<FONT SIZE=5>appels syst&egrave;mes!fork@</FONT><TT><FONT SIZE=5>fork</FONT></TT><FONT SIZE=5>
<BR><BR><B>DEUX</B> valeurs de retour en cas de succ&egrave;s&nbsp;: </FONT>
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Dans le processus
	p&egrave;re valeur de retour = le PID du fils, </FONT>
	</P>
	<LI><P><FONT SIZE=5>Dans le processus fils valeur de retour = z&eacute;ro.
	</FONT>
	</P>
</UL>
<P><FONT SIZE=5>Sinon </FONT>
</P>
<UL>
	<LI><P><FONT SIZE=5>Dans le processus p&egrave;re valeur de retour =
	-1. </FONT>
	</P>
</UL>
<P><FONT SIZE=5>Les </FONT><TT><FONT SIZE=5>PID</FONT></TT><FONT SIZE=5>
et </FONT><TT><FONT SIZE=5>PPID</FONT></TT><FONT SIZE=5> sont les
seules informations diff&eacute;rentes entre les deux processus.<!--TOC section <FONT SIZE=5>L'appel système </FONT><FONT SIZE=5><TT>exec</TT></FONT>--></FONT></P>
<H2>7.17&nbsp;&nbsp; L'appel syst&egrave;me <TT>exec</TT></H2>
<PRE><!--SEC END -->
<FONT SIZE=5>#include &lt;unistd.h&gt;</FONT>
<FONT SIZE=5>extern char **environ;</FONT>

<FONT SIZE=5>int execl( const char *path, const char *arg0, ...,NULL);</FONT>
<FONT SIZE=5>int execv(const char *path, char * const argv[]);</FONT>
<FONT SIZE=5>int execle( const char *path, const char *arg0, ...,NULL,  char * const envp[]);</FONT>

<FONT SIZE=5>int execve(const char *file, char * const argv[], char * const envp[]);</FONT>
<FONT SIZE=5>int execlp( const char *file,const char *arg0, ... , NULL );</FONT>
<FONT SIZE=5>int execvp(const char *file, char * const argv[]);</FONT>
</PRE><P>
<FONT SIZE=5>appels syst&egrave;mes!execv@</FONT><TT><FONT SIZE=5>execv</FONT></TT><FONT SIZE=5>
appels syst&egrave;mes!execvp@</FONT><TT><FONT SIZE=5>execvp</FONT></TT><FONT SIZE=5>
appels syst&egrave;mes!execlp@</FONT><TT><FONT SIZE=5>execlp</FONT></TT><FONT SIZE=5>
appels syst&egrave;mes!execve@</FONT><TT><FONT SIZE=5>execve</FONT></TT><FONT SIZE=5>
appels syst&egrave;mes!execle@</FONT><TT><FONT SIZE=5>execle</FONT></TT><FONT SIZE=5>
<BR><BR>Informations conserv&eacute;es par le processus&nbsp;: PID
PPID PGID ruid suid (pour l'euid cf le </FONT><TT><FONT SIZE=5>setuidbit
</FONT></TT><FONT SIZE=5>de </FONT><TT><FONT SIZE=5>chmod </FONT></TT><FONT SIZE=5>),
nice, groupe d'acc&egrave;s, catalogue courant, catalogue ``/'',
terminal de contr&ocirc;le, utilisation et limites des ressources
(temps machine, m&eacute;moire, etc), umask, masques des signaux,
signaux en attente, table des descripteurs de fichiers, verrous,
session.<BR><BR>Quand le processus ex&eacute;cute dans le nouvel
ex&eacute;cutable la fonction&nbsp;: </FONT>
</P>
<PRE>
<FONT SIZE=5> main(int argc, char **argv,char **envp)</FONT></PRE><P>
<EM><FONT SIZE=5>argv</FONT></EM><FONT SIZE=5> et </FONT><EM><FONT SIZE=5>env</FONT></EM><FONT SIZE=5>
sont ceux qui ont &eacute;t&eacute; utilis&eacute;s dans l'appel de
</FONT><TT><FONT SIZE=5>execve</FONT></TT><FONT SIZE=5>.<BR>appels
syst&egrave;mes!execve@</FONT><TT><FONT SIZE=5>execve</FONT></TT><FONT SIZE=5>
<BR><BR>Les diff&eacute;rents noms des fonction </FONT><TT><FONT SIZE=5>exec</FONT></TT><FONT SIZE=5>
sont des mn&eacute;moniques&nbsp;: </FONT>
</P>
<DL>
	<DT><TT><FONT SIZE=5>l</FONT></TT></DT><DD>
	<FONT SIZE=5>liste d'arguments </FONT>
	</DD><DT>
	<TT><FONT SIZE=5>v</FONT></TT></DT><DD>
	<FONT SIZE=5>arguments sont forme d'un vecteur. </FONT>
	</DD><DT>
	<TT><FONT SIZE=5>p</FONT></TT></DT><DD>
	<FONT SIZE=5>recherche du fichier avec la variable d'environnement
	</FONT><TT><FONT SIZE=5>PATH</FONT></TT><FONT SIZE=5>. </FONT>
	</DD><DT>
	<TT><FONT SIZE=5>e</FONT></TT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>transmission d'un environnement en dernier param&egrave;tre,
	en remplacement de l'environnement courant. </FONT>
	</DD></DL>
<P STYLE="margin-left: 6.4cm; margin-right: 6.4cm; border-top: none; border-bottom: 1.10pt double #808080; border-left: none; border-right: none; padding: 0cm">
<FONT SIZE=1 STYLE="font-size: 6pt"><!--BEGIN NOTES chapter--></FONT><BR><BR>
</P>
<DL>
	<DT><A HREF="#text6" NAME="note6"><FONT SIZE=5>1</FONT></A></DT><DD>
	<FONT SIZE=5>swappeur,gestionnaire de pages </FONT>
	</DD><DT>
	<A HREF="#text7" NAME="note7"><FONT SIZE=5>2</FONT></A></DT><DD>
	<FONT SIZE=5>Bien que le processus soit pr&ecirc;t, il est retir&eacute;
	de l'unit&eacute; de traitement pour que les autres processus
	puissent avancer. </FONT>
	</DD><DT>
	<A HREF="#text8" NAME="note8"><FONT SIZE=5>3</FONT></A></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>Exercice&nbsp;: Donner un exemple. </FONT>
	</DD></DL>
<H1>
<FONT SIZE=5><!--END NOTES--><!--TOC chapter <FONT SIZE=5>L'ordonnancement des processus</FONT>-->Chapitre&nbsp;8&nbsp;&nbsp;
L'ordonnancement des processus</FONT></H1>
<P><!--SEC END --><FONT SIZE=5>ordonnancement La s&eacute;lection
dans le temps des processus pouvant acc&egrave;der &agrave; une
ressource est un probl&egrave;me dit d'ordonnancement. Nous
pr&eacute;sentons ici&nbsp;: </FONT>
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>le cas g&eacute;n&eacute;ral
	</FONT>
	</P>
	<LI><P><FONT SIZE=5>les besoins et les probl&egrave;mes </FONT>
	</P>
</UL>
<P><FONT SIZE=5>et nous d&eacute;crirons des solutions que l'on
trouve sous UNIX pour diff&eacute;rents probl&egrave;mes
d'ordonnancement.<BR><BR>Les algorithmes d'ordonnancement r&eacute;alisent
la s&eacute;lection parmi les processus actifs de celui qui va
obtenir l'utilisation d'une ressource, que ce soit l'unit&eacute;
centrale, ou bien un p&eacute;riph&eacute;rique
d'entr&eacute;e-sortie.<BR><BR>Pour l'unit&eacute; centrale notre but
est de maximiser d&eacute;bit et taux utile de l'unit&eacute;
centrale&nbsp;: </FONT>
</P>
<DL>
	<DT><FONT SIZE=5>le d&eacute;bit</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>est le nombre moyen de processus ex&eacute;cut&eacute;s
	en un temps donn&eacute;.</FONT></DD><DT>
	<FONT SIZE=5>le taux utile</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>est la proportion de temps r&eacute;ellement utilis&eacute;e
	pour ex&eacute;cuter des processus utilisateurs. </FONT>
	</DD></DL>
<P>
<FONT SIZE=5>Un exemple&nbsp;:<BR>Soient 2 processus A et B de m&ecirc;me
comportement 30 p&eacute;riodes de deux seconde&nbsp;:<BR>1 seconde
d'activit&eacute;<BR>1 seconde d'inactivit&eacute;</FONT></P>
<PRE>
<FONT SIZE=5>AIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAIAI</FONT></PRE><P>
<FONT SIZE=5>Si l'on ex&eacute;cute les deux processus
cons&eacute;cutivement on obtient un d&eacute;bit de 1 processus par
minute, et un taux utile de 50%. Si l'on entrelace les p&eacute;riodes
actives et inactives des deux processus on obtient un d&eacute;bit de
2 processus par minute et un taux d'utilisation de 100%.<BR><BR>Pour
une autre ressource d'autres crit&egrave;res seront utilis&eacute;s.<!--TOC section <FONT SIZE=5>Le partage de l'unité centrale</FONT>--></FONT></P>
<H2><FONT SIZE=5>8.1&nbsp;&nbsp; Le partage de l'unit&eacute;
centrale</FONT></H2>
<P><!--SEC END --><FONT SIZE=5>Ce partage doit &ecirc;tre fait non
seulement entre les processus utilisateurs mais aussi entre les
diff&eacute;rentes t&acirc;ches du syst&egrave;me, scheduler,
entr&eacute;es-sorties, gestion des interruptions, etc.<BR><BR>Nous
demandons de plus &agrave; l'algorithme d'ordonnancement de nous
assurer <B>l'exclusion mutuelle</B> et <B>l'absence de famine</B>,
qui sont les points-clefs de la plupart des probl&egrave;mes
d'ordonnancement. exclusion mutuellefamine L'invention d'un
algorithme d'ordonnancement se base en g&eacute;n&eacute;rale sur des
remarques statistique sur le comportement des processus&nbsp;: </FONT>
</P>
<UL>
	<LI><P><FONT SIZE=5>Le couple UC/ES (cpu/io), les processus ont
	tendance &agrave; basculer constamment entre des phases
	d'entr&eacute;es-sorties et des phases de calcul sur l'unit&eacute;
	centrale. </FONT>
	</P>
	<LI><P><FONT SIZE=5>Les processus consommant de longues p&eacute;riodes
	d'U.C. sont proportionnellement rares. </FONT>
	</P>
</UL>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML039.gif" NAME="Image41" ALIGN=BOTTOM WIDTH=553 HEIGHT=272 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
8.1&nbsp;: Histogramme de r&eacute;partition de la dur&eacute;e de la
p&eacute;riode d'utilisation de l'unit&eacute; centrale</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="histogramme"></A><BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<H3><FONT SIZE=5><!--TOC subsection <FONT SIZE=5>Famine</FONT>-->8.1.1&nbsp;&nbsp;
Famine</FONT></H3>
<P><!--SEC END --><FONT SIZE=5>Notre premi&egrave;re t&acirc;che est
d'affecter une ressource (l'UC par exemple) &agrave; un unique
processus &agrave; la fois (exclusion mutuelle) et s'assurer de
l'absence de famine.<BR><BR><B>famine</B>&nbsp;: un processus peut se
voir refuser l'acc&egrave;s &agrave; une ressource pendant un temps
ind&eacute;termin&eacute;, il est dit alors que le processus est en
famine. <BR><BR>Un syst&egrave;me qui ne cr&eacute;e pas de cas de
famine&nbsp;: fournira toujours la ressource demand&eacute;e par un
processus, au bout d'un temps fini.<BR><BR>Si on prend le cas des
p&eacute;riph&eacute;riques (tels que les disques) l'ordonnancement
peut se faire de fa&ccedil;on simple avec par exemple une file
d'attente (FIFO).<BR><BR>Pour l'unit&eacute; centrale on va devoir
utiliser des structures de donn&eacute;es plus complexes car nous
allons avoir besoin de g&eacute;rer des priorit&eacute;s. C'est par
exemple, autoriser l'existence de processus qui &eacute;vitent la
file d'attente. La structure de donn&eacute;es utilis&eacute;e peut
parfaitement &ecirc;tre une file, une liste, un arbre ou un tas, ceci
en fonction de l'&eacute;l&eacute;ment-clef de notre algorithme de
s&eacute;lection (&acirc;ge, priorit&eacute; simple, priorit&eacute;
&agrave; plusieurs niveaux, etc).<BR><BR>Cette structure de donn&eacute;es
doit nous permettre d'acc&eacute;der &agrave; tous les processus
pr&ecirc;ts (&eacute;ligibles).<!--TOC subsection <FONT SIZE=5>Stratégie globale</FONT>--></FONT></P>
<H3><FONT SIZE=5>8.1.2&nbsp;&nbsp; Strat&eacute;gie globale</FONT></H3>
<P><!--SEC END --><FONT SIZE=5>On peut repr&eacute;senter
l'ordonnancement global avec le sch&eacute;ma </FONT><A HREF="#courlong"><FONT SIZE=5>8.2</FONT></A><FONT SIZE=5>
</FONT>
</P>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML040.gif" NAME="Image42" ALIGN=BOTTOM WIDTH=319 HEIGHT=158 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
8.2&nbsp;: Strat&eacute;gie globale d'ordonnancement.</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="courlong"></A><BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<P><FONT SIZE=5>Les ordonnancements &agrave; court terme doivent &ecirc;tre
tr&egrave;s rapides, en effet le processus &eacute;lu ne va utiliser
l'unit&eacute; centrale que pendant un tr&egrave;s court laps de
temps ( 10 milli-secondes par exemple). Si on utilise trop de temps
(1 milli-seconde) pour s&eacute;lectionner cet &eacute;lu, le taux
utile d&eacute;cro&icirc;t tr&egrave;s rapidement (ici on perd 9% du
temps d'unit&eacute; centrale).<BR><BR>Par contre l'ordonnancement &agrave;
long terme peut &ecirc;tre plus long car il a lieu moins souvent
(toutes les secondes par exemple). La conception de l'ordonnanceur &agrave;
long terme est faite dans l'optique d'obtenir un ordonnanceur &agrave;
court terme rapide.<!--TOC subsection <FONT SIZE=5>Critères de performance </FONT>--></FONT></P>
<H3><FONT SIZE=5>8.1.3&nbsp;&nbsp; Crit&egrave;res de performance </FONT>
</H3>
<P><!--SEC END --><FONT SIZE=5><B>Les crit&egrave;res de performance
des algorithmes d'ordonnancement</B> </FONT>
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Taux d'utilisation de
	l'unit&eacute; centrale </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>D&eacute;bit </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Temps r&eacute;el
	d'ex&eacute;cution </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Temps d'attente </FONT>
	</P>
	<LI><P><FONT SIZE=5>Temps de r&eacute;ponse </FONT>
	</P>
</UL>
<P><B><FONT SIZE=5>Ces cinq crit&egrave;res sont plus ou moins
mutuellement exclusifs.</FONT></B><BR><BR><FONT SIZE=5>Les
comparaisons des diff&eacute;rents algorithmes se fait donc sur une
s&eacute;lection de ces crit&egrave;res.<!--TOC section <FONT SIZE=5>Ordonnancement sans préemption.</FONT>--></FONT></P>
<H2><FONT SIZE=5>8.2&nbsp;&nbsp; Ordonnancement sans pr&eacute;emption.</FONT></H2>
<UL>
	<LI><P><!--SEC END --><FONT SIZE=5>FCFS&nbsp;: First Come First
	served<BR>Facile &agrave; &eacute;crire et &agrave; comprendre, peu
	efficace ...FCFS</FONT></P>
	<LI><P><FONT SIZE=5>SJF&nbsp;: Shortest Job First<BR>le plus petit
	en premier.<BR>Optimal pour le temps d'attente moyen ...SJF</FONT></P>
	<LI><P><FONT SIZE=5>A priorit&eacute;&nbsp;:<BR>L'utilisateur donne
	des priorit&eacute;s aux diff&eacute;rents processus et ils sont
	activ&eacute;s en fonction de cette priorit&eacute;.<BR>probl&egrave;me
	<FONT FACE="symbol">&frac34;&reg;</FONT> famine possible des
	processus peu prioritaires<BR>Solution <FONT FACE="symbol">&frac34;&reg;</FONT>
	faire augmenter la priorit&eacute; avec le temps d'attente&nbsp;:<BR>plus
	un processus attend, plus sa priorit&eacute; augmente ainsi au bout
	d'un certain temps le processus devient n&eacute;cessairement le
	plus prioritaire.<BR><BR>re-probl&egrave;me <FONT FACE="symbol">&frac34;&reg;</FONT>
	si le processus en question (le tr&egrave;s vieux tr&egrave;s gros)
	est ex&eacute;cut&eacute; alors que de nombreux utilisateurs sont en
	mode interactif chute catastrophique du temps de r&eacute;ponse et
	du d&eacute;bit<BR>solution <FONT FACE="symbol">&frac34;&reg;</FONT>
	pr&eacute;emption.</FONT></P>
</UL>
<P><FONT SIZE=5>pr&eacute;emption La <B>pr&eacute;emption</B> est la
possibilit&eacute; qu'a le syst&egrave;me de reprendre une ressource
&agrave; un processus sans que celui-ci ait lib&eacute;r&eacute;
cette ressource.<BR>Ceci est impossible sur bon nombre de ressources.
Lesquelles ? <!--TOC section <FONT SIZE=5>Les algorithmes préemptifs</FONT>--></FONT></P>
<H2><FONT SIZE=5>8.3&nbsp;&nbsp; Les algorithmes pr&eacute;emptifs</FONT></H2>
<P><FONT SIZE=5><!--SEC END -->FCFS ne peut &ecirc;tre pr&eacute;emptif
...<BR>SJF peut &ecirc;tre pr&eacute;emptif&nbsp;: si un processus
plus court que le processus actif arrive dans la queue, le processus
actif est pr&eacute;empt&eacute;.<BR><BR>Dans des syst&egrave;mes
interactifs en temps partag&eacute; un des crit&egrave;res est le
temps de r&eacute;ponse, c'est &agrave; dire que chaque utilisateur
dispose de l'unit&eacute; centrale r&eacute;guli&egrave;rement.
Heureusement, les processus interactifs utilisent l'UC pendant de
tr&egrave;s courts intervalles &agrave; chaque fois.<!--TOC subsection <FONT SIZE=5>Round Robin (tourniquet)</FONT>--></FONT></P>
<H3><FONT SIZE=5>8.3.1&nbsp;&nbsp; Round Robin (tourniquet)</FONT></H3>
<P><!--SEC END --><FONT SIZE=5>Round Robin Cet algorithme est
sp&eacute;cialement adapt&eacute; aux syst&egrave;mes en temps
partag&eacute;. <BR>On d&eacute;finit un <B>quantum de temps</B>
(time quantum) d'utilisation de l'unit&eacute; centrale.<BR>La file
d'attente des processus &eacute;ligibles est vue comme une queue
circulaire (fifo circulaire).<BR>Tout nouveau processus est plac&eacute;
&agrave; la fin de la liste.<BR><BR>De deux choses l'une, soit le
processus actif rend l'Unit&eacute; Centrale avant la fin de sa
tranche de temps (pour cause d'entr&eacute;e/sortie) soit il est
pr&eacute;empt&eacute;, et dans les deux cas plac&eacute; en fin de
liste.<BR><BR>Un processus obtiendra le processeur au bout de (n
-1)*q secondes au plus (n nombre de processus et q longueur du
quantum de temps), la famine est donc assur&eacute;ment
&eacute;vit&eacute;e.<BR><BR>Remarquons que si le quantum de temps
est trop grand, round-robin devient &eacute;quivalent &agrave; FCFS.
De l'autre cot&eacute; si le quantum de temps est tr&egrave;s court,
nous avons th&eacute;oriquement un processeur n fois moins rapide
pour chaque processus (n nombre de processus).<BR><BR>Malheureusement
si le quantum de temps est court, le nombre de changements de
contexte d&ucirc;s &agrave; la pr&eacute;emption grandit, d'o&ugrave;
une diminution du taux utile, d'o&ugrave; un processeur virtuel tr&egrave;s
lent.<BR><BR>Une r&egrave;gle empirique est d'utiliser un quantum de
temps tel que 80% des processus interrompent naturellement leur
utilisation de l'unit&eacute; centrale avant l'expiration du quantum
de temps.<!--TOC subsection <FONT SIZE=5>Les algorithmes à queues multiples</FONT>--></FONT></P>
<H3><FONT SIZE=5>8.3.2&nbsp;&nbsp; Les algorithmes &agrave; queues
multiples</FONT></H3>
<P><FONT SIZE=5><!--SEC END -->Nous supposons que nous avons un moyen
de diff&eacute;rencier facilement les processus en plusieurs classes
de priorit&eacute; diff&eacute;rentes (c'est le cas sous UNIX o&ugrave;
nous allons diff&eacute;rencier les t&acirc;ches syst&egrave;me,
comme le swappeur, des autres t&acirc;ches).<BR><BR>Pour s&eacute;lectionner
un processus, le scheduler parcourt successivement les queues dans
l'ordre d&eacute;croissant des priorit&eacute;s.<BR>Un exemple de
queues organis&eacute;es en fonction du contenu des processus&nbsp;: </FONT>
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>les processus
	syst&egrave;mes </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>les processus
	interactifs </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>les processus &eacute;dition
	</FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>les processus gros
	calcul </FONT>
	</P>
	<LI><P><FONT SIZE=5>les processus des &eacute;tudiants </FONT>
	</P>
</UL>
<P><FONT SIZE=5>pour qu'un processus &eacute;tudiant soit ex&eacute;cut&eacute;
il faut que toutes les autres files d'attente soient vides ...<BR>Une
autre possibilit&eacute; est de partager les quantums de temps sur
les diff&eacute;rentes queues.<BR>Il est aussi possible de r&eacute;aliser
diff&eacute;rents algorithmes de scheduling sur les diff&eacute;rentes
queues&nbsp;: </FONT>
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Round Robin sur les
	processus interactifs </FONT>
	</P>
	<LI><P><FONT SIZE=5>FCFS sur les gros calculs en t&acirc;che de
	fond. </FONT>
	</P>
</UL>
<H2><FONT SIZE=5><!--TOC section <FONT SIZE=5>Multi-level-feedback round robin Queues</FONT>-->8.4&nbsp;&nbsp;
Multi-level-feedback round robin Queues</FONT></H2>
<P><FONT SIZE=5><!--SEC END -->Le syst&egrave;me d'ordonnancement des
processus sous UNIX (BSD 4.3 et system V4) utilise plusieurs files
d'attente qui vont mat&eacute;rialiser des niveaux de priorit&eacute;
diff&eacute;rents et &agrave; l'int&eacute;rieur de ces diff&eacute;rents
niveaux de priorit&eacute;, un syst&egrave;me de tourniquet.</FONT></P>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML041.gif" NAME="Image43" ALIGN=BOTTOM WIDTH=311 HEIGHT=273 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
8.3&nbsp;: Les queues multiples en tourniquet </FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="multilevel"></A><BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<H3><FONT SIZE=5><!--TOC subsection <FONT SIZE=5>Les niveaux de priorité</FONT>-->8.4.1&nbsp;&nbsp;
Les niveaux de priorit&eacute;</FONT></H3>
<P><!--SEC END --><FONT SIZE=5>Le scheduler parcourt les listes une
par une de haut en bas jusqu'&agrave; trouver une liste contenant un
processus &eacute;ligible. Ainsi tant qu'il y a des processus de
cat&eacute;gorie sup&eacute;rieure &agrave; ex&eacute;cuter les
autres processus sont en attente de l'unit&eacute; centrale.<BR><BR>Dans
les listes internes au noyau, de simples files d'attente sont
utilis&eacute;es avec la possibilit&eacute; de doubler les processus
endormis de la m&ecirc;me liste (en effet seul le processus r&eacute;veill&eacute;
par la fin de son entr&eacute;e/sortie est &eacute;ligible).<BR><BR>Pour
les processus utilisateurs, la m&ecirc;me r&egrave;gle est utilis&eacute;e
mais avec pr&eacute;emption et la r&egrave;gle du tourniquet.<BR><BR>C'est
&agrave; dire, on calcul une priorit&eacute; de base qui est utilis&eacute;e
pour placer le processus dans la bonne file d'attente.<BR><BR>Un
processus qui utilise l'unit&eacute; centrale voit augmenter sa
priorit&eacute;.<BR>Un processus qui lib&egrave;re l'unit&eacute;
centrale pour demander une entr&eacute;e/sortie ne voit pas sa
priorit&eacute; changer.<BR>Un processus qui utilise tout sont
quantum de temps est pr&eacute;empt&eacute; et plac&eacute; dans une
nouvelle file d'attente.<BR><B>Attention&nbsp;: plus la priorit&eacute;
est grande moins le processus est prioritaire.</B> priorit&eacute;<!--TOC subsection <FONT SIZE=5>Evolution de la priorité</FONT>-->
</FONT>
</P>
<H3><FONT SIZE=5>8.4.2&nbsp;&nbsp; Evolution de la priorit&eacute;</FONT></H3>
<P><FONT SIZE=5><!--SEC END -->Regardons la priorit&eacute; et
l'&eacute;volution de la priorit&eacute; d'un processus utilisateur
au cours du temps. Les fonctions suivantes sont utilis&eacute;es dans
une impl&eacute;mentation BSD.<BR><BR>Pour calculer la priorit&eacute;
d'un processus utilisateur, le scheduler utilise l'&eacute;quation
suivante qui est calcul&eacute;e tous les 4 clicks horloge (valeur
pratique empirique)&nbsp;:</FONT></P>
<CENTER>
	<TABLE WIDTH=396 BORDER=0 CELLPADDING=2 CELLSPACING=0>
		<COLGROUP>
			<COL WIDTH=15>
			<COL WIDTH=51>
			<COL WIDTH=129>
			<COL WIDTH=16>
			<COL WIDTH=38>
		</COLGROUP>
		<COLGROUP>
			<COL WIDTH=0>
			<COL WIDTH=78>
			<COL WIDTH=42>
		</COLGROUP>
		<TR>
			<TD ROWSPAN=8 WIDTH=15>
				<P><FONT SIZE=5><I>P</I></FONT></P>
			</TD>
			<TD WIDTH=51>
				<P><FONT SIZE=5>&nbsp;</FONT></P>
			</TD>
			<TD ROWSPAN=8 WIDTH=129>
				<P><FONT SIZE=5>= PUSER + </FONT>
				</P>
			</TD>
			<TD ROWSPAN=3 WIDTH=16>
				<P><FONT SIZE=5><I>P</I></FONT></P>
			</TD>
			<TD ROWSPAN=2 WIDTH=38 VALIGN=TOP>
				<TABLE WIDTH=38 BORDER=0 CELLPADDING=0 CELLSPACING=0>
					<COL WIDTH=38>
					<TR>
						<TD WIDTH=38>
							<P><FONT SIZE=5>&nbsp;</FONT></P>
						</TD>
					</TR>
					<TR>
						<TD WIDTH=38>
							<P><FONT SIZE=2>&nbsp;cpu</FONT></P>
						</TD>
					</TR>
				</TABLE>
			</TD>
			<TD ROWSPAN=2 WIDTH=0 VALIGN=TOP></TD>
			<TD ROWSPAN=8 WIDTH=78>
				<P><FONT SIZE=5>+ 2 &times; <I>P</I></FONT></P>
			</TD>
			<TD WIDTH=42>
				<P><FONT SIZE=5>&nbsp;</FONT></P>
			</TD>
		</TR>
		<TR>
			<TD WIDTH=51>
				<P><FONT SIZE=2>&nbsp;usrpri</FONT></P>
			</TD>
			<TD WIDTH=42>
				<P><FONT SIZE=2>&nbsp;nice</FONT></P>
			</TD>
		</TR>
		<TR>
			<TD ROWSPAN=6 WIDTH=51></TD>
			<TD COLSPAN=2 WIDTH=40></TD>
			<TD ROWSPAN=6 WIDTH=42></TD>
		</TR>
		<TR>
			<TD COLSPAN=3 WIDTH=59></TD>
		</TR>
		<TR>
			<TD COLSPAN=3 WIDTH=59 BGCOLOR="#000000"></TD>
		</TR>
		<TR>
			<TD COLSPAN=3 WIDTH=59 BGCOLOR="#000000"></TD>
		</TR>
		<TR>
			<TD COLSPAN=3 WIDTH=59>
				<P ALIGN=CENTER><FONT SIZE=5>4</FONT></P>
			</TD>
		</TR>
		<TR>
			<TD COLSPAN=3 WIDTH=59></TD>
		</TR>
	</TABLE>
</CENTER>
<P><BR><FONT SIZE=5>cette valeur est tronqu&eacute;e &agrave;
l'intervalle PUSER..127. En fonction de cette valeur le processus est
plac&eacute; dans une des listes correspondant &agrave; son niveau
courant de priorit&eacute;.<BR><BR>Ceci nous donne une priorit&eacute;
qui diminue lin&eacute;airement en fonction de l'utilisation de
l'unit&eacute; centrale (il advient donc un moment o&ugrave; le
processus devient le processus le plus prioritaire!).<BR><BR><I>P</I></FONT><FONT SIZE=2><SUB>&nbsp;nice</SUB></FONT><FONT SIZE=5>
est une valeur sp&eacute;cifi&eacute;e par le programmeur gr&acirc;ce
&agrave; l'appel syst&egrave;me </FONT><TT><FONT SIZE=5>nice</FONT></TT><FONT SIZE=5>.
Elle varie entre -20 et +20 et seul le super utilisateur peut
sp&eacute;cifier une valeur n&eacute;gative.<BR><BR><I>P</I></FONT><FONT SIZE=2><SUB>&nbsp;cpu</SUB></FONT><FONT SIZE=5>
donne une estimation du temps pass&eacute; par un processus sur
l'unit&eacute; centrale. A chaque click d'horloge, la variable </FONT><TT><FONT SIZE=5>p_cpu</FONT></TT><FONT SIZE=5>
du processus actif est incr&eacute;ment&eacute;e. Ce qui permet de
mat&eacute;rialiser la consommation d'unit&eacute; central du
processus. Pour que cette valeur ne devienne pas trop p&eacute;nalisante
sur le long terme (comme pour un shell) elle est att&eacute;nu&eacute;e
toute les secondes gr&acirc;ce &agrave; la formule suivante&nbsp;:</FONT></P>
<CENTER>
	<TABLE WIDTH=382 BORDER=0 CELLPADDING=2 CELLSPACING=0>
		<COL WIDTH=15>
		<COL WIDTH=38>
		<COL WIDTH=20>
		<COL WIDTH=129>
		<COL WIDTH=36>
		<COL WIDTH=38>
		<COL WIDTH=36>
		<COL WIDTH=42>
		<TR>
			<TD ROWSPAN=6 WIDTH=15>
				<P><FONT SIZE=5><I>P</I></FONT></P>
			</TD>
			<TD WIDTH=38>
				<P><FONT SIZE=5>&nbsp;</FONT></P>
			</TD>
			<TD ROWSPAN=6 WIDTH=20>
				<P><FONT SIZE=5>= </FONT>
				</P>
			</TD>
			<TD WIDTH=129>
				<P ALIGN=CENTER><FONT SIZE=5>2 &times; load</FONT></P>
			</TD>
			<TD ROWSPAN=6 WIDTH=36>
				<P><FONT SIZE=5>&times; <I>P</I></FONT></P>
			</TD>
			<TD WIDTH=38>
				<P><FONT SIZE=5>&nbsp;</FONT></P>
			</TD>
			<TD ROWSPAN=6 WIDTH=36>
				<P><FONT SIZE=5>+ <I>P</I></FONT></P>
			</TD>
			<TD WIDTH=42>
				<P><FONT SIZE=5>&nbsp;</FONT></P>
			</TD>
		</TR>
		<TR>
			<TD ROWSPAN=3 WIDTH=38>
				<P><FONT SIZE=2>&nbsp;cpu</FONT></P>
			</TD>
			<TD WIDTH=129 BGCOLOR="#000000"></TD>
			<TD ROWSPAN=3 WIDTH=38>
				<P><FONT SIZE=2>&nbsp;cpu</FONT></P>
			</TD>
			<TD ROWSPAN=3 WIDTH=42>
				<P><FONT SIZE=2>&nbsp;nice</FONT></P>
			</TD>
		</TR>
		<TR>
			<TD WIDTH=129 BGCOLOR="#000000"></TD>
		</TR>
		<TR>
			<TD ROWSPAN=2 WIDTH=129>
				<P ALIGN=CENTER><FONT SIZE=5>2 &times; load + 1</FONT></P>
			</TD>
		</TR>
		<TR>
			<TD ROWSPAN=2 WIDTH=38></TD>
			<TD ROWSPAN=2 WIDTH=38></TD>
			<TD ROWSPAN=2 WIDTH=42></TD>
		</TR>
		<TR>
			<TD WIDTH=129></TD>
		</TR>
	</TABLE>
</CENTER>
<P><BR><FONT SIZE=5>la valeur de </FONT><TT><FONT SIZE=5>load</FONT></TT><FONT SIZE=5>
(la charge) est calcul&eacute;e sur une moyenne du nombre de
processus actifs pendant une minute.<BR><BR>Pour ne pas utiliser trop
de ressources, les processus qui sont en sommeil (sleep) voient leur
<I>P</I></FONT><FONT SIZE=2><SUB>&nbsp;cpu</SUB></FONT><FONT SIZE=5>
recalcul&eacute; uniquement &agrave; la fin de leur p&eacute;riode de
sommeil gr&acirc;ce &agrave; la formule&nbsp;:</FONT></P>
<CENTER>
	<TABLE WIDTH=412 BORDER=0 CELLPADDING=2 CELLSPACING=0>
		<COL WIDTH=15>
		<COL WIDTH=38>
		<COL WIDTH=20>
		<COL WIDTH=11>
		<COL WIDTH=129>
		<COL WIDTH=11>
		<COL WIDTH=82>
		<COL WIDTH=36>
		<COL WIDTH=39>
		<TR>
			<TD ROWSPAN=9 WIDTH=15>
				<P><FONT SIZE=5><I>P</I></FONT></P>
			</TD>
			<TD ROWSPAN=2 WIDTH=38>
				<P><FONT SIZE=5>&nbsp;</FONT></P>
			</TD>
			<TD ROWSPAN=9 WIDTH=20>
				<P><FONT SIZE=5>= </FONT>
				</P>
			</TD>
			<TD ROWSPAN=9 WIDTH=11>
				<P><FONT FACE="symbol"><FONT SIZE=5>&aelig;<BR>&ccedil;<BR>&ccedil;<BR>&egrave;</FONT></FONT></P>
			</TD>
			<TD ROWSPAN=2 WIDTH=129>
				<P ALIGN=CENTER><FONT SIZE=5>2 &times; load</FONT></P>
			</TD>
			<TD ROWSPAN=9 WIDTH=11>
				<P><FONT FACE="symbol"><FONT SIZE=5>&ouml;<BR>&divide;<BR>&divide;<BR>&oslash;</FONT></FONT></P>
			</TD>
			<TD WIDTH=82>
				<P ALIGN=LEFT><FONT SIZE=2>&nbsp;sleep_time</FONT></P>
			</TD>
			<TD ROWSPAN=9 WIDTH=36>
				<P><FONT SIZE=5>&times; <I>P</I></FONT></P>
			</TD>
			<TD ROWSPAN=2 WIDTH=39>
				<P><FONT SIZE=5>&nbsp;</FONT></P>
			</TD>
		</TR>
		<TR>
			<TD ROWSPAN=6 WIDTH=82>
				<P ALIGN=LEFT><FONT SIZE=5><BR></FONT><BR>
				</P>
			</TD>
		</TR>
		<TR>
			<TD ROWSPAN=3 WIDTH=38>
				<P><FONT SIZE=2>&nbsp;cpu</FONT></P>
			</TD>
			<TD WIDTH=129 BGCOLOR="#000000"></TD>
			<TD ROWSPAN=3 WIDTH=39>
				<P><FONT SIZE=2>&nbsp;cpu</FONT></P>
			</TD>
		</TR>
		<TR>
			<TD WIDTH=129 BGCOLOR="#000000"></TD>
		</TR>
		<TR>
			<TD ROWSPAN=2 WIDTH=129>
				<P ALIGN=CENTER><FONT SIZE=5>2 &times; load + 1</FONT></P>
			</TD>
		</TR>
		<TR>
			<TD ROWSPAN=4 WIDTH=38></TD>
			<TD ROWSPAN=4 WIDTH=39></TD>
		</TR>
		<TR>
			<TD ROWSPAN=3 WIDTH=129></TD>
		</TR>
		<TR>
			<TD WIDTH=82>
				<P ALIGN=LEFT><FONT SIZE=4>&nbsp;</FONT></P>
			</TD>
		</TR>
		<TR>
			<TD WIDTH=82></TD>
		</TR>
	</TABLE>
</CENTER>
<P><BR><FONT SIZE=5>la variable </FONT><TT><FONT SIZE=5>sleep_time</FONT></TT><FONT SIZE=5>
&eacute;tant initialis&eacute;e &agrave; z&eacute;ro puis incr&eacute;ment&eacute;e
une fois par seconde. load<!--TOC subsection <FONT SIZE=5>Les classes de priorité</FONT>-->
</FONT>
</P>
<H3><FONT SIZE=5>8.4.3&nbsp;&nbsp; Les classes de priorit&eacute;</FONT></H3>
<P><!--SEC END --><FONT SIZE=5><B>La priorit&eacute; des processus en
mode syst&egrave;me d&eacute;pend de l'action &agrave;
r&eacute;aliser.</B><BR>PSWAP 0 priorit&eacute; en cours de
swap<BR>PINOD 10 priorit&eacute; en attendant une lecture
d'information sur le syst&egrave;me de fichiers<BR>PRIBIO 20 priorit&eacute;
en attente d'une lecture/&eacute;criture sur disque<BR>PZERO 25
priorit&eacute; limite<BR>PWAIT 30 priorit&eacute; d'attente de
base<BR>PLOCK 35 priorit&eacute; d'attente sur un verrou<BR>PSLEP 40
priorit&eacute; d'attente d'un &eacute;v&egrave;nement <BR>PUSER 50
priorit&eacute; de base pour les processus en mode utilisateur<BR>Le
choix de l'ordre de ces priorit&eacute;s est tr&egrave;s important,
en effet un mauvais choix peut entra&icirc;ner une diminution
importante des performances du syst&egrave;me.<BR><BR>Il vaut mieux
que les processus en attente d'un disque soient plus prioritaires que
les processus en attente d'un buffer, car les premiers risquent fort
de lib&eacute;rer un buffer apr&egrave;s leur acc&egrave;s disque (de
plus il est possible que ce soit exactement le buffer attendu par le
deuxi&egrave;me processus). Si la priorit&eacute; &eacute;tait
inverse, il deviendrait possible d'avoir un interblocage ou une
attente tr&egrave;s longue si le syst&egrave;me est bloqu&eacute; par
ailleurs.<BR><BR>De la m&ecirc;me fa&ccedil;ons, le swappeur doit
&ecirc;tre le plus prioritaire et non interruptible <FONT FACE="symbol">&frac34;&reg;</FONT>
Si un processus est plus prioritaire que le swappeur et qu'il doit
&ecirc;tre swapp&eacute; en m&eacute;moire ...<BR>En Demand-Paging le
swappeur est aussi le processus qui r&eacute;alise les chargements de
page, ce processus doit &ecirc;tre le plus prioritaire.
Demand-Paging<!--TOC chapter <FONT SIZE=5>La mémoire</FONT>--></FONT></P>
<H1><FONT SIZE=5>Chapitre&nbsp;9&nbsp;&nbsp; La m&eacute;moire</FONT></H1>
<H3><FONT SIZE=5><!--SEC END --><!--TOC subsection <FONT SIZE=5>les mémoires</FONT>-->9.0.4&nbsp;&nbsp;
les m&eacute;moires</FONT></H3>
<P><!--SEC END --><FONT SIZE=5>La m&eacute;moire d'un ordinateur se
d&eacute;compose en plusieurs &eacute;l&eacute;ments, dont le prix et
le temps d'acc&egrave;s sont tr&egrave;s variables, cf figure </FONT><A HREF="#hierarchie"><FONT SIZE=5>9.1</FONT></A><FONT SIZE=5>.
Nous d&eacute;velopperons dans ce chapitre et le suivant les
questions et solutions relatives &agrave; la m&eacute;moire centrale.</FONT></P>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML042.gif" NAME="Image44" ALIGN=BOTTOM WIDTH=318 HEIGHT=131 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
9.1&nbsp;: Hi&eacute;rarchie de m&eacute;moires</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="hierarchie"></A><BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<P><FONT SIZE=5>L'importance de la gestion de la m&eacute;moire
centrale vient de son co&ucirc;t et du co&ucirc;t relatif des autres
formes de stockage, la figure </FONT><A HREF="#caracteristiques"><FONT SIZE=5>9.2</FONT></A><FONT SIZE=5>
donne une id&eacute;e des caract&eacute;ristiques relatives des
diff&eacute;rents types de stockage.</FONT></P>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML043.gif" NAME="Image45" ALIGN=BOTTOM WIDTH=321 HEIGHT=198 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
9.2&nbsp;: Caract&eacute;ristiques relatives des m&eacute;moires.</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="caracteristiques"></A>
<BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<H3><FONT SIZE=5><!--TOC subsection <FONT SIZE=5>La mémoire centrale</FONT>-->9.0.5&nbsp;&nbsp;
La m&eacute;moire centrale</FONT></H3>
<P><FONT SIZE=5><!--SEC END -->La m&eacute;moire est un tableau &agrave;
une dimension de mots machines (ou d'octets), chacun ayant une
adresse propre. Les &eacute;changes avec l'ext&eacute;rieur se font
en g&eacute;n&eacute;ral par des lectures ou des &eacute;critures &agrave;
des adresses sp&eacute;cifiques.<BR><BR>Le syst&egrave;me Unix est
multi-t&acirc;che,ceci pour maximiser l'utilisation du cpu. Cette
technique pose comme condition obligatoire que la m&eacute;moire
centrale soit utilis&eacute;e et/ou partag&eacute;e entre les
diff&eacute;rentes t&acirc;ches.<BR><BR>Les solutions de gestion de
la m&eacute;moire sont tr&egrave;s d&eacute;pendantes du mat&eacute;riel
et ont mis longtemps &agrave; &eacute;voluer vers les solutions
actuelles. Nous allons voir plusieurs approches qui peuvent servir
dans des situations particuli&egrave;res .<BR><BR>La m&eacute;moire
est le point central dans un syst&egrave;me d'exploitation, c'est &agrave;
travers elle que l'unit&eacute; centrale communique avec
l'ext&eacute;rieur.<!--TOC section <FONT SIZE=5>Allocation contiguë</FONT>--></FONT></P>
<H2><FONT SIZE=5>9.1&nbsp;&nbsp; Allocation contigu&euml;</FONT></H2>
<P><!--SEC END --><FONT SIZE=5>Allocation contigu&euml;<!--TOC subsection <FONT SIZE=5>Pas de gestion de la mémoire</FONT>-->
</FONT>
</P>
<H3><FONT SIZE=5>9.1.1&nbsp;&nbsp; Pas de gestion de la m&eacute;moire</FONT></H3>
<P ALIGN=CENTER STYLE="margin-left: 1cm; margin-right: 1cm; border-top: none; border-bottom: 1.10pt double #808080; border-left: none; border-right: none; padding: 0cm">
<FONT SIZE=1 STYLE="font-size: 6pt"><!--SEC END --></FONT><BR><BR>
</P>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML044.gif" NAME="Image46" ALIGN=BOTTOM WIDTH=157 HEIGHT=272 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
9.3&nbsp;: Une m&eacute;moire de 64 Kilo Octets.</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="mem1"></A><BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<P><FONT SIZE=5>Pas de gestion de la m&eacute;moire ! Cette m&eacute;thode,
qui a l'avantage de la simplicit&eacute; et de la rapidit&eacute;,
permet toute libert&eacute; quand &agrave; l'utilisation de la
m&eacute;moire. En effet, toute adresse est accessible, et peut &ecirc;tre
utilis&eacute;e pour n'importe quelle t&acirc;che. Le d&eacute;savantage
&nbsp;: aucune fonctionnalit&eacute;, tout doit &ecirc;tre
reprogramm&eacute;, typiquement il n'y pas de syst&egrave;me
d'exploitation !<!--TOC subsection <FONT SIZE=5>Le moniteur résidant</FONT>--></FONT></P>
<H3><FONT SIZE=5>9.1.2&nbsp;&nbsp; Le moniteur r&eacute;sidant</FONT></H3>
<P><FONT SIZE=5><!--SEC END -->On cherche &agrave; prot&eacute;ger le
noyau des interf&eacute;rences possibles de la part des utilisateurs.
Pour cela, toute adresse d'instruction ou de donn&eacute;e manipul&eacute;e
par un programme utilisateur est compar&eacute;e &agrave; un registre
barri&egrave;re (fence register).<BR><BR>Tant que l'adresse est
sup&eacute;rieure &agrave; la barri&egrave;re, l'adresse est l&eacute;gale,
sinon l'adresse est une r&eacute;f&eacute;rence ill&eacute;gale au
moniteur et une interruption est &eacute;mise (invalid adress). </FONT>
</P>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML045.gif" NAME="Image47" ALIGN=BOTTOM WIDTH=239 HEIGHT=247 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
9.4&nbsp;: Protection du moniteur par un registre barri&egrave;re.</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="mem2"></A><BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<P><FONT SIZE=5>Cette m&eacute;thode demande que pour tout acc&egrave;s
&agrave; la m&eacute;moire une v&eacute;rification de la validit&eacute;
de l'adresse soit r&eacute;alis&eacute;e. Ceci ralentit toute
ex&eacute;cution d'un acc&egrave;s m&eacute;moire. (Paterson donne
comme exemple de ralentissement des temps de 980 nanosecondes sans
v&eacute;rification et 995 nanosecondes avec v&eacute;rification).
Globalement ce temps suppl&eacute;mentaire peut &ecirc;tre oubli&eacute;.<!--TOC subsection <FONT SIZE=5>Le registre barrière</FONT>--></FONT></P>
<H3><FONT SIZE=5>9.1.3&nbsp;&nbsp; Le registre barri&egrave;re</FONT></H3>
<P><!--SEC END --><FONT SIZE=5>registre barri&egrave;re
L'impl&eacute;mentation d'un tel m&eacute;canisme doit &ecirc;tre
r&eacute;alis&eacute;e de fa&ccedil;on mat&eacute;rielle.<BR><BR>La
valeur du registre barri&egrave;re est parfois r&eacute;alis&eacute;e
de fa&ccedil;on fixe sur une machine, ce qui pose des probl&egrave;mes
d&egrave;s que l'on veut changer le noyau et/ou prot&eacute;ger plus
de m&eacute;moire (voir DOS). </FONT>
</P>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML046.gif" NAME="Image48" ALIGN=BOTTOM WIDTH=321 HEIGHT=165 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
9.5&nbsp;: Impl&eacute;mentation du registre Barri&egrave;re.</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="mem3"></A><BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<H3><FONT SIZE=5><!--TOC subsection <FONT SIZE=5>Le registre base</FONT>-->9.1.4&nbsp;&nbsp;
Le registre base</FONT></H3>
<P><!--SEC END --><FONT SIZE=5>registre base Le m&eacute;canisme
suivant est une notion plus utile et plus ergonomique pour d&eacute;crire
la zone d'adressage d'un programme, et utile pour r&eacute;soudre le
probl&egrave;me de d&eacute;placement des programmes en m&eacute;moire
(relocation). </FONT>
</P>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML047.gif" NAME="Image49" ALIGN=BOTTOM WIDTH=321 HEIGHT=133 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
9.6&nbsp;: Impl&eacute;mentation du registre de Base.</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="mem5"></A><BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<P><FONT SIZE=5>En effet, du fait que l'on utilise un registre
barri&egrave;re, les adresses utilisables de la m&eacute;moire ne
commencent plus &agrave; 0000, alors que l'utilisateur veut continuer
&agrave; utiliser des adresses logiques qui commencent &agrave; 0000.
</FONT>
</P>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML048.gif" NAME="Image50" ALIGN=BOTTOM WIDTH=238 HEIGHT=246 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
9.7&nbsp;: Positionnement d'un processus par un registre de Base.</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="mem4"></A><BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<P><FONT SIZE=5>Pour continuer &agrave; fournir cette possibilit&eacute;
le registre barri&egrave;re est transform&eacute; en registre de base
(relocation) . A chaque utilisation d'une adresse logique du
programme, on ajoute &agrave; cette adresse la valeur du registre de
base pour trouver l'adresse physique. L'utilisateur ne conna&icirc;t
plus les adresses physiques. Il travaille uniquement avec des
adresses logiques (xdb).<BR><BR>Le moniteur a &eacute;videmment une
valeur nulle pour son registre de base et donc peut adresser toute la
m&eacute;moire. Le changement de la valeur du registre de base se
fait de fa&ccedil;on prot&eacute;g&eacute;e en mode moniteur.<BR><BR>Ces
deux syst&egrave;mes de protection de la m&eacute;moire sont
clairement mono-processus. Seul le moniteur peut &ecirc;tre prot&eacute;g&eacute;
par ces m&eacute;canismes, il n'est pas possible de prot&eacute;ger
les processus entre eux.<!--TOC subsection <FONT SIZE=5>Le swap</FONT>--></FONT></P>
<H3><FONT SIZE=5>9.1.5&nbsp;&nbsp; Le swap</FONT></H3>
<P><!--SEC END --><FONT SIZE=5>swap </FONT>
</P>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML049.gif" NAME="Image51" ALIGN=BOTTOM WIDTH=319 HEIGHT=227 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
9.8&nbsp;: Un syst&egrave;me de swap utilisant uniquement un registre
barri&egrave;re.</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="mem.swap"></A><BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<P><FONT SIZE=5>Il est possible avec les registres barri&egrave;re ou
les registres de base d'&eacute;crire des syst&egrave;mes temps
partag&eacute;, en utilisant le m&eacute;canisme de swap
(&eacute;change).<BR><B>Swapper</B>, c'est &eacute;changer le contenu
de la m&eacute;moire centrale avec le contenu d'une m&eacute;moire
secondaire. Par extension swapper devient l'action de d&eacute;placer
une zone m&eacute;moire de la m&eacute;moire vers le support de swap
(en g&eacute;n&eacute;ral un disque) ou r&eacute;ciproquement du
p&eacute;riph&eacute;rique de swap vers la m&eacute;moire.<BR><BR>Le
syst&egrave;me va r&eacute;aliser cet &eacute;change &agrave; chaque
changement de contexte. Les syst&egrave;mes de swap utilisent une
m&eacute;moire secondaire qui est en g&eacute;n&eacute;ral un disque
mais on peut utiliser d'autre supports secondaires plus lents ou plus
rapides comme des bandes ou m&eacute;moires secondaires (non
accessibles par l'unit&eacute; de traitement).<!--TOC subsection <FONT SIZE=5>Le coût du swap</FONT>--></FONT></P>
<H3><FONT SIZE=5>9.1.6&nbsp;&nbsp; Le co&ucirc;t du swap</FONT></H3>
<P><FONT SIZE=5><!--SEC END -->Sur un tel syst&egrave;me, le temps de
commutation de t&acirc;ches est tr&egrave;s important. Il est donc
n&eacute;cessaire que chaque processus reste possesseur de l'unit&eacute;
de traitement un temps suffisamment long pour que le ralentissement
d&ucirc; au swap ne soit pas trop sensible. Que ce passe-t-il sinon ?
Le syst&egrave;me utilise la majeure partie de ses ressources &agrave;
d&eacute;placer des processus en et hors m&eacute;moire centrale.
L'unit&eacute; de traitement n'est plus utilis&eacute;e au maximum
...<!--TOC subsection <FONT SIZE=5>Utilisation de la taille des processus</FONT>--></FONT></P>
<H3><FONT SIZE=5>9.1.7&nbsp;&nbsp; Utilisation de la taille des
processus</FONT></H3>
<P><!--SEC END --><FONT SIZE=5>Pour am&eacute;liorer les m&eacute;canismes
de swap, on remarque que le temps de swap est proportionnel &agrave;
la taille des donn&eacute;es &agrave; d&eacute;placer. Pour am&eacute;liorer
les performances, il faut donc introduire la notion de taille
effective d'un processus, ce qui permet d'am&eacute;liorer le d&eacute;bit
mais cela impose que toutes les augmentations ou r&eacute;ductions de
taille d'un processus utilisateur soient r&eacute;alis&eacute;e par
un appel syst&egrave;me (</FONT><TT><FONT SIZE=5>sbrk</FONT></TT><FONT SIZE=5>)
afin que le noyau connaisse &agrave; tout moment la taille r&eacute;elle
de chaque processus.<!--TOC subsection <FONT SIZE=5>Swap et exécutions concurrentes</FONT>--></FONT></P>
<H3><FONT SIZE=5>9.1.8&nbsp;&nbsp; Swap et ex&eacute;cutions
concurrentes</FONT></H3>
<P><FONT SIZE=5><!--SEC END -->Une autre approche tr&egrave;s
efficace est de r&eacute;aliser le swap pendant l'ex&eacute;cution
d'un autre processus. Mais avec le syst&egrave;me de registres de
relocation c'est dangereux. En effet nous ne pouvons pas assurer
qu'un processus utilisateur donn&eacute; ne va pas &eacute;crire dans
les adresses r&eacute;serv&eacute;es &agrave; un autre processus.<!--TOC subsection <FONT SIZE=5>Contraintes</FONT>--></FONT></P>
<H3><FONT SIZE=5>9.1.9&nbsp;&nbsp; Contraintes</FONT></H3>
<P><FONT SIZE=5><!--SEC END -->Le swap introduit d'autres
contraintes&nbsp;: un processus doit &ecirc;tre en pr&eacute;empt&eacute;
actif pour &ecirc;tre swapp&eacute;, c'est &agrave; dire n'&ecirc;tre
en attente d'aucune entr&eacute;e-sortie. En effet, si P1 demande une
E/S et pendant cette demande il y a &eacute;change de P1 et P2, alors
la lecture demand&eacute;e par P1 a lieu dans les donn&eacute;es de
P2.<!--TOC subsection <FONT SIZE=5>Deux solutions existent</FONT>--></FONT></P>
<H3><FONT SIZE=5>9.1.10&nbsp;&nbsp; Deux solutions existent</FONT></H3>
<P><FONT SIZE=5><!--SEC END -->Soit ne jamais swapper de processus en
attente d'entr&eacute;es-sorties. Soit r&eacute;aliser toutes les
entr&eacute;es-sorties dans des buffers internes au noyau (solution
UNIX), ce qui a pour co&ucirc;t une recopie m&eacute;moire &agrave;
m&eacute;moire suppl&eacute;mentaire par E/S. Les transferts entre le
noyau et le processus ayant lieu uniquement quand le processus est en
m&eacute;moire.<!--TOC subsection <FONT SIZE=5>Les problèmes de protection</FONT>--></FONT></P>
<H3><FONT SIZE=5>9.1.11&nbsp;&nbsp; Les probl&egrave;mes de
protection</FONT></H3>
<P><FONT SIZE=5><!--SEC END -->Nous venons d'apercevoir des probl&egrave;mes
de protection entre un processus et le noyau. Si l'on autorise
plusieurs processus &agrave; r&eacute;sider en m&eacute;moire en m&ecirc;me
temps, il nous faut un m&eacute;canisme de protection
inter-processus.<BR>Deux m&eacute;thodes sont couramment utilis&eacute;es&nbsp;:
les extensions du registre barri&egrave;re et du registre de base
(relocation). <!--TOC subsection <FONT SIZE=5>Les registres doubles</FONT>--></FONT></P>
<H3><FONT SIZE=5>9.1.12&nbsp;&nbsp; Les registres doubles</FONT></H3>
<P ALIGN=CENTER STYLE="margin-left: 1cm; margin-right: 1cm; border-top: none; border-bottom: 1.10pt double #808080; border-left: none; border-right: none; padding: 0cm">
<FONT SIZE=1 STYLE="font-size: 6pt"><!--SEC END --></FONT><BR><BR>
</P>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML050.gif" NAME="Image52" ALIGN=BOTTOM WIDTH=321 HEIGHT=131 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
9.9&nbsp;: Double registre barri&egrave;re.</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="mem6"></A><BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<P><FONT SIZE=5>Deux registres Barri&egrave;re Bas et Haut <BR>Si
Adresse &lt; Bas <FONT FACE="symbol">&frac34;&reg;</FONT> lever une
exception erreur d'adresse<BR>Si Adresse &gt;= Haut <FONT FACE="symbol">&frac34;&reg;</FONT>
lever une exception erreur d'adresse<BR>Sinon adresse correcte.</FONT></P>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML051.gif" NAME="Image53" ALIGN=BOTTOM WIDTH=319 HEIGHT=142 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
9.10&nbsp;: Base et Limite.</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="mem7"></A><BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<P><FONT SIZE=5>Deux registres de relocation <I>Base</I> et <I>Limit</I>,
on travaille avec des adresses logiques <I>Limit</I> donne la valeur
maximale d'une adresse logique et <I>Base</I> donne la position en
m&eacute;moire de l'adresse logique z&eacute;ro.<BR>Si Adresse &gt;=
<I>Limit</I> <FONT FACE="symbol">&frac34;&reg;</FONT> lever une
exception erreur d'adresse<BR>sinon utiliser l'adresse physique
Adresse+<I>Base</I>.<BR><!--TOC section <FONT SIZE=5>Ordonnancement en mémoire des processus</FONT>--></FONT><BR><BR>
</P>
<H2><FONT SIZE=5>9.2&nbsp;&nbsp; Ordonnancement en m&eacute;moire des
processus</FONT></H2>
<P><FONT SIZE=5><!--SEC END -->Les choix de l'impl&eacute;mentation
des m&eacute;canismes d'adressage influence &eacute;norm&eacute;ment
l'ordonnancement des processus.<BR><BR>Nous travaillons dans le cas
d'un syst&egrave;me de traitement par lots c'est &agrave; dire en
temps partag&eacute; mais les processus restent en m&eacute;moire
tout le temps de leur ex&eacute;cution. S'il n'y a plus de place le
processus est mis en attente (i.e. non charg&eacute; en m&eacute;moire).
</FONT>
</P>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML052.gif" NAME="Image54" ALIGN=BOTTOM WIDTH=319 HEIGHT=207 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
9.11&nbsp;: Une situation d'ordonnancement de processus en m&eacute;moire.</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="mem.ordo.1"></A><BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<P><FONT SIZE=5>Nous devons r&eacute;soudre le probl&egrave;me
suivant&nbsp;: il nous faut un algorithme pour choisir dynamiquement,
parmi les blocs libres de la m&eacute;moire centrale, celui qui va
recevoir le nouveau processus (algorithme d'allocation de m&eacute;moire
&agrave; un processus). On reconna&icirc;t en g&eacute;n&eacute;ral
trois m&eacute;thodes&nbsp;: </FONT>
</P>
<DL>
	<DT><FONT SIZE=5>First-fit First-fit</FONT></DT><DD>
	<FONT SIZE=5>Le premier bloc suffisamment grand pour contenir notre
	processus est choisi. </FONT>
	</DD><DT>
	<FONT SIZE=5>Best-fit</FONT></DT><DD>
	<FONT SIZE=5>Le plus petit bloc suffisamment grand pour contenir
	notre processus est choisi.Best-fit </FONT>
	</DD><DT>
	<FONT SIZE=5>Worst-fit</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>Le bloc qui nous laisse le plus grand morceau de
	m&eacute;moire libre est choisi (le plus grand bloc).Worst-fit </FONT>
	</DD></DL>
<P>
<FONT SIZE=5>De nombreuse exp&eacute;riences pratiques et des
simulations ont montr&eacute; que le meilleur est first-fit puis
best-fit et que ces deux algorithmes sont beaucoup plus efficaces que
worst-fit. <B>Compactage</B> On cherche &agrave; am&eacute;liorer ces
m&eacute;canismes en d&eacute;fragmentant la m&eacute;moire c'est &agrave;
dire en d&eacute;pla&ccedil;ant les processus en m&eacute;moire de
fa&ccedil;on &agrave; rendre contigu&euml;s les zones de m&eacute;moire
libre de fa&ccedil;on &agrave; pouvoir les utiliser. </FONT>
</P>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML053.gif" NAME="Image55" ALIGN=BOTTOM WIDTH=315 HEIGHT=211 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
9.12&nbsp;: Compactage</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="mem.ordo.3"></A><BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML054.gif" NAME="Image56" ALIGN=BOTTOM WIDTH=318 HEIGHT=157 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
9.13&nbsp;: Plusieurs d&eacute;placements possibles.</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="mem.ordo.2"></A><BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<P><FONT SIZE=5>compactage<!--TOC section <FONT SIZE=5>Allocation non-contiguë</FONT>-->
</FONT>
</P>
<H2><FONT SIZE=5>9.3&nbsp;&nbsp; Allocation non-contigu&euml;</FONT></H2>
<H3><FONT SIZE=5><!--SEC END --><!--TOC subsection <FONT SIZE=5>Les pages et la pagination</FONT>-->9.3.1&nbsp;&nbsp;
Les pages et la pagination</FONT></H3>
<P><!--SEC END --><FONT SIZE=5>pages Pour acc&eacute;l&eacute;rer ces
m&eacute;canismes d'allocation, la notion de page a &eacute;t&eacute;
introduite.<BR><BR>On va d&eacute;couper la m&eacute;moire et les
processus en pages. Gr&acirc;ce &agrave; ce syst&egrave;me, il ne
sera plus n&eacute;cessaire de placer les processus dans une zone
contig&uuml;e de la m&eacute;moire. Il devient possible d'allouer de
la m&eacute;moire &agrave; un processus sans avoir &agrave; r&eacute;aliser
de compactage !<BR><BR>Ce principe des page n&eacute;cessite de
nouvelles possibilit&eacute;s mat&eacute;rielles. Toute adresse est
maintenant consid&eacute;r&eacute;e comme un couple <BR><BR>(Num&eacute;ro
de page, Position dans la page)</FONT></P>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML055.gif" NAME="Image57" ALIGN=BOTTOM WIDTH=321 HEIGHT=179 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
9.14&nbsp;: Calcul d'une adresse avec la table des pages</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="mem.page"></A><BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<P><FONT SIZE=5>A &nbsp;: adresse logique, P &nbsp;: taille de page
<BR>Num&eacute;ro de page = A div P<BR>Position = A modulo P<!--TOC subsection <FONT SIZE=5>Ordonnancement des processus dans une mémoire paginée </FONT>--></FONT></P>
<H3><FONT SIZE=5>9.3.2&nbsp;&nbsp; Ordonnancement des processus dans
une m&eacute;moire pagin&eacute;e </FONT>
</H3>
<P><!--SEC END --><FONT SIZE=5>Le choix de l'organisation m&eacute;moire
a une influence pr&eacute;pond&eacute;rante sur l'ordonnancement des
processus, qui devient beaucoup plus ind&eacute;pendant de la m&eacute;moire
quand celle-ci est pagin&eacute;e.<BR>ordonnancement Le d&eacute;savantage
de la m&eacute;thode de gestion de m&eacute;moire par un m&eacute;canisme
de page est le ph&eacute;nom&egrave;ne de <B>fragmentation interne</B>.
On alloue une page enti&egrave;re alors que le processus ne l'utilise
qu'en partie. Mais la taille des m&eacute;moires et des processus
deviennent tels par rapport aux tailles de page que cette perte
devient minime.<BR>Un avantage des pages est une plus grande
simplicit&eacute; du partage de la m&eacute;moire entre diff&eacute;rents
processus. En particulier quand plusieurs processus partagent le m&ecirc;me
code. La page qui contient du code utilis&eacute; par les processus
sera partageable et prot&eacute;g&eacute;e en &eacute;criture.<BR>Sous
Unix le compilateur produit automatiquement des programmes dont la
partie code est partageable. </FONT>
</P>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML056.gif" NAME="Image58" ALIGN=BOTTOM WIDTH=314 HEIGHT=214 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
9.15&nbsp;: La m&eacute;moire logique et la Table des pages.</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="mem.page2"></A><BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<H3><FONT SIZE=5><!--TOC subsection <FONT SIZE=5>Comment protéger la mémoire paginée</FONT>-->9.3.3&nbsp;&nbsp;
Comment prot&eacute;ger la m&eacute;moire pagin&eacute;e</FONT></H3>
<P><FONT SIZE=5><!--SEC END -->Les protections d'acc&egrave;s sont
faites au niveau de la table des pages.<BR><BR>On a une table des
pages globale. C'est donc le syst&egrave;me qui alloue les pages &agrave;
un processus, qui par construction (du syst&egrave;me de pagination)
ne peut pas &eacute;crire en dehors de ses propres pages. De plus,
dans la table des pages d'un processus, des drapeaux indiquent le
type de page (droits d'acc&egrave;s en lecture/&eacute;criture/ex&eacute;cution).<!--TOC subsection <FONT SIZE=5>La mémoire segmentée</FONT>--></FONT></P>
<H3><FONT SIZE=5>9.3.4&nbsp;&nbsp; La m&eacute;moire segment&eacute;e</FONT></H3>
<P><FONT SIZE=5><!--SEC END -->Nous venons de voir que les adresses
logiques utilis&eacute;es par le programmeur sont diff&eacute;rentes
des adresses physiques.<BR><BR>La m&eacute;moire segment&eacute;e est
une organisation de la m&eacute;moire qui respecte le comportement
usuel des programmeurs, qui g&eacute;n&eacute;ralement voient la
m&eacute;moire comme un ensemble de tableaux distincts contenant des
informations de types diff&eacute;rents. Un segment pour chaque
type&nbsp;: donn&eacute;es, code, table des symboles, librairies etc.
Ces diff&eacute;rentes zones ayant des tailles vari&eacute;es, et
parfois variables au cours du temps (le tas par exemple).</FONT></P>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML057.gif" NAME="Image59" ALIGN=BOTTOM WIDTH=321 HEIGHT=189 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
9.16&nbsp;: M&eacute;moire segment&eacute;e</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="mem.seg"></A><BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<P><FONT SIZE=5>La m&eacute;moire segment&eacute;e non pagin&eacute;e
pose des probl&egrave;mes de compactage (d&eacute;fragmentation). La
strat&eacute;gie id&eacute;ale est&nbsp;: la m&eacute;moire en
segments pagin&eacute;s.<!--TOC chapter <FONT SIZE=5>La mémoire virtuelle</FONT>--></FONT></P>
<H1><FONT SIZE=5>Chapitre&nbsp;10&nbsp;&nbsp; La m&eacute;moire
virtuelle</FONT></H1>
<P><FONT SIZE=5><!--SEC END -->Les m&eacute;thodes de gestion m&eacute;moire
que nous venons de voir ont toutes un d&eacute;faut majeur qui est de
garder l'ensemble du processus en m&eacute;moire, ce qui donne : </FONT>
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>swap un co&ucirc;t en
	swap important </FONT>
	</P>
	<LI><P><FONT SIZE=5>Impossibilit&eacute; de cr&eacute;er de tr&egrave;s
	gros processus. </FONT>
	</P>
</UL>
<P><FONT SIZE=5>Les m&eacute;thodes de m&eacute;moire virtuelle
permettent d'ex&eacute;cuter un programme qui ne tient pas
enti&egrave;rement en m&eacute;moire centrale&nbsp;!<BR><BR>Nous
avons commenc&eacute; par pr&eacute;senter des algorithmes de gestion
de la m&eacute;moire qui utilisent le concept de base
suivant&nbsp;:<BR>l'ensemble de l'espace logique adressable d'un
processus doit &ecirc;tre en m&eacute;moire pour pouvoir ex&eacute;cuter
le processus.<BR>Cette restriction semble &agrave; la fois
raisonnable et n&eacute;cessaire, mais aussi tr&egrave;s dommageable
car cela limite la taille des processus &agrave; la taille de la
m&eacute;moire physique.<BR>Or si l'on regarde des programmes tr&egrave;s
standards, on voit que&nbsp;: </FONT>
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>il y des portions de
	code qui g&egrave;rent des cas tr&egrave;s inhabituels qui ont lieu
	tr&egrave;s rarement (si ils ont lieu) </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>les tableaux, les
	listes et autres tables sont en g&eacute;n&eacute;ral initialis&eacute;s
	&agrave; des tailles beaucoup plus grandes que ce qui est r&eacute;ellement
	utile </FONT>
	</P>
	<LI><P><FONT SIZE=5>Certaines options d'application sont tr&egrave;s
	rarement utilis&eacute;es </FONT>
	</P>
</UL>
<P><FONT SIZE=5>M&ecirc;me dans le cas o&ugrave; le programme en
entier doit r&eacute;sider en m&eacute;moire, tout n'est peut-&ecirc;tre
pas absolument n&eacute;cessaire en m&ecirc;me temps.<BR><BR>Avec la
m&eacute;moire virtuelle, la m&eacute;moire logique devient beaucoup
plus grande que la m&eacute;moire physique.<BR><BR>De nombreux
avantages&nbsp;:<BR>Comme les utilisateurs consomment
individuellement moins de m&eacute;moire, plus d'utilisateurs peuvent
travailler en m&ecirc;me temps. Avec l'augmentation de l'utilisation
du CPU et de d&eacute;bit que cela implique (mais pas d'augmentation
de la vitesse).<BR><BR>Moins d'entr&eacute;es-sorties sont effectu&eacute;es
pour l'ex&eacute;cution d'un processus, ce qui fait que le processus
s'ex&eacute;cute (temps r&eacute;el) plus rapidement.<!--TOC subsection <FONT SIZE=5>Les overlays</FONT>--></FONT></P>
<H3><FONT SIZE=5>10.0.5&nbsp;&nbsp; Les overlays</FONT></H3>
<P><!--SEC END --><FONT SIZE=5>overlays Une des premi&egrave;res
versions d'ex&eacute;cutables partiellement en m&eacute;moire est
celle des &quot;overlay&quot; qui est l'id&eacute;e de charger
successivement des portions disjointes et diff&eacute;rentes de code
en m&eacute;moire, ex&eacute;cut&eacute;es l'une apr&egrave;s
l'autre.<BR><BR>Les diff&eacute;rentes passes d'un compilateur sont
souvent r&eacute;alis&eacute;es en utilisant un overlay
(pr&eacute;processeurs, pass1, pass2, pour les compilateurs C).<BR><BR>Les
overlay n&eacute;cessitent quelques adaptations de l'&eacute;diteur
de liens et des m&eacute;canismes de relocation.<!--TOC subsection <FONT SIZE=5>Le chargement dynamique</FONT>--></FONT></P>
<H3><FONT SIZE=5>10.0.6&nbsp;&nbsp; Le chargement dynamique</FONT></H3>
<P><!--SEC END --><FONT SIZE=5>chargement dynamique Un autre syst&egrave;me
couramment utilis&eacute; dans les logiciels du march&eacute; des
micros est le chargement dynamique. Avec le chargement dynamique, une
fonction n'est charg&eacute;e en m&eacute;moire qu'au moment de son
appel. Le chargement dynamique demande que toutes les fonctions
soient repositionnables en m&eacute;moire de fa&ccedil;on
ind&eacute;pendante.<BR><BR>A chaque appel de fonction on regarde si
la fonction est en m&eacute;moire sinon un &eacute;diteur de liens
dynamique est appel&eacute; pour la charger.<BR><BR>Dans les deux cas
(overlay et chargement dynamique), le syst&egrave;me joue un r&ocirc;le
tr&egrave;s restreint, il suffit en effet d'avoir un bon syst&egrave;me
de gestion de fichiers.<BR><BR>Malheureusement, </FONT><EM><FONT SIZE=5>le
travail</FONT></EM><FONT SIZE=5> que doit r&eacute;aliser le
programmeur pour choisir les overlays et/ou installer un m&eacute;canisme
de chargement dynamique efficace </FONT><EM><FONT SIZE=5>est non
trivial</FONT></EM><FONT SIZE=5> et requiert que le programmeur ait
une </FONT><EM><FONT SIZE=5>parfaite connaissance</FONT></EM><FONT SIZE=5>
du programme.<BR><BR>Ceci nous am&egrave;ne aux </FONT><EM><FONT SIZE=5>techniques
automatiques</FONT></EM><FONT SIZE=5>.<!--TOC section <FONT SIZE=5>Demand Paging</FONT>--></FONT></P>
<H2><FONT SIZE=5>10.1&nbsp;&nbsp; Demand Paging</FONT></H2>
<P><!--SEC END --><FONT SIZE=5>Demand Paging La m&eacute;thode de
<B>Demand Paging</B> est la plus r&eacute;pandue des impl&eacute;mentations
de m&eacute;moire virtuelle, elle demande de nombreuse capacit&eacute;s
mat&eacute;rielles.<BR>Nous partons d'un syst&egrave;me de swap o&ugrave;
la m&eacute;moire est d&eacute;coup&eacute;e en pages. Comme pour le
swap, quand un programme doit &ecirc;tre ex&eacute;cut&eacute; nous
le chargeons en m&eacute;moire (swap in) mais au lieu de faire un
swap complet, on utilise un &quot;swappeur paresseux&quot; (lazy
swapper).<BR>lazy swapper Un swappeur paresseux charge une page
<B>uniquement si</B> elle est n&eacute;cessaire.<BR>Que ce passe-t-il
quand le programme essaie d'acc&eacute;der &agrave; une page qui est
hors m&eacute;moire ? </FONT>
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>le mat&eacute;riel va
	traduire l'adresse logique en une adresse physique gr&acirc;ce &agrave;
	la table des pages. </FONT>
	</P>
	<LI><P><FONT SIZE=5>tant que les pages demand&eacute;es sont en
	m&eacute;moire, le programme tourne normalement, sinon si la page
	est contenue dans l'espace des adresses logiques mais n'est pas
	charg&eacute;e, il y a une <B>page fault</B>. page fault </FONT>
	</P>
</UL>
<P><FONT SIZE=5>En g&eacute;n&eacute;ral, une erreur d'adresse est
d&ucirc;e &agrave; une tentative d'acc&egrave;s &agrave; une adresse
ext&eacute;rieure (invalide). Dans ce cas, le programme doit &ecirc;tre
interrompu, c'est le comportement normal d'un syst&egrave;me de
swap.<BR><BR>Mais il est possible avec un swappeur paresseux que la
page existe mais ne soit pas en m&eacute;moire centrale, d'o&ugrave;
les &eacute;tapes suivantes dans ce cas&nbsp;: </FONT>
</P>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML058.gif" NAME="Image60" ALIGN=BOTTOM WIDTH=315 HEIGHT=283 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
10.1&nbsp;: Etapes de la gestion d'une erreur de page</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="mem.fault"></A><BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<P><FONT SIZE=5>On peut faire d&eacute;marrer un processus sans
aucune page en m&eacute;moire. La premi&egrave;re <B>Page Fault</B>
aurait lieu &agrave; la lecture de la premi&egrave;re instruction
(l'instruction n'&eacute;tant pas en m&eacute;moire).<BR><BR>Il faut
r&eacute;aliser une forme sp&eacute;ciale de sauvegarde de contexte,
il faut garder une image de l'&eacute;tat du processus qui vient
d'effectuer une <B>Page Fault</B> mais de plus il faudra red&eacute;marrer
(r&eacute;ex&eacute;cuter) l'instruction qui a plac&eacute; le
processus dans cet &eacute;tat, en effet il est possible que
l'instruction ne se soit pas termin&eacute; par manque de
donn&eacute;es.<BR><BR>Le syst&egrave;me d'exploitation a ici un r&ocirc;le
important, c'est lui qui va r&eacute;aliser le chargement de la page
manquante puis relancer le processus et l'instruction.<BR><BR>Les
circuits n&eacute;cessaires &agrave; la m&eacute;thode de Demande
Paging sont les m&ecirc;mes que ceux que l'on utilise pour un syst&egrave;me
de swap pagin&eacute;, c'est-&agrave;-dire une m&eacute;moire
secondaire et un gestionnaire de pages (table des pages).<BR><BR>Par
contre, la partie logicielle est beaucoup plus importante.<BR><BR>Enfin
il faut que les <B>instructions soient interruptibles</B>, ce qui
n'est pas toujours le cas sur tous les processeurs et ce qui est
fondamental, comme nous allons le voir sur des exemples:<BR><BR>add
A,B in C</FONT></P>
<OL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>chercher et d&eacute;coder
	l'instruction add </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>charger le contenu de
	l'adresse A </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>charger le contenu de
	l'adresse B </FONT>
	</P>
	<LI><P><FONT SIZE=5>sommer et sauvegarder dans C </FONT>
	</P>
</OL>
<P><FONT SIZE=5>Si l'erreur de page a lieu dans le 4i&egrave;me acc&egrave;s
&agrave; la m&eacute;moire (C), il faudra de nouveau recommencer les
3 acc&egrave;s m&eacute;moire de l'instruction, c'est-&agrave;-dire
lire l'instruction, etc.<BR><BR>Un autre type de probl&egrave;me
vient d'instructions comme la suivante que l'on trouve sur PDP-11
&nbsp;:<BR><BR>MOV (R2)++,--(R3)<BR><BR>cette instruction d&eacute;place
l'objet point&eacute; par le registre R2 dans l'adresse point&eacute;
par R3, R2 est incr&eacute;ment&eacute; apr&egrave;s le transfert et
R3 avant.<BR><BR>Que se passe-t-il si l'on a une erreur de page en
cherchant &agrave; acc&eacute;der &agrave; la page point&eacute; par
R3 ?<!--TOC subsection <FONT SIZE=5>Efficacité</FONT>--></FONT></P>
<H3><FONT SIZE=5>10.1.1&nbsp;&nbsp; Efficacit&eacute;</FONT></H3>
<P><FONT SIZE=5><!--SEC END -->Efficacit&eacute; des performances de
Demand Paging &nbsp;:<BR>Soit ma = 500 nanosecondes, le temps moyen
d'acc&egrave;s a une m&eacute;moire.<BR>le temps effectif d'acc&egrave;s
avec le Demand Paging est <BR>temps effectif = (1-p)*ma + p * &quot;temps
de gestion de l'erreur de page&quot;<BR>o&ugrave; p est la
probabilit&eacute; d'occurrence d'une erreur de page (page
fault).<BR><BR>Une erreur de page n&eacute;cessite de r&eacute;aliser
les op&eacute;rations suivantes </FONT>
</P>
<OL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>lever une
	interruption pour le syst&egrave;me </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>sauvegarder le
	contexte du processus </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>d&eacute;terminer que
	l'interruption est une erreur de page </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>v&eacute;rifier que
	la page en question est une page l&eacute;gale de l'espace logique,
	d&eacute;terminer o&ugrave; se trouve la page dans la m&eacute;moire
	secondaire. </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>ex&eacute;cuter une
	lecture de la page sur une page m&eacute;moire libre (lib&eacute;rer
	&eacute;ventuellement une page cf. algorithme de remplacement de
	page) </FONT>
	</P>
	<UL>
		<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>attendre que le
		p&eacute;riph&eacute;rique soit libre </FONT>
		</P>
		<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>temps de latence du
		p&eacute;riph&eacute;rique </FONT>
		</P>
		<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>commencer le
		transfert </FONT>
		</P>
	</UL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>allouer pendant ce
	temps-l&agrave; le cpu &agrave; un autre utilisateur </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>interruption du
	p&eacute;riph&eacute;rique </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>sauvegarde du
	contexte du processus courant </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>d&eacute;terminer que
	l'interruption &eacute;tait la bonne interruption (venant du
	p&eacute;riph&eacute;rique) </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>mise &agrave; jour de
	la table des pages et d'autres pages pour indiquer que la page
	demand&eacute;e est en m&eacute;moire maintenant. </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>attendre que le
	processus soit s&eacute;lectionn&eacute; de nouveau pour utiliser
	l'unit&eacute; centrale (cpu) </FONT>
	</P>
	<LI><P><FONT SIZE=5>charger le contexte du processus ! </FONT>
	</P>
</OL>
<P><FONT SIZE=5>Toutes ces instructions ne sont pas toujours
r&eacute;alis&eacute;es (on peut en particulier supposer que l'on ne
peut pas pr&eacute;empter l'unit&eacute; centrale, mais alors quelle
perte de temps pour l'ensemble du syst&egrave;me).<BR><BR>Dans tous
les cas, nous devons au moins r&eacute;aliser les 3 actions
suivantes&nbsp;:</FONT></P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>g&eacute;rer
	l'interruption </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>swapper la page
	demand&eacute;e </FONT>
	</P>
	<LI><P><FONT SIZE=5>relancer le processus </FONT>
	</P>
</UL>
<P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Ce qui co&ucirc;te le plus
cher est la recherche de la page sur le disque et son transfert en
m&eacute;moire, ce qui prend de l'ordre de 1 &agrave; 10
millisecondes.<BR>Ce qui nous donne en prenant une vitesse d'acc&egrave;s
m&eacute;moire de 1 microseconde et un temps de gestion de page de 5
millisecondes un </FONT>
</P>
<P ALIGN=CENTER STYLE="margin-bottom: 0cm"><FONT SIZE=5>temps
effectif = (1 - <I>p</I>) + <I>p</I> &times; 5000 &nbsp;
microsecondes </FONT>
</P>
<P><BR><FONT SIZE=5>Une erreur de page toutes les mille pages nous
donne un temps effectif onze fois plus long que l'acc&egrave;s
standard.<BR>Il faut r&eacute;duire &agrave; moins d'une erreur de
page tout les 100000 acc&egrave;s pour obtenir une d&eacute;gradation
inf&eacute;rieure &agrave; 10<BR><BR>On comprend bien que les choix &agrave;
faire sur des pages qu'il faut placer en m&eacute;moire sont donc
tr&egrave;s importants.<BR>Ces choix deviennent encore plus
importants quand l'on a de nombreux utilisateurs et qu'il y a
sur-allocation de la m&eacute;moire, ex&eacute;cution concurrente de
6 processus de la taille sup&eacute;rieure ou &eacute;gale &agrave;
la m&eacute;moire physique&nbsp;!<BR>Si l'on suppose de plus que nos
6 programmes utilisent dans une petite s&eacute;quence d'instructions
toutes les pages de leur m&eacute;moire logique, nous nous trouvons
alors dans une situation de p&eacute;nurie de pages libres.<BR>Le
syst&egrave;me d'exploitation peut avoir recoure &agrave; plusieurs
solution dans ce cas-l&agrave; </FONT>
</P>
<OL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>tuer le processus
	fautif ... </FONT>
	</P>
	<LI><P><FONT SIZE=5>utiliser un algorithme de remplacement de page </FONT>
	</P>
</OL>
<P><FONT SIZE=5>Cet algorithme de remplacement est introduit dans
notre s&eacute;quence de gestion d'erreur de page l&agrave; o&ugrave;
l'on s'attribuait une page libre de la m&eacute;moire
centrale.<BR>Maintenant il nous faut s&eacute;lectionner une victime,
c'est-&agrave;-dire, une des pages occup&eacute;es de la m&eacute;moire
centrale qui sera swapp&eacute;e sur disque et remplac&eacute;e par
la page demand&eacute;e.<BR>Remarquons que dans ce cas-l&agrave;
notre temps de transfert est doubl&eacute;, comme il faut &agrave; la
fois lire une page et sauvegarder une page sur disque (le temps de
transfert disque est ce qui est le plus co&ucirc;teux dans la gestion
d'une erreur de page).<BR>Il est possible de r&eacute;aliser des
syst&egrave;mes de <B>demand segments</B>, mais le lecteur avis&eacute;
remarquera rapidement les probl&egrave;mes pos&eacute;s par la taille
variable des segments.<!--TOC section <FONT SIZE=5>Les algorithmes de remplacement de page</FONT>--></FONT></P>
<H2><FONT SIZE=5>10.2&nbsp;&nbsp; Les algorithmes de remplacement de
page</FONT></H2>
<P><FONT SIZE=5><!--SEC END -->Un algorithme de remplacement de page
doit minimiser le nombre de Page Faults.<BR>On recherche l'algorithme
qui r&eacute;duit au mieux la probabilit&eacute; d'occurrence d'une
erreur de page.<BR>Un algorithme est &eacute;valu&eacute; en prenant
une cha&icirc;ne de num&eacute;ros de page et en comptant le nombre
de fautes de page qui ont lieu au cours de cette suite d'acc&egrave;s,
et cela en fonction du nombre de pages de m&eacute;moire centrale
dont il dispose.<BR>Pour illustrer les algorithmes de remplacement,
nous utiliserons la suite de pages suivante
:<BR>7,0,1,2,0,3,0,4,2,3,0,3,2,1,2,0,1,7,0,1<BR>et 3 pages en m&eacute;moire
centrale.<!--TOC subsection <FONT SIZE=5>Le remplacement optimal</FONT>--></FONT></P>
<H3><FONT SIZE=5>10.2.1&nbsp;&nbsp; Le remplacement optimal</FONT></H3>
<P><FONT SIZE=5><!--SEC END -->Utiliser comme victime la page qui ne
sera pas utilis&eacute;e pendant le plus longtemps.<BR><BR>Soit pour
notre suite : </FONT>
</P>
<PRE>
<FONT SIZE=5>7xx 70x 701 201 - 203 - 243 - -203 - - 201 - - - 701 - -</FONT></PRE><P>
<FONT SIZE=5>soit seulement 9 fautes de page.<BR><BR>Mais cet
&quot;algorithme&quot; n'est valable que dans un cas o&ugrave; l'on
conna&icirc;t &agrave; l'avance les besoins, ce qui n'est
g&eacute;n&eacute;ralement pas le cas.<!--TOC subsection <FONT SIZE=5>Le remplacement peps (FIFO)</FONT>--></FONT></P>
<H3><FONT SIZE=5>10.2.2&nbsp;&nbsp; Le remplacement peps (FIFO)</FONT></H3>
<P><FONT SIZE=5><!--SEC END -->L'algorithme le plus simple est
Premier Entr&eacute; Premier Sorti (First-In-First-Out ).<BR>Quand
une victime doit &ecirc;tre s&eacute;lectionn&eacute;e c'est la page
la plus ancienne qui est s&eacute;lectionn&eacute;e.<BR>Soit pour la
liste </FONT>
</P>
<PRE>
<FONT SIZE=5>7,0,1,2,0,3,0,4,2,3,0,3,2,1,2,0,1,7,0,1</FONT></PRE><P>
<FONT SIZE=5>et trois page de m&eacute;moire centrale&nbsp;: </FONT>
</P>
<PRE>
<FONT SIZE=5>7XX/70X/701/201-201/231/230/430/420/423/</FONT>
<FONT SIZE=5>023-023-023/013/012-012-012/712/702/701  </FONT></PRE><P>
<FONT SIZE=5>soit <B>Quinze</B> Page Faults.<BR><BR>Ce m&eacute;canisme
rapide et simple &agrave; programmer n'est malheureusement pas tr&egrave;s
efficace. Il existe des suites de pages pour lesquelles cet
algorithme fait plus de page faults avec quatre pages m&eacute;moire
qu'avec trois ! (par exemple : 1,2,3,4,1,2,5,1,2,3,4,5).<!--TOC subsection <FONT SIZE=5>Moins récemment utilisée LRU.</FONT>--></FONT></P>
<H3><FONT SIZE=5>10.2.3&nbsp;&nbsp; Moins r&eacute;cemment utilis&eacute;e
LRU.</FONT></H3>
<P><FONT SIZE=5><!--SEC END -->LRU (Least Recently Used page).<BR>Nous
utilisons ici le vieillissement d'une page et non plus l'ordre de
cr&eacute;ation de la page. On fait le pari que les pages qui ont &eacute;t&eacute;
r&eacute;cemment utilis&eacute;es le seront dans un proche avenir,
alors que les pages qui n'ont pas &eacute;t&eacute; utilis&eacute;es
depuis longtemps ne sont plus utiles.<BR><BR>Soit pour notre suite&nbsp;:
</FONT>
</P>
<PRE>
<FONT SIZE=5>7xx 70x 701 201 - 203 - 403 402 432 032 - - 132 - 102 - 107 - </FONT></PRE><P>
<FONT SIZE=5>soit <B>Douze</B> Page Faults.<BR><BR>L'algorithme LRU
est un bon algorithme mais il pose de nombreux probl&egrave;mes
d'impl&eacute;mentation et peut demander de substantiels outils
mat&eacute;riels.<BR>Des solutions logicielles&nbsp;: </FONT>
</P>
<DL>
	<DT><FONT SIZE=5>Des compteurs</FONT></DT><DD>
	<FONT SIZE=5>&agrave; chaque entr&eacute;e de la table des pages, on
	ajoute un compteur de temps qui est mis &agrave; jour &agrave;
	chaque acc&egrave;s &agrave; la page. Il faut rechercher sur
	l'ensemble de la table la victime. De plus, ces temps doivent &ecirc;tre
	mis &agrave; jour quand on change de table de page (celle d'un autre
	processus ...). On ne peut utiliser le temps r&eacute;el ... </FONT>
	</DD><DT>
	<FONT SIZE=5>Une pile</FONT></DT><DD>
	<FONT SIZE=5>&agrave; chaque fois que l'on acc&egrave;de &agrave;
	une page, la page est plac&eacute;e en sommet de pile. Le dessus est
	toujours la page la plus r&eacute;cemment utilis&eacute;e et le fond
	de la pile la moins r&eacute;cemment utilis&eacute;e. </FONT>
	</DD><DT>
	<FONT SIZE=5>Des masques</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>On utilise un octet associ&eacute; &agrave; chaque
	page. Le syst&egrave;me positionne &agrave; 1 le bit de poids fort &agrave;
	chaque acc&egrave;s &agrave; la page. Toutes les N millisecondes
	(click d'horloge, cf clock, N = 100 sur fillmore) le syst&egrave;me
	fait un d&eacute;calage &agrave; droite de l'octet associ&eacute; &agrave;
	chaque page. On obtient ainsi un historique de l'utilisation de la
	page. L'octet &agrave; 00000000 indique que la page n'a pas &eacute;t&eacute;
	utilis&eacute;e depuis 8 cycles, 11111111 indique que la page a &eacute;t&eacute;
	utilis&eacute;e pendant les 8 cycles. La page de masque 11000100 &agrave;
	&eacute;t&eacute; utilis&eacute;e plus r&eacute;cemment que
	01110111. Si l'on interpr&egrave;te ces octets comme des entiers
	non-sign&eacute;s, c'est la page ayant le plus petit octet qui a &eacute;t&eacute;
	utilis&eacute;e le moins r&eacute;cemment (l'unicit&eacute; des
	num&eacute;ros n'&eacute;tant pas assur&eacute;e, la s&eacute;lection
	entre num&eacute;ros identiques se fait avec l'ordre FIFO). </FONT>
	</DD></DL>
<H3>
<FONT SIZE=5><!--TOC subsection <FONT SIZE=5>L'algorithme de la deuxième chance</FONT>-->10.2.4&nbsp;&nbsp;
L'algorithme de la deuxi&egrave;me chance</FONT></H3>
<P><FONT SIZE=5><!--SEC END -->Un bit associ&eacute; &agrave; chaque
page est positionn&eacute; &agrave; 1 &agrave; chaque fois qu'une
page est utilis&eacute;e par un processus. Avant de retirer une page
de la m&eacute;moire, on va essayer de lui donner une deuxi&egrave;me
chance. On utilise un algorithme FIFO plus la deuxi&egrave;me
chance&nbsp;:<BR>Si le bit d'utilisation est &agrave; 0, la page est
swapp&eacute;e hors m&eacute;moire (elle n'a pas &eacute;t&eacute;
utilis&eacute;e depuis la derni&egrave;re demande de page).<BR>Si le
bit est &agrave; 1, il est positionn&eacute; a z&eacute;ro et l'on
cherche une autre victime. Ainsi cette page ne sera swapp&eacute;e
hors m&eacute;moire que si toutes les autres pages ont &eacute;t&eacute;
utilis&eacute;es, et utilisent aussi leur deuxi&egrave;me chance.<BR>On
peut voir ceci comme une queue circulaire, o&ugrave; l'on avance sur
les pages qui ont le bit &agrave; 1 (en le positionnant &agrave;
z&eacute;ro) jusqu'&agrave; ce que l'on trouve une page avec le bit
d'utilisation &agrave; z&eacute;ro.<!--TOC subsection <FONT SIZE=5>Plus fréquemment utilisé MFU</FONT>--></FONT></P>
<H3><FONT SIZE=5>10.2.5&nbsp;&nbsp; Plus fr&eacute;quemment utilis&eacute;
MFU</FONT></H3>
<P><FONT SIZE=5><!--SEC END -->Plus fr&eacute;quemment
Utilis&eacute;e&nbsp;:<BR>Comme son nom l'indique, c'est la fr&eacute;quence
d'utilisation qui joue au lieu de l'anciennet&eacute;, mais c'est le
m&ecirc;me m&eacute;canisme que LRU. Ces deux algorithmes de LRU et
MFU sont rarement utilis&eacute;s car trop gourmands en temps de
calcul et difficiles &agrave; impl&eacute;menter, mais ils sont assez
efficaces.<!--TOC subsection <FONT SIZE=5>Le bit de saleté (Dirty Bit)</FONT>--></FONT></P>
<H3><FONT SIZE=5>10.2.6&nbsp;&nbsp; Le bit de salet&eacute; (Dirty
Bit)</FONT></H3>
<P><FONT SIZE=5><!--SEC END -->Remarquons que si il existe une copie
identique sur disque (zone de swap) d'une page de m&eacute;moire, il
n'est pas n&eacute;cessaire dans le cas d'un swapout de sauvegarder
la page sur disque, il suffit de la lib&eacute;rer.<BR>Le bit de
salet&eacute; permet d'indiquer qu'une page est (ou n'est plus)
conforme &agrave; la page en zone de swap.<BR><BR>Ce bit de propret&eacute;
est utilis&eacute; dans les autres algorithmes, on choisit entre deux
victimes possibles la plus propre, c'est-&agrave;-dire celle qui ne
n&eacute;cessite pas de swapout.<!--TOC section <FONT SIZE=5>Allocation de pages aux processus</FONT>--></FONT></P>
<H2><FONT SIZE=5>10.3&nbsp;&nbsp; Allocation de pages aux processus</FONT></H2>
<P><FONT SIZE=5><!--SEC END -->Comment r&eacute;partir les pages sur
les diff&eacute;rents processus et le syst&egrave;me ? </FONT>
</P>
<DL>
	<DT><FONT SIZE=5>remplacement local</FONT></DT><DD>
	<FONT SIZE=5>le processus se voit affect&eacute; un certain nombre
	de pages qu'il va utiliser de fa&ccedil;on autonome, son temps
	d'ex&eacute;cution ne d&eacute;pend que de son propre comportement. </FONT>
	</DD><DT>
	<FONT SIZE=5>remplacement global</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>le comportement d'allocation de pages aux processus
	d&eacute;pend de la charge du syst&egrave;me et du comportement des
	diff&eacute;rents processus. </FONT>
	</DD></DL>
<P>
<FONT SIZE=5>Le remplacement local demande que l'on r&eacute;alise un
partage entre les diff&eacute;rents processus.<BR>Le partage
&quot;&eacute;quitable&quot; &nbsp;: m pages de m&eacute;moire
physique, n processus, m/n pages par processus &nbsp;! On retrouve
ici un probl&egrave;me proche de la fragmentation interne, un grand
nombre de pages est donn&eacute; &agrave; un processus qui en utilise
effectivement peu.<BR>On fait un peu mieux en utilisant&nbsp;: <I>S</I>
= <FONT FACE="symbol">S</FONT> &nbsp; <I>s</I></FONT><I><FONT SIZE=4><SUB>i</SUB></FONT></I><FONT SIZE=5>
o&ugrave; <I>s</I></FONT><I><FONT SIZE=4><SUB>i</SUB></FONT></I><FONT SIZE=5>
est le nombre de pages de la m&eacute;moire logique du Processus i.
Chaque processus se voit attribu&eacute; (<I>s</I></FONT><I><FONT SIZE=4><SUB>i</SUB></FONT></I><FONT SIZE=5>
/ <I>S</I>) <I>m</I> pages. On am&eacute;liore en faisant varier ce
rapport en fonction de la priorit&eacute; de chaque processus.<!--TOC paragraph <FONT SIZE=5>Problèmes d'écroulement</FONT>--></FONT></P>
<H5><FONT SIZE=5>Probl&egrave;mes d'&eacute;croulement</FONT></H5>
<P><FONT SIZE=5><!--SEC END -->Si le nombre de pages allou&eacute;es
&agrave; un processus non-prioritaire tombe en dessous de son minimum
vital, ce processus est constamment en erreur de page &nbsp;: il
passe tout son temps &agrave; r&eacute;aliser des demandes de pages.
Ce processus doit &ecirc;tre alors &eacute;ject&eacute; enti&egrave;rement
en zone de swap et reviendra plus prioritaire quand il y aura de la
place.<BR><BR>Un exemple de bonne et mauvaise utilisation des pages
(rappel les compilateurs c allouent les tableaux sur des plages
d'adresse croissante contig&uuml;es int m[A][B] est un tableau de A
tableaux de B entiers) &nbsp;: </FONT>
</P>
<PRE>
<FONT SIZE=5>/* bonne initialisation */</FONT>
<FONT SIZE=5>int m[2048][2048];</FONT>
<FONT SIZE=5>main()</FONT>
<FONT SIZE=5>{int i,j;</FONT>
<FONT SIZE=5>for(i=0;i&lt;2048;i++)</FONT>
<FONT SIZE=5>        for(j=0;j&lt;2048;j++)</FONT>
<FONT SIZE=5>        m[i][j] = 1;       </FONT>
<FONT SIZE=5>}</FONT></PRE><P>
<FONT SIZE=5>ce processus acc&egrave;de a une nouvelle page toute les
2048 affectation. </FONT>
</P>
<PRE>
<FONT SIZE=5>/* mauvaise initialisation */</FONT>
<FONT SIZE=5>int m[2048][2048];</FONT>
<FONT SIZE=5>main()</FONT>
<FONT SIZE=5>{int i,j;</FONT>
<FONT SIZE=5>for(i=0;i&lt;2048;i++)</FONT>
<FONT SIZE=5>        for(j=0;j&lt;2048;j++)</FONT>
<FONT SIZE=5>        m[j][i] = 1;       </FONT>
<FONT SIZE=5>}</FONT></PRE><P>
<FONT SIZE=5>ce processus acc&egrave;de a une nouvelle page toute les
affectations&nbsp;!<BR>Attention&nbsp;: En </FONT><TT><FONT SIZE=5>fortran</FONT></TT><FONT SIZE=5>
l'allocation des tableaux se fait dans l'autre sens par colones
...<BR>Si la m&eacute;moire est libre et assez grande, les deux
processus sont grossi&egrave;rement aussi rapides, par contre si on
lance dix exemplaires du premier, le temps d'attente est juste
multipli&eacute; par 10. Pour le deuxi&egrave;me, le temps d'attente
est au moins multipli&eacute; par 100 (je n'ai pas attendu la fin de
l'ex&eacute;cution).<!--TOC section <FONT SIZE=5>L'appel fork et la mémoire virtuelle</FONT>--></FONT></P>
<H2><FONT SIZE=5>10.4&nbsp;&nbsp; L'appel fork et la m&eacute;moire
virtuelle</FONT></H2>
<P><!--SEC END --><FONT SIZE=5>Nous avons vu que la primitive </FONT><TT><FONT SIZE=5>fork()</FONT></TT><FONT SIZE=5>
r&eacute;alise une copie de l'image m&eacute;moire du processus p&egrave;re
pour cr&eacute;er le processus fils. Cette copie n'est pas int&eacute;grale
car les deux processus peuvent partager des pages marqu&eacute;es en
lecture seule, en particulier le segment du code est partag&eacute;
par les deux processus (r&eacute;entrance standard des processus
unix).<BR>Mais avec le syst&egrave;me de demand-paging, on peut
introduire une nouvelle notion qui est la &quot;copie sur &eacute;criture&quot;
(copy on write). On ajoute &agrave; la structure de page de la table
des pages des indicateurs de &quot;copie sur &eacute;criture&quot;.
L'id&eacute;e est de r&eacute;aliser la copie de la page uniquement
dans le cas o&ugrave; l'un des processus qui peuvent y acc&egrave;der
r&eacute;alise une &eacute;criture. Dans ce cas-l&agrave;, la page
est recopi&eacute;e avant l'&eacute;criture et le processus &eacute;crivain
poss&egrave;de alors sa propre page.<BR>L'int&eacute;r&ecirc;t de ce
m&eacute;canisme est surtout visible dans le cas tr&egrave;s fr&eacute;quent
o&ugrave; le </FONT><TT><FONT SIZE=5>fork</FONT></TT><FONT SIZE=5>
est imm&eacute;diatement suivi par un </FONT><TT><FONT SIZE=5>exec</FONT></TT><FONT SIZE=5>.
En effet, ce dernier va r&eacute;aliser une lib&eacute;ration de
toutes les pages, il est donc inutile de les recopier juste avant
cette lib&eacute;ration.<BR>Le syst&egrave;me BSD a introduit la
premi&egrave;re version de cette id&eacute;e en partant de l'appel
syst&egrave;me </FONT><TT><FONT SIZE=5>vfork()</FONT></TT><FONT SIZE=5>
qui lui permet le partage totale de toutes les pages entre le
processus p&egrave;re et le processus fils sans aucune copie.
L'int&eacute;r&ecirc;t est de pouvoir r&eacute;aliser rapidement un
</FONT><TT><FONT SIZE=5>execve</FONT></TT><FONT SIZE=5> sans avoir &agrave;
recopier l'espace d'adressage du processus p&egrave;re.<BR><!--TOC section <FONT SIZE=5>Projection de fichiers en mémoire</FONT>--></FONT><BR><BR>
</P>
<H2><FONT SIZE=5>10.5&nbsp;&nbsp; Projection de fichiers en m&eacute;moire</FONT></H2>
<P><A NAME="mmap"></A><!--SEC END --><FONT SIZE=5>La fonction </FONT><TT><FONT SIZE=5>mmap</FONT></TT><FONT SIZE=5>
permet la projection de fichiers en m&eacute;moire. Le segment du
fichier indiqu&eacute; est plac&eacute; en m&eacute;moire &agrave;
partir de l'adresse indiqu&eacute;e. Le segment de fichier peut ainsi
&ecirc;tre parcouru par des acc&egrave;s par adresse sans utiliser de
commande de lecture ou d'&eacute;criture.</FONT></P>
<PRE>
<FONT SIZE=5>#include &lt;sys/mman.h&gt;</FONT>
<FONT SIZE=5>#include &lt;sys/types.h&gt;</FONT>

<FONT SIZE=5>void *mmap(void  *adr, int len,</FONT>
<FONT SIZE=5>           int   prot, int options,</FONT>
<FONT SIZE=5>           int   desc, int offset);</FONT>

<FONT SIZE=5>int munmap(void *adr, int len);</FONT></PRE><P STYLE="margin-bottom: 0cm">
<FONT SIZE=5>appels syst&egrave;mes!mmap@</FONT><TT><FONT SIZE=5>mmap</FONT></TT><FONT SIZE=5>
appels syst&egrave;mes!munmap@</FONT><TT><FONT SIZE=5>munmap</FONT></TT><FONT SIZE=5>
<BR><BR>L'adresse </FONT><TT><FONT SIZE=5>adr</FONT></TT><FONT SIZE=5>
indique o&ugrave; doit &ecirc;tre plac&eacute; le fichier, cette
adresse doit &ecirc;tre une adresse de d&eacute;but de page (un
multiple de </FONT><TT><FONT SIZE=5>sysconf(_SC_PAGE_SIZE)</FONT></TT><FONT SIZE=5>),
si le param&egrave;tre est NULL alors le syst&egrave;me s&eacute;lectionne
l'adresse de placement qui est retourn&eacute;e par la fonction.
L'intervalle de position </FONT>
</P>
<P ALIGN=CENTER STYLE="margin-bottom: 0cm"><TT><FONT SIZE=5>[offset,
offset+len]</FONT></TT></P>
<P><FONT SIZE=5>du fichier </FONT><TT><FONT SIZE=5>desc</FONT></TT><FONT SIZE=5>
est plac&eacute; en m&eacute;moire.<BR></FONT><TT><FONT SIZE=5>prot</FONT></TT><FONT SIZE=5>
indique les protections d'acc&egrave;s sous HP-UX les protections
suivantes sont disponible&nbsp;: </FONT>
</P>
<PRE>
<FONT SIZE=5>---     PROT_NONE</FONT>
<FONT SIZE=5>r--     PROT_READ</FONT>
<FONT SIZE=5>r-x     PROT_READ|PROT_EXECUTE</FONT>
<FONT SIZE=5>rw      PROT_READ|PROT_WRITE</FONT>
<FONT SIZE=5>rwx     PROT_READ|PROT_WRITE|PROT_EXECUTE</FONT></PRE><P>
<TT><FONT SIZE=5>options</FONT></TT><FONT SIZE=5> indique si l'on
veut que les &eacute;critures r&eacute;alis&eacute;es dans les pages
contenant la projection soient partag&eacute;es (MAP_SHARED), ou au
contraire qu'une copie sur &eacute;criture soit r&eacute;alis&eacute;e
(MAP_PRIVATE).<BR><BR>La fonction </FONT><TT><FONT SIZE=5>munmap</FONT></TT><FONT SIZE=5>
permet de lib&eacute;rer la zone m&eacute;moire d'adresse </FONT><TT><FONT SIZE=5>adr</FONT></TT><FONT SIZE=5>
et de longueur </FONT><TT><FONT SIZE=5>len</FONT></TT><FONT SIZE=5>.<BR><BR>Pour
une autre forme de m&eacute;moire partag&eacute;e, voir le chapitre
</FONT><A HREF="#IPC"><FONT SIZE=5>16</FONT></A><FONT SIZE=5> sur les
IPC.<BR>Un exemple d'utilisation de </FONT><TT><FONT SIZE=5>mmap</FONT></TT><FONT SIZE=5>
pour copier un fichier&nbsp;:<BR></FONT><TT><FONT SIZE=5>#include
&lt;stdio.h&gt;<BR>#include &lt;sys/types.h&gt;<BR>#include
&lt;sys/stat.h&gt;<BR>#include &lt;sys/mman.h&gt;<BR>#include
&lt;fcntl.h&gt;<BR><BR>int main(int argc,char *argv[])<BR>{<BR>int
fdin,fdout;<BR>struct stat statbuf;<BR>char *src,*dst;<BR>if (argc !=
3)<BR>{<BR>fprintf(stderr,&quot;usage: %s source destination
&quot;,argv[0]);<BR>exit(-1);<BR>}<BR>if ((fdin = open(argv[1],
O_RDONLY)) &lt; 0)<BR>{<BR>fprintf(stderr,&quot;impossible d\'ouvrir:
%s en lecture &quot;,argv[1]);<BR>exit(-2);<BR>}<BR>if ((fdout =
open(argv[2], O_RDWR|O_CREAT|O_TRUNC,0666)) &lt;
0)<BR>{<BR>fprintf(stderr,&quot;impossible d\'ouvrir: %s en ecriture
&quot;,argv[2]);<BR>exit(-3);<BR>}<BR>if (fstat(fdin,&amp;statbuf) &lt;
0 )<BR>{<BR>fprintf(stderr,&quot;impossible de faire stat sur %s
&quot;,argv[1]);<BR>exit(-4);<BR>}<BR>if (lseek(fdout,
statbuf.st_size -1 , SEEK_SET) == -1 )<BR>{<BR>fprintf(stderr,&quot;impossible
de lseek %s &quot;,argv[2]);<BR>exit(-5);<BR>}<BR>if
(write(fdout,&quot;&quot;,1) != 1)<BR>{<BR>fprintf(stderr,&quot;impossible
d\'ecrire sur %s &quot;,argv[2]);<BR>exit(-6);<BR>}<BR>if ((src =
mmap (0,statbuf.st_size, PROT_READ,<BR>MAP_FILE | MAP_SHARED,
fdin,0)) == (caddr_t) -1 )<BR>{<BR>fprintf(stderr,&quot;impossible de
mapper %s &quot;,argv[1]);<BR>exit(-7);<BR>}<BR>if ((dst = mmap
(0,statbuf.st_size, PROT_READ | PROT_WRITE,<BR>MAP_FILE | MAP_SHARED,
fdout,0)) == (caddr_t) -1 )<BR>{<BR>fprintf(stderr,&quot;impossible
de mapper %s &quot;,argv[2]);<BR>exit(-8);<BR>}<BR>memcpy(dst,src,statbuf.st_size);
/* copie */<BR><BR>exit(0);<BR><BR>}<BR><BR></FONT></TT><BR><BR><FONT SIZE=5>Programme
tr&egrave;s rapide, il pourrait &ecirc;tre encore am&eacute;lior&eacute;
si la fonction </FONT><TT><FONT SIZE=5>madvice</FONT></TT><FONT SIZE=5>
fonctionnait ce commentaire n'est plus vrai sur la version 10.* de
HPUX.<BR>Attention, quand vous utilisez </FONT><TT><FONT SIZE=5>mmap</FONT></TT><FONT SIZE=5>
les adresses m&eacute;moire dans la zone mapp&eacute;e ne sont pas
n&eacute;cessairement bien align&eacute;es, il faut faire .<!--TOC chapter <FONT SIZE=5>Tubes et Tubes Nommés</FONT>--></FONT></P>
<H1><FONT SIZE=5>Chapitre&nbsp;11&nbsp;&nbsp; Tubes et Tubes Nomm&eacute;s</FONT></H1>
<P><!--SEC END --><FONT SIZE=5>tubes Les tubes sont un m&eacute;canisme
de communication qui permet de r&eacute;aliser des communications
entre processus sous forme d'un flot continu d'octets. Les tubes sont
un des &eacute;l&eacute;ments de l'agr&eacute;ment d'utilisation
d'UNIX. C'est ce m&eacute;canisme qui permet l'approche filtre de la
conception sous UNIX.<BR><BR>M&eacute;canisme de communication li&eacute;
au syst&egrave;me de gestion de fichier, les tubes nomm&eacute;s ou
non sont des paires d'entr&eacute;es de la table des fichiers
ouverts, associ&eacute;es &agrave; une inode en m&eacute;moire g&eacute;r&eacute;e
par un driver sp&eacute;cifique. Une entr&eacute;e est utilis&eacute;e
par les processus qui &eacute;crivent dans le tube, une entr&eacute;e
pour les lecteurs du tube. <BR><B>L'op&eacute;ration de lecture y est
destructive&nbsp;!<BR>L'ordre des caract&egrave;res en entr&eacute;e
est conserv&eacute; en sortie (premier entr&eacute; premier
sortie).<BR>Un tube a une capacit&eacute; finie&nbsp;: en g&eacute;n&eacute;ral
le nombre d'adresses directes des inodes du SGF (ce qui peut varier
de 5 &agrave; 80 Ko).<!--TOC section <FONT SIZE=5>Les tubes ordinaires (</FONT><FONT SIZE=5><EM>pipe</EM></FONT><FONT SIZE=5>)</FONT>-->
</B></FONT>
</P>
<H2>11.1&nbsp;&nbsp; Les tubes ordinaires (<EM>pipe</EM>)</H2>
<P><FONT SIZE=5><!--SEC END -->Un tube est mat&eacute;rialis&eacute;
par deux entr&eacute;es de la table des ouvertures de fichiers, une
de ces entr&eacute;es est ouverte en &eacute;criture (l'entr&eacute;e
du tube), l'autre en lecture (la sortie du tube). Ces deux entr&eacute;es
de la table des fichiers ouverts nous donnent le nombre de
descripteurs qui pointent sur elles. Ces valeurs peuvent &ecirc;tre
traduites comme&nbsp;: </FONT>
</P>
<DL>
	<DT><FONT SIZE=5>nombre de lecteurs</FONT></DT><DD>
	<FONT SIZE=5>= nombre de descripteurs associ&eacute;s &agrave;
	l'entr&eacute;e ouverte en lecture.</FONT><EM><FONT SIZE=5>On ne
	peut pas &eacute;crire dans un tube sans lecteur</FONT></EM><FONT SIZE=5>.
	</FONT>
	</DD><DT>
	<FONT SIZE=5>nombre d'&eacute;crivains</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>= nombre de descripteurs associ&eacute;s &agrave;
	l'entr&eacute;e ouverte en &eacute;criture. La nullit&eacute; de ce
	nombre d&eacute;finit le comportement de la primitive </FONT><TT><FONT SIZE=5>read</FONT></TT><FONT SIZE=5>
	lorsque le tube est vide. </FONT>
	</DD></DL>
<H2>
<FONT SIZE=5><!--TOC section <FONT SIZE=5>Création de tubes ordinaires</FONT>-->11.2&nbsp;&nbsp;
Cr&eacute;ation de tubes ordinaires</FONT></H2>
<P><!--SEC END --><FONT SIZE=5>Un processus ne peut utiliser que les
tubes qu'il a cr&eacute;&eacute;s lui-m&ecirc;me par la primitive
</FONT><TT><FONT SIZE=5>pipe</FONT></TT><FONT SIZE=5> ou qu'il a
h&eacute;rit&eacute;s de son p&egrave;re gr&acirc;ce &agrave;
l'h&eacute;ritage des descripteurs &agrave; travers </FONT><TT><FONT SIZE=5>fork</FONT></TT><FONT SIZE=5>
et </FONT><TT><FONT SIZE=5>exec</FONT></TT><FONT SIZE=5>.</FONT></P>
<PRE>
<FONT SIZE=5>#include &lt;unistd.h&gt;</FONT>
<FONT SIZE=5>int pipe(int  p[2]);</FONT></PRE><P>
<FONT SIZE=5>appels syst&egrave;mes!pipe@</FONT><TT><FONT SIZE=5>pipe</FONT></TT><FONT SIZE=5>
</FONT>
</P>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML059.gif" NAME="Image61" ALIGN=BOTTOM WIDTH=316 HEIGHT=181 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
11.1&nbsp;: Ouverture d'un tube</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="tube1"></A><BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<P><FONT SIZE=5>On ne peut pas manipuler les descripteurs de tubes
avec les fonctions et primitives&nbsp;: </FONT><TT><FONT SIZE=5>lseek,
ioctl, tcsetattr</FONT></TT><FONT SIZE=5> et </FONT><TT><FONT SIZE=5>tcgetattr</FONT></TT><FONT SIZE=5>,
comme il n'y a pas de p&eacute;riph&eacute;rique associ&eacute; au
tube (tout est fait en m&eacute;moire).<BR>H&eacute;ritage d'un tube
dans la figure </FONT><A HREF="#tube2"><FONT SIZE=5>11.2</FONT></A><FONT SIZE=5>
&nbsp;: le processus B h&eacute;rite des descripteurs ouverts par son
p&egrave;re A et donc, ici, du tube.</FONT></P>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML060.gif" NAME="Image62" ALIGN=BOTTOM WIDTH=319 HEIGHT=184 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
11.2&nbsp;: H&eacute;ritage d'un tube</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="tube2"></A><BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<P><FONT SIZE=5>Dans la Figure </FONT><A HREF="#tube3"><FONT SIZE=5>11.3</FONT></A><FONT SIZE=5>,
les descripteurs associ&eacute;s aux tubes sont plac&eacute;s comme
descripteurs 0 et 1 des processus A et B, c'est &agrave; dire la
sortie de A et l'entr&eacute;e de B. Les autres descripteurs sont
ferm&eacute;s pour assurer l'unicit&eacute; du nombre de lecteurs et
d'&eacute;crivains dans le tube.</FONT></P>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML061.gif" NAME="Image63" ALIGN=BOTTOM WIDTH=319 HEIGHT=216 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
11.3&nbsp;: Redirection de la sortie standard de A dans le tube et de
l'entr&eacute;e standard de B dans le tube, et fermeture des
descripteurs inutiles</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="tube3"></A><BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<H2><FONT SIZE=5><!--TOC section <FONT SIZE=5>Lecture dans un tube</FONT>-->11.3&nbsp;&nbsp;
Lecture dans un tube</FONT></H2>
<P><!--SEC END --><FONT SIZE=5>On utilise l'appel syst&egrave;me
</FONT><TT><FONT SIZE=5>read</FONT></TT><FONT SIZE=5>. </FONT>
</P>
<PRE>
<FONT SIZE=5>int nb_lu;</FONT>
<FONT SIZE=5>nb_lu = read(p[0], buffer, TAILLE_READ);</FONT></PRE><P STYLE="margin-bottom: 0cm">
<FONT SIZE=5>appels syst&egrave;mes!read@</FONT><TT><FONT SIZE=5>read</FONT></TT><FONT SIZE=5>
Remarquer que la lecture se fait dans le descripteur
p[0].<BR>Comportement de l'appel&nbsp;: </FONT>
</P>
<TABLE CELLPADDING=0 CELLSPACING=2>
	<TR>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>Si le tube n'est <B>pas vide</B> et
			contient <B>taille</B> caract&egrave;res&nbsp;:</FONT></P>
		</TD>
		<TD VALIGN=TOP></TD>
		<TD VALIGN=TOP></TD>
		<TD VALIGN=TOP></TD>
	</TR>
	<TR>
		<TD></TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>lecture de nb_lu = min(taille,
			TAILLE_READ) caract&egrave;res.</FONT></P>
		</TD>
		<TD VALIGN=TOP></TD>
		<TD VALIGN=TOP></TD>
	</TR>
	<TR>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>Si le tube est <B>vide</B></FONT></P>
		</TD>
		<TD VALIGN=TOP></TD>
		<TD VALIGN=TOP></TD>
		<TD VALIGN=TOP></TD>
	</TR>
	<TR>
		<TD></TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>Si le nombre d'&eacute;crivains est </FONT><EM><FONT SIZE=5>nul</FONT></EM></P>
		</TD>
		<TD VALIGN=TOP></TD>
		<TD VALIGN=TOP></TD>
	</TR>
	<TR>
		<TD></TD>
		<TD></TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>alors c'est la fin de fichier et nb_lu
			est nul.</FONT></P>
		</TD>
		<TD VALIGN=TOP></TD>
	</TR>
	<TR>
		<TD></TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>Si le nombre d'&eacute;crivains est </FONT><EM><FONT SIZE=5>non
			nul</FONT></EM></P>
		</TD>
		<TD VALIGN=TOP></TD>
		<TD VALIGN=TOP></TD>
	</TR>
	<TR>
		<TD></TD>
		<TD></TD>
		<TD></TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>Si lecture bloquante alors sommeil</FONT></P>
		</TD>
	</TR>
	<TR>
		<TD></TD>
		<TD></TD>
		<TD></TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>Si lecture non bloquante alors en
			fonction de l'indicateur</FONT></P>
		</TD>
	</TR>
	<TR>
		<TD></TD>
		<TD></TD>
		<TD></TD>
		<TD>
			<P ALIGN=LEFT><TT><FONT SIZE=5>O_NONBLOCK</FONT></TT><FONT SIZE=5>
			nb_lu= -1 et errno=EAGAIN.</FONT></P>
		</TD>
	</TR>
	<TR>
		<TD></TD>
		<TD></TD>
		<TD></TD>
		<TD>
			<P ALIGN=LEFT><TT><FONT SIZE=5>O_NDELAY</FONT></TT><FONT SIZE=5>
			nb_lu = 0. </FONT>
			</P>
		</TD>
	</TR>
</TABLE>
<P><!--TOC section <FONT SIZE=5>Ecriture dans un tube</FONT>--><BR><BR>
</P>
<H2><FONT SIZE=5>11.4&nbsp;&nbsp; Ecriture dans un tube</FONT></H2>
<PRE><!--SEC END -->
<FONT SIZE=5>nb_ecrit = write(p[1], buf, n);</FONT></PRE><P>
<FONT SIZE=5>appels syst&egrave;mes!write@</FONT><TT><FONT SIZE=5>write</FONT></TT><FONT SIZE=5>
L'&eacute;criture est atomique si le nombre de caract&egrave;res &agrave;
&eacute;crire est inf&eacute;rieur &agrave; PIPE_BUF, la taille du
tube sur le syst&egrave;me. (cf </FONT><TT><CODE><FONT SIZE=5>&lt;limits.h&gt;</FONT></CODE></TT><FONT SIZE=5>).</FONT></P>
<TABLE CELLPADDING=0 CELLSPACING=2>
	<TR>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>Si le nombre de lecteurs est nul</FONT></P>
		</TD>
		<TD VALIGN=TOP></TD>
		<TD VALIGN=TOP></TD>
		<TD VALIGN=TOP></TD>
	</TR>
	<TR>
		<TD></TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>envoi du signal SIGPIPE &agrave;
			l'&eacute;crivain.</FONT></P>
		</TD>
		<TD VALIGN=TOP></TD>
		<TD VALIGN=TOP></TD>
	</TR>
	<TR>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>Sinon</FONT></P>
		</TD>
		<TD VALIGN=TOP></TD>
		<TD VALIGN=TOP></TD>
		<TD VALIGN=TOP></TD>
	</TR>
	<TR>
		<TD></TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>Si l'&eacute;criture est bloquante, il
			n'y a retour que quand</FONT></P>
		</TD>
		<TD VALIGN=TOP></TD>
		<TD VALIGN=TOP></TD>
	</TR>
	<TR>
		<TD></TD>
		<TD></TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>les n caract&egrave;res ont &eacute;t&eacute;
			&eacute;crits dans le tube.</FONT></P>
		</TD>
		<TD VALIGN=TOP></TD>
	</TR>
	<TR>
		<TD></TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>Si &eacute;criture non bloquante</FONT></P>
		</TD>
		<TD VALIGN=TOP></TD>
		<TD VALIGN=TOP></TD>
	</TR>
	<TR>
		<TD></TD>
		<TD></TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>Si n &gt; PIPE_BUF, retour avec un
			nombre inf&eacute;rieur &agrave; n</FONT></P>
		</TD>
		<TD VALIGN=TOP></TD>
	</TR>
	<TR>
		<TD></TD>
		<TD></TD>
		<TD></TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>&eacute;ventuellement -1 !</FONT></P>
		</TD>
	</TR>
	<TR>
		<TD></TD>
		<TD></TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>Si n <FONT FACE="symbol">&pound;</FONT>
			PIPE_BUF</FONT></P>
		</TD>
		<TD VALIGN=TOP></TD>
	</TR>
	<TR>
		<TD></TD>
		<TD></TD>
		<TD></TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>et si n emplacements libres, &eacute;criture
			nb_ecrit = n</FONT></P>
		</TD>
	</TR>
	<TR>
		<TD></TD>
		<TD></TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>sinon retour -1 ou 0. </FONT>
			</P>
		</TD>
		<TD VALIGN=TOP></TD>
	</TR>
</TABLE>
<P><!--TOC section <FONT SIZE=5>Interblocage avec des tubes</FONT>--><BR><BR>
</P>
<H2><FONT SIZE=5>11.5&nbsp;&nbsp; Interblocage avec des tubes</FONT></H2>
<P><!--SEC END --><FONT SIZE=5>Un m&ecirc;me processus a deux acc&egrave;s
&agrave; un tube, un acc&egrave;s en lecture, un acc&egrave;s en
&eacute;criture et essaie de lire sur le tube vide en mode bloquant
<FONT FACE="symbol">&frac34;&reg;</FONT> le processus est bloqu&eacute;
ind&eacute;finiment dans la primitive </FONT><TT><FONT SIZE=5>read</FONT></TT><FONT SIZE=5>.<BR>Avec
deux processus&nbsp;:<BR>deux tubes entre les deux processus, tous
les deux bloqu&eacute;s en lecture ou tous les deux bloqu&eacute;s en
&eacute;criture, tous les deux en attente d'une action de l'autre
processus.<!--TOC section <FONT SIZE=5>Les tubes nommés</FONT>--></FONT></P>
<H2><FONT SIZE=5>11.6&nbsp;&nbsp; Les tubes nomm&eacute;s</FONT></H2>
<P><!--SEC END --><FONT SIZE=5>fifotubes nomm&eacute;s Les tube
nomm&eacute;s sont des tubes (</FONT><TT><FONT SIZE=5>pipe</FONT></TT><FONT SIZE=5>)
qui existent dans le syst&egrave;me de fichiers, et donc peuvent &ecirc;tre
ouverts gr&acirc;ce &agrave; une r&eacute;f&eacute;rence.<BR>Il faut
pr&eacute;alablement cr&eacute;er le tube nomm&eacute; dans le
syst&egrave;me de fichiers, gr&acirc;ce &agrave; la primitive </FONT><TT><FONT SIZE=5>mknod</FONT></TT><FONT SIZE=5>
(</FONT><TT><FONT SIZE=5>mkfifo</FONT></TT><FONT SIZE=5>), avant de
pouvoir l'ouvrir avec la primitive </FONT><TT><FONT SIZE=5>open</FONT></TT><FONT SIZE=5>.</FONT></P>
<PRE>
<FONT SIZE=5>int mknod(reference, mode | S_IFIFO,0);</FONT></PRE><P>
<FONT SIZE=5>mkfifo appels syst&egrave;mes!mknod@</FONT><TT><FONT SIZE=5>mknod</FONT></TT><FONT SIZE=5>
</FONT><TT><FONT SIZE=5>mode</FONT></TT><FONT SIZE=5> est construit
comme le param&egrave;tre de mode de la fonction </FONT><TT><FONT SIZE=5>open</FONT></TT><FONT SIZE=5>.<BR>En
POSIX, un appel simplifi&eacute; &nbsp;: </FONT>
</P>
<PRE>
<FONT SIZE=5>#include &lt;sys/types.h&gt;</FONT>
<FONT SIZE=5>#include &lt;sys/stat.h&gt;</FONT>
<FONT SIZE=5>int mkfifo(const char *ref, mode_t mode);</FONT></PRE><P>
<FONT SIZE=5>appels syst&egrave;mes!mkfifo@</FONT><TT><FONT SIZE=5>mkfifo</FONT></TT><FONT SIZE=5>
<BR><BR>On peut cr&eacute;er des FIFOs &agrave; partir du shell gr&acirc;ce
&agrave; </FONT>
</P>
<PRE>
<FONT SIZE=5>mkfifo [-p] [-m mode] ref ... </FONT></PRE><P>
<FONT SIZE=5>L'ouverture d'un tube nomm&eacute; se fait exclusivement
soit en mode O_RDONLY soit en mode O_WRONLY, ainsi le nombre de
lecteur et d'&eacute;crivain peut &ecirc;tre comptabilis&eacute;.<!--TOC subsection <FONT SIZE=5>Ouverture et synchronisation des ouvertures de tubes nommés</FONT>--></FONT></P>
<H3><FONT SIZE=5>11.6.1&nbsp;&nbsp; Ouverture et synchronisation des
ouvertures de tubes nomm&eacute;s</FONT></H3>
<P><!--SEC END --><FONT SIZE=5>synchronisation <B>Il y a
automatiquement synchronisation des processus qui ouvrent en mode
bloquant un tube nomm&eacute;.</B><BR>L'op&eacute;ration d'ouverture
sur un tube nomm&eacute; est bloquante en lecture.<BR>Le processus
attend qu'un autre processus ouvre la fifo en &eacute;criture.<BR>L'ouverture
en &eacute;criture est aussi bloquante, avec attente qu'un autre
processus ouvre la fifo en lecture. L'ouverture bloquante se termine
de fa&ccedil;ons synchrone pour les deux processus.<BR>Ainsi un
unique processus ne peut ouvrire &agrave; la fois en lecture et
&eacute;criture un tube nomm&eacute;.<BR>En mode non bloquant
(O_NONBLOCK, O_NDELAY), seule l'ouverture en lecture r&eacute;ussit
dans tous les cas. L'ouverture en &eacute;criture en mode non
bloquant d'un tube nomm&eacute; ne fonctionne que si un autre
processus a d&eacute;j&agrave; ouvert en mode non bloquant le tube en
lecture, ou bien qu'il est bloqu&eacute; dans l'appel d'une ouverture
en lecture en mode bloquant. Ceci pour &eacute;viter que le processus
qui vient d'ouvrir le tube nomm&eacute;, n'&eacute;crive dans le tube
avant qu'il n'y ait de lecteur (qu'un processus ait ouvert le tube en
lecture) et ce qui engendrerait un signal SIGPIPE (tube d&eacute;truit),
ce qui n'est pas vrai car le tube n'a pas encore &eacute;t&eacute;
utilis&eacute;.<!--TOC subsection <FONT SIZE=5>Suppression d'un tube nommé </FONT>--></FONT></P>
<H3><FONT SIZE=5>11.6.2&nbsp;&nbsp; Suppression d'un tube nomm&eacute;
</FONT>
</H3>
<P><!--SEC END --><FONT SIZE=5>L'utilisation de </FONT><TT><FONT SIZE=5>rm</FONT></TT><FONT SIZE=5>
ou </FONT><TT><FONT SIZE=5>unlink</FONT></TT><FONT SIZE=5> ne fait
que d&eacute;truire la r&eacute;f&eacute;rence, le tube n'est
r&eacute;ellement d&eacute;truit que lorsque son compteur de liens
internes et externes est nul.<BR>Une fois que tous les liens par
r&eacute;f&eacute;rence sont d&eacute;truits, le tube nomm&eacute;
devient un tube ordinaire. <!--TOC subsection <FONT SIZE=5> les appels popen et pclose </FONT>--></FONT></P>
<H3><FONT SIZE=5>11.6.3&nbsp;&nbsp; les appels popen et pclose </FONT>
</H3>
<P><FONT SIZE=5><!--SEC END -->Une interface plus facile pour lancer
un coprocessus est propos&eacute; avec les primitives popen et
pclose.<!--TOC chapter <FONT SIZE=5>La gestion des terminaux</FONT>--></FONT></P>
<H1><FONT SIZE=5>Chapitre&nbsp;12&nbsp;&nbsp; La gestion des
terminaux</FONT></H1>
<P><A NAME="terminaux"></A><FONT SIZE=5><!--SEC END -->Les terminaux
ont un r&ocirc;le fondamental puisqu'ils permettent l'interaction
entre les utilisateurs et les applications. Vis-&agrave;-vis des
processus dits interactifs, les terminaux ont une double fonction&nbsp;:
</FONT>
</P>
<DL>
	<DT><FONT SIZE=5>fonction de &quot;fichier&quot;</FONT></DT><DD>
	<FONT SIZE=5>sur lequel il est possible de lire ou d'&eacute;crire. </FONT>
	</DD><DT>
	<FONT SIZE=5>fonction de contr&ocirc;le</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>&nbsp;: la possibilit&eacute; de faire parvenir des
	signaux &agrave; un ensemble particulier de processus connect&eacute;s.
	</FONT>
	</DD></DL>
<P>
<FONT SIZE=5>Un terminal correspond &agrave; l'un de ces types &nbsp;:
</FONT>
</P>
<DL>
	<DT><FONT SIZE=5>terminal physique</FONT></DT><DD>
	<FONT SIZE=5>, connect&eacute; &agrave; un port de communication de
	la machine (port s&eacute;rie, port parall&egrave;le). On compte
	dans les terminaux physiques les imprimantes mais pas les Terminaux
	X ! physique </FONT>
	</DD><DT>
	<FONT SIZE=5>pseudo-terminal</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>, par exemple une fen&ecirc;tre de terminal X ou une
	connection ETHERNET avec un autre site UNIX, une connections modem
	etc. </FONT>
	</DD></DL>
<P>
<FONT SIZE=5>pseudo-terminaux</FONT><BR><BR><FONT SIZE=5>Dans tous
les cas on trouvera une repr&eacute;sentation sous forme de fichier
sp&eacute;cial en mode caract&egrave;re dans le r&eacute;pertoire
/dev. En standard un fichier de terminal s'appelle /dev/tty</FONT><EM><FONT SIZE=5>xy</FONT></EM><FONT SIZE=5>.
On trouvera aussi sur fillmore des fichiers de pseudo terminaux dans
/dev/pty/tty</FONT><EM><FONT SIZE=5>xy</FONT></EM><FONT SIZE=5>.<BR>Le
param&eacute;trage des terminaux et de la ligne de communication est
diff&eacute;rent sous BSD et SYSTEM V.<BR>La norme POSIX est bas&eacute;e
sur SYSTEM V.<!--TOC section <FONT SIZE=5>Acquisition d'un descripteur associé à un terminal</FONT>--></FONT></P>
<H2><FONT SIZE=5>12.1&nbsp;&nbsp; Acquisition d'un descripteur
associ&eacute; &agrave; un terminal</FONT></H2>
<P><!--SEC END --><FONT SIZE=5>En standard, l'acquisition d'un
descripteur de terminal se fait par h&eacute;ritage &agrave; la
naissance du processus. On h&eacute;rite en particulier du terminal
de contr&ocirc;le. Pour ouvrir un terminal, on utilise la primitive
</FONT><TT><FONT SIZE=5>open</FONT></TT><FONT SIZE=5> avec une
r&eacute;f&eacute;rence du type /dev/ttyxy, qui est celle d'un
fichier sp&eacute;cial caract&egrave;res correspondant au terminal &agrave;
ouvrir. Dans le cas o&ugrave; l'on cherche &agrave; ouvrir le
terminal de contr&ocirc;le du processus, il faut utiliser la
r&eacute;f&eacute;rence symbolique &quot;</FONT><EM><FONT SIZE=5>/dev/tty</FONT></EM><FONT SIZE=5>&quot;.
Si le terminal n'est pas pr&ecirc;t, la primitive </FONT><TT><FONT SIZE=5>open</FONT></TT><FONT SIZE=5>
est bloquante, on utilisera pour un appel non bloquant l'indicateur
O_NONBLOCK.<!--TOC subsubsection <FONT SIZE=5>Test d'association d'un descripteur avec un terminal</FONT>--></FONT></P>
<H4><FONT SIZE=5>Test d'association d'un descripteur avec un terminal</FONT></H4>
<P><FONT SIZE=5><!--SEC END -->La primitive </FONT>
</P>
<PRE>
<FONT SIZE=5>        #include &lt;unistd.h&gt;</FONT>
<FONT SIZE=5>        int isatty(int desc);</FONT></PRE><P>
<FONT SIZE=5>appels syst&egrave;mes!isatty@</FONT><TT><FONT SIZE=5>isatty</FONT></TT><FONT SIZE=5>
<BR><BR>permet de tester si le descripteur est (1) associ&eacute; ou
non (0) &agrave; un terminal.<BR>La primitive </FONT>
</P>
<PRE>
<FONT SIZE=5>        #include &lt;unistd.h&gt;</FONT>
<FONT SIZE=5>        char *ttyname(int desc);</FONT></PRE><P>
<FONT SIZE=5>appels syst&egrave;mes!ttyname@</FONT><TT><FONT SIZE=5>ttyname</FONT></TT><FONT SIZE=5>
<BR><BR>renvoie, lorsque le descripteur est associ&eacute; &agrave;
un terminal, le nom de celui-ci gr&acirc;ce &agrave; un pointeur en
zone statique. Sinon elle retourne NULL.<BR>Exemple&nbsp;: </FONT>
</P>
<BLOCKQUOTE><TT><FONT SIZE=5>da=open(&quot;/dev/tty&quot;,O_RDWR));<BR>db=open(&quot;/dev/ttyp2&quot;,O_RDWR));<BR>a=ttyname(da);
printf(&quot; %s\t&quot;,a);<BR>b=ttyname(db);printf(&quot; %s\t&quot;,b);
printf(&quot; %s \n&quot;,a);</FONT></TT></BLOCKQUOTE>
<P><FONT SIZE=5>nous donne&nbsp;: </FONT>
</P>
<PRE STYLE="margin-left: 1cm; margin-right: 1cm">
<FONT SIZE=5> /dev/tty    /dev/ttyp2   /dev/ttyp2 </FONT></PRE><BLOCKQUOTE>
<FONT SIZE=5>static </FONT>
</BLOCKQUOTE>
<H2><FONT SIZE=5><!--TOC section <FONT SIZE=5>Terminal de contrôle - Sessions - Groupes de processus</FONT>-->12.2&nbsp;&nbsp;
Terminal de contr&ocirc;le - Sessions - Groupes de processus</FONT></H2>
<P><!--SEC END --><FONT SIZE=5>L'ensemble des processus existant dans
le syst&egrave;me &agrave; un moment donn&eacute; est partitionn&eacute;
en sessions&nbsp;: tout processus appartient &agrave; une seule et
unique session, on h&eacute;rite de la session du processus p&egrave;re.<BR>Un
processus qui n'est pas </FONT><EM><FONT SIZE=5>leader</FONT></EM><FONT SIZE=5>
de groupe peut cr&eacute;er une nouvelle session avec la primitive </FONT>
</P>
<PRE>
<FONT SIZE=5>        #include &lt;unistd.h&gt;</FONT>
<FONT SIZE=5>        pid_t setsid(void);</FONT></PRE><P>
<FONT SIZE=5>appels syst&egrave;mes!setsid@</FONT><TT><FONT SIZE=5>setsid</FONT></TT><FONT SIZE=5>
Lors du login, le processus shell cr&eacute;&eacute; est le </FONT><EM><FONT SIZE=5>leader</FONT></EM><FONT SIZE=5>
d'une nouvelle session. Une tel session est caract&eacute;ris&eacute;e
par le terminal de l'utilisateur (sur lequel il se loge) qui devient
le <B>terminal de contr&ocirc;le</B> de la session. Tous les
processus de la session sont inform&eacute;s de la frappe des
caract&egrave;res de contr&ocirc;le sur le terminal </FONT>
</P>
<PRE>
<FONT SIZE=5>intr, quit, susp.</FONT></PRE><P>
<FONT SIZE=5>intrquitsusp /dev/tty Le terminal de contr&ocirc;le est
symbolis&eacute; par la r&eacute;f&eacute;rence &quot;</FONT><TT><FONT SIZE=5>/dev/tty</FONT></TT><FONT SIZE=5>&quot;.<BR>Lorsque
le </FONT><EM><FONT SIZE=5>leader</FONT></EM><FONT SIZE=5> d'une
session attach&eacute;e &agrave; un terminal se <B>termine</B> tous
les processus de la session re&ccedil;oivent le signal SIGHUP et sont
alors interrompus (on r&eacute;alise sur fillmore une fin de session
en tuant la fen&ecirc;tre console, ce qui termine le processus shell
leader ...) sauf si un handler a &eacute;t&eacute; positionn&eacute;
pour le signal SIGHUP. SIGHUP On peut r&eacute;aliser ceci en sh avec
la commande </FONT><TT><FONT SIZE=5>nohup</FONT></TT><FONT SIZE=5>,
ou la commande </FONT><TT><FONT SIZE=5>trap</FONT></TT><FONT SIZE=5>
qui permettent d'ignorer le signal SIGHUP. Le terminal de contr&ocirc;le
et la session d'un tel processus r&eacute;sistant n'est pas norm&eacute;e
dans POSIX. <!--TOC subsection <FONT SIZE=5>Acquisition d'un terminal de contrôle par une session</FONT>--></FONT></P>
<H3><FONT SIZE=5>12.2.1&nbsp;&nbsp; Acquisition d'un terminal de
contr&ocirc;le par une session</FONT></H3>
<P><!--SEC END --><FONT SIZE=5>terminal de contr&ocirc;le <B>A sa
cr&eacute;ation, une session n'a pas de terminal de
contr&ocirc;le!</B><BR>L'acquisition d'un terminal de contr&ocirc;le
n'est pas norm&eacute;e, mais, si l'on ouvre un terminal qui n'est
pas le terminal de contr&ocirc;le d'une autre session avec un
processus </FONT><EM><FONT SIZE=5>leader</FONT></EM><FONT SIZE=5> qui
n'a pas de terminal de contr&ocirc;le, alors le terminal ouvert
devient le terminal de contr&ocirc;le de la session. <BR><BR>Un
terminal peut &ecirc;tre le terminal de contr&ocirc;le d'au plus une
session.<!--TOC subsection <FONT SIZE=5>Groupes de processus</FONT>-->
</FONT>
</P>
<H3><FONT SIZE=5>12.2.2&nbsp;&nbsp; Groupes de processus</FONT></H3>
<P><!--SEC END --><FONT SIZE=5>Les <B>groupes de processus</B> sont
un raffinement POSIX de la notion de session. Ils permettent de
travailler avec des groupes de processus sans toutes les obligations
li&eacute;es aux sessions.<BR><BR>L'objectif est de sp&eacute;cifier
l'ensemble des processus qui sont interactifs sur un terminal donn&eacute;
&agrave; un moment donn&eacute;, et donc qui ont le droit de lire sur
le terminal et de plus sont inform&eacute;s de la frappe des
caract&egrave;res de contr&ocirc;le.<BR><BR>Un </FONT><EM><FONT SIZE=5>groupe
de processus</FONT></EM><FONT SIZE=5> est identifi&eacute; par le PID
du </FONT><EM><FONT SIZE=5>leader</FONT></EM><FONT SIZE=5> du groupe,
&agrave; la naissance, un processus h&eacute;rite du groupe de son
p&egrave;re. La primitive suivante&nbsp;: </FONT>
</P>
<PRE>
<FONT SIZE=5>        #include &lt;unistd.h&gt;</FONT>
<FONT SIZE=5>        pid_t setpgid(pid_t pid, pid_t id_grp);</FONT></PRE><P>
<FONT SIZE=5>appels syst&egrave;mes!setpgid@</FONT><TT><FONT SIZE=5>setpgid</FONT></TT><FONT SIZE=5>
permet de rattacher le processus </FONT><EM><FONT SIZE=5>pid</FONT></EM><FONT SIZE=5>
au groupe </FONT><EM><FONT SIZE=5>id_grp</FONT></EM><FONT SIZE=5>.<BR>Si
</FONT><EM><FONT SIZE=5>pid</FONT></EM><FONT SIZE=5> est nul c'est le
processus courant qui est rattach&eacute;.<BR>Si </FONT><EM><FONT SIZE=5>id_grp</FONT></EM><FONT SIZE=5>
est nul le num&eacute;ro d&eacute;duit de </FONT><EM><FONT SIZE=5>pid</FONT></EM><FONT SIZE=5>
est utilis&eacute;.<BR>Dans tous les cas soit le groupe existe et le
processus est rattach&eacute;, soit le groupe est cr&eacute;&eacute;
et le processus trait&eacute; devient le leader du groupe.<BR>Un
processus ne peut &ecirc;tre rattach&eacute; qu'&agrave; un groupe
appartenant &agrave; la m&ecirc;me session que lui,c'est-&agrave;-dire,
que les groupes sont d&eacute;finis &agrave; l'int&eacute;rieur des
sessions.<BR>La primitive </FONT>
</P>
<PRE>
<FONT SIZE=5>        #include &lt;unistd.h&gt;</FONT>
<FONT SIZE=5>        pid_t getpgrp(void);</FONT></PRE><P>
<FONT SIZE=5>appels syst&egrave;mes!getpgrp@</FONT><TT><FONT SIZE=5>getpgrp</FONT></TT><FONT SIZE=5>
renvoie le num&eacute;ro du </FONT><EM><FONT SIZE=5>leader</FONT></EM><FONT SIZE=5>
du groupe du processus courant.<BR>Sur certaines machines, la
primitive </FONT>
</P>
<PRE>
<FONT SIZE=5>        #include &lt;unistd.h&gt;</FONT>
<FONT SIZE=5>        pid_t getgrp2(pid_t pid);</FONT></PRE><P>
<FONT SIZE=5>appels syst&egrave;mes!getgrp2@</FONT><TT><FONT SIZE=5>getgrp2</FONT></TT><FONT SIZE=5>
renvoie le num&eacute;ro du groupe du processus </FONT><EM><FONT SIZE=5>pid</FONT></EM><FONT SIZE=5>.<!--TOC subsection <FONT SIZE=5>Premier Plan et Arrière Plan</FONT>--></FONT></P>
<H3><FONT SIZE=5>12.2.3&nbsp;&nbsp; Premier Plan et Arri&egrave;re
Plan</FONT></H3>
<P><!--SEC END --><FONT SIZE=5>Le <B>premier plan</B> est l'unique
sous-groupe de processus de la session qui est en mode interactif.
Les processus de ce groupe peuvent lire et &eacute;crire sur le
terminal, ce sont les processus qui re&ccedil;oivent les signaux
engendr&eacute;s par les caract&egrave;res de contr&ocirc;le. premier
planarri&egrave;re plan Les groupes en <B>arri&egrave;re plan</B>
sont tous les autres sous-groupes de la session. En csh/ksh ce sont
tous les processus lanc&eacute;s en t&acirc;che de fond (&amp;), que
l'on peut manipuler avec les commandes </FONT><TT><FONT SIZE=5>fg</FONT></TT><FONT SIZE=5>
et </FONT><TT><FONT SIZE=5>bg</FONT></TT><FONT SIZE=5>.<BR><BR>Ces
groupes ne peuvent lire sur le terminal (signaux SIGTTIN et SIGTTOU),
de plus &agrave; la frappe de caract&egrave;re de contr&ocirc;le sur
le terminal ils ne re&ccedil;oivent pas de signaux. <BR><BR>Avant
POSIX les processus lanc&eacute;s en t&acirc;che de fond par le shell
ignoraient les signaux SIGINT et SIGQUIT et avaient leur entr&eacute;e
standard redirig&eacute;e sur le &quot;trou noir&quot;&nbsp;:
/dev/null. /dev/null<!--TOC subsection <FONT SIZE=5>Quelques fonctions</FONT>-->
</FONT>
</P>
<H3><FONT SIZE=5>12.2.4&nbsp;&nbsp; Quelques fonctions</FONT></H3>
<P><FONT SIZE=5><!--SEC END -->Quelques fonctions d'information sur
les sessions et les groupes.<BR>Elles n&eacute;cessite toute
l'include </FONT>
</P>
<PRE>
<FONT SIZE=5>#include &lt;unistd.h&gt;</FONT></PRE><P>
<FONT SIZE=5>La primitive </FONT>
</P>
<PRE>
<FONT SIZE=5>        pid_t tcgetsid(int desc);</FONT></PRE><P>
<FONT SIZE=5>appels syst&egrave;mes!tcgetsid@</FONT><TT><FONT SIZE=5>tcgetsid</FONT></TT><FONT SIZE=5>
renvoie l'identit&eacute; du processus leader.<BR>La primitive
renvoie -1 si le terminal n'est pas terminal de contr&ocirc;le.</FONT></P>
<PRE>
<FONT SIZE=5>        pid_t getsid(pid_t pid);</FONT></PRE><P>
<FONT SIZE=5>appels syst&egrave;mes!getsid@</FONT><TT><FONT SIZE=5>getsid</FONT></TT><FONT SIZE=5>
renvoie l'identit&eacute; du leader de la session du processus </FONT><EM><FONT SIZE=5>pid</FONT></EM><FONT SIZE=5>.
Si </FONT><EM><FONT SIZE=5>pid</FONT></EM><FONT SIZE=5> ==0 c'est le
pid du processus courant qui est utilis&eacute;, un appel &eacute;quivalent
&agrave; </FONT><TT><CODE><FONT SIZE=5>getsid(getpid())</FONT></CODE></TT><FONT SIZE=5>
mais avec un appel syst&egrave;me de moins.<!--TOC paragraph <FONT SIZE=5>Changement du groupe en premier plan</FONT>--></FONT></P>
<H5><FONT SIZE=5>Changement du groupe en premier plan</FONT></H5>
<P><FONT SIZE=5><!--SEC END -->La primitive </FONT>
</P>
<PRE>
<FONT SIZE=5>        pid_t  tcgetgrp(int desc);</FONT></PRE><P>
<FONT SIZE=5>appels syst&egrave;mes!tcgetgrp@</FONT><TT><FONT SIZE=5>tcgetgrp</FONT></TT><FONT SIZE=5>
renvoie le groupe de processus en premier plan associ&eacute; au
terminal de contr&ocirc;le indiqu&eacute; par le descripteur
</FONT><EM><FONT SIZE=5>desc</FONT></EM><FONT SIZE=5>.<BR>Ceci
s'applique &eacute;videment uniquement au terminal de contr&ocirc;le
de la session du processus courant.<BR>La primitive </FONT>
</P>
<PRE>
<FONT SIZE=5>pid_t tcsetpgrp(int desc, pid_t id_grp);</FONT></PRE><P>
<FONT SIZE=5>appels syst&egrave;mes!tcsetpgrp@</FONT><TT><FONT SIZE=5>tcsetpgrp</FONT></TT><FONT SIZE=5>
permet de placer en premier plan le groupe </FONT><EM><FONT SIZE=5>id_grp</FONT></EM><FONT SIZE=5>
dans la session associ&eacute;e au terminal point&eacute; par </FONT><EM><FONT SIZE=5>desc</FONT></EM><FONT SIZE=5>.<!--TOC section <FONT SIZE=5>Les drivers logiciels de terminaux</FONT>--></FONT></P>
<H2><FONT SIZE=5>12.3&nbsp;&nbsp; Les drivers logiciels de terminaux</FONT></H2>
<P><!--SEC END --><FONT SIZE=5>Les terminaux physiques sont manipul&eacute;s
par des drivers sp&eacute;cifiques pour chaque terminal(en fonction
du mod&egrave;le, de la marque, de l'age, etc ...). Sur cet ensemble
de drivers, on trouve une super-structure logicielle, les <B>tty
driver</B>, drivers logiciels de terminaux. Ces drivers permettent de
travailler sur l'ensemble des terminaux de fa&ccedil;on homog&egrave;ne
et transparente (polymorphisme).<BR>Structure de description du mode
de communication &nbsp;: la structure termios.</FONT></P>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML062.gif" NAME="Image64" ALIGN=BOTTOM WIDTH=320 HEIGHT=112 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
12.1&nbsp;: Structure de la communication entre le processus et le
terminal.</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="terminaux1"></A><BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<H3><!--TOC subsection <FONT SIZE=5>La structure </FONT><FONT SIZE=5><TT>termios</TT></FONT>--><FONT SIZE=5>12.3.1&nbsp;&nbsp;
La structure </FONT><TT><FONT SIZE=5>termios</FONT></TT></H3>
<P><!--SEC END --><FONT SIZE=5>En POSIX, toutes les caract&eacute;ristiques
d'une voie de communication sont rassembl&eacute;es dans la structure
termios pr&eacute;d&eacute;finie dans le fichier </FONT><TT><CODE><FONT SIZE=5>&lt;termios.h&gt;</FONT></CODE></TT><FONT SIZE=5>.<BR>termios
Sur un HP/UX &nbsp;: </FONT>
</P>
<PRE>
<FONT SIZE=5>/* machine: fillmore */</FONT>

<FONT SIZE=5>#define NCCS 16</FONT>

<FONT SIZE=5>   typedef unsigned int tcflag_t;</FONT>
<FONT SIZE=5>   typedef unsigned char cc_t;</FONT>

<FONT SIZE=5>     struct termios {</FONT>
<FONT SIZE=5>        tcflag_t        c_iflag;        /* Input modes */</FONT>
<FONT SIZE=5>        tcflag_t        c_oflag;        /* Output modes */</FONT>
<FONT SIZE=5>        tcflag_t        c_cflag;        /* Control modes */</FONT>
<FONT SIZE=5>        tcflag_t        c_lflag;        /* Local modes */</FONT>
<FONT SIZE=5>        tcflag_t        c_reserved;     /* Reserved for future use */</FONT>
<FONT SIZE=5>        cc_t            c_cc[NCCS];     /* Control characters */</FONT>
<FONT SIZE=5>     };</FONT></PRE><P>
<FONT SIZE=5>Le type tcflag_t est consid&eacute;r&eacute; comme un
tableau de bits. On peut donc tester le positionnement d'un
indicateur par un &amp; (conjonction binaire) avec sa
macro-d&eacute;finition.<BR>Par exemple:<BR></FONT><TT><CODE><FONT SIZE=5>(c_iflag
&amp; IXOFF )</FONT></CODE></TT><FONT SIZE=5> est vrai si le drapeau
est positionn&eacute;.<!--TOC subsection <FONT SIZE=5>Modes d'entrée</FONT>--></FONT></P>
<H3><FONT SIZE=5>12.3.2&nbsp;&nbsp; Modes d'entr&eacute;e</FONT></H3>
<P><FONT SIZE=5><!--SEC END -->Macro-d&eacute;finitions des drapeaux
du mode d'entr&eacute;e &nbsp;: </FONT>
</P>
<DL>
	<DT><FONT SIZE=5>IGNBRK</FONT></DT><DD>
	<FONT SIZE=5>Ignorer &lt;break&gt; </FONT>
	</DD><DT>
	<FONT SIZE=5>BRKINT</FONT></DT><DD>
	<FONT SIZE=5>Signal SIGINT &agrave; la frappe de &lt;break&gt; </FONT>
	</DD><DT>
	<FONT SIZE=5>IGNPAR</FONT></DT><DD>
	<FONT SIZE=5>Ignorer les erreurs de parit&eacute; </FONT>
	</DD><DT>
	<FONT SIZE=5>PARMRK</FONT></DT><DD>
	<FONT SIZE=5>Marquer les erreurs de parit&eacute; </FONT>
	</DD><DT>
	<FONT SIZE=5>INPCK</FONT></DT><DD>
	<FONT SIZE=5>V&eacute;rification de parit&eacute; </FONT>
	</DD><DT>
	<FONT SIZE=5>ISTRIP</FONT></DT><DD>
	<FONT SIZE=5>Strip character&nbsp;: compacter sur 7 bits </FONT>
	</DD><DT>
	<FONT SIZE=5>INLCR</FONT></DT><DD>
	<FONT SIZE=5>Transformer NL en CR </FONT>
	</DD><DT>
	<FONT SIZE=5>IGNCR</FONT></DT><DD>
	<FONT SIZE=5>Ignorer CR </FONT>
	</DD><DT>
	<FONT SIZE=5>ICRNL</FONT></DT><DD>
	<FONT SIZE=5>Transformer CR en NL </FONT>
	</DD><DT>
	<FONT SIZE=5>_IUCLC</FONT></DT><DD>
	<FONT SIZE=5>Transformer Majuscules en minuscules </FONT>
	</DD><DT>
	<FONT SIZE=5>IXON</FONT></DT><DD>
	<FONT SIZE=5>Autoriser l'arr&ecirc;t du flux avec (Ctrl-S/Ctrl-Q) </FONT>
	</DD><DT>
	<FONT SIZE=5>_IXANY</FONT></DT><DD>
	<FONT SIZE=5>N'importe quel caract&egrave;re relance le flux. </FONT>
	</DD><DT>
	<FONT SIZE=5>IXOFF</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>Interdit l'arr&ecirc;t du flux. </FONT>
	</DD></DL>
<H3>
<FONT SIZE=5><!--TOC subsection <FONT SIZE=5>Modes de sortie</FONT>-->12.3.3&nbsp;&nbsp;
Modes de sortie</FONT></H3>
<P><FONT SIZE=5><!--SEC END -->Macro-d&eacute;finitions des drapeaux
du mode de sortie &nbsp;: </FONT>
</P>
<DL>
	<DT><FONT SIZE=5>OPOST</FONT></DT><DD>
	<FONT SIZE=5>Postprocessing de la sortie. </FONT>
	</DD><DT>
	<FONT SIZE=5>OLCUC</FONT></DT><DD>
	<FONT SIZE=5>Transformer minuscule en MAJUSCULE en sortie. </FONT>
	</DD><DT>
	<FONT SIZE=5>ONLCR</FONT></DT><DD>
	<FONT SIZE=5>NL en CR+NL. </FONT>
	</DD><DT>
	<FONT SIZE=5>OCRNL</FONT></DT><DD>
	<FONT SIZE=5>CR en NL . </FONT>
	</DD><DT>
	<FONT SIZE=5>ONOCR</FONT></DT><DD>
	<FONT SIZE=5>No CR en colonne 0. </FONT>
	</DD><DT>
	<FONT SIZE=5>ONLRET</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>NL en NL+CR. </FONT>
	</DD></DL>
<H3>
<FONT SIZE=5><!--TOC subsection <FONT SIZE=5>Modes de contrôle</FONT>-->12.3.4&nbsp;&nbsp;
Modes de contr&ocirc;le</FONT></H3>
<P><FONT SIZE=5><!--SEC END -->Description plus bas niveau de la
ligne de communication. Utilis&eacute;s surtout pour des
p&eacute;riph&eacute;riques de communication (modems). </FONT>
</P>
<DL>
	<DT><FONT SIZE=5>CLOCAL</FONT></DT><DD>
	<FONT SIZE=5>Ouverture non bloquante, sinon l'ouverture est
	bloquante tant que la ligne n'est pas pr&ecirc;te (par exemple un
	modem), sauf demande contraire dans l'appel de </FONT><TT><FONT SIZE=5>open</FONT></TT><FONT SIZE=5>
	avec </FONT><TT><FONT SIZE=5>O_NONBLOCK</FONT></TT><FONT SIZE=5>. </FONT>
	</DD><DT>
	<FONT SIZE=5>HUPCL</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>hangup sur le dernier </FONT><TT><FONT SIZE=5>close</FONT></TT><FONT SIZE=5>.
	</FONT>
	</DD></DL>
<H3>
<FONT SIZE=5><!--TOC subsection <FONT SIZE=5>Modes locaux</FONT>-->12.3.5&nbsp;&nbsp;
Modes locaux</FONT></H3>
<P><!--SEC END --><FONT SIZE=5>Ce sont ces modes-l&agrave; qui ont le
plus d'impact au niveau logiciel. Ce sont eux qui indiquent les
traitements r&eacute;alis&eacute;s sur les caract&egrave;res de
contr&ocirc;le et d&eacute;terminent le comportement de la primitive
</FONT><TT><FONT SIZE=5>read</FONT></TT><FONT SIZE=5>. </FONT>
</P>
<DL>
	<DT><FONT SIZE=5>ISIG</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>les caract&egrave;res de contr&ocirc;le </FONT><TT><FONT SIZE=5>intr,
	quit</FONT></TT><FONT SIZE=5>, etc sont transform&eacute;s en
	signaux.</FONT></DD><DT>
	<FONT SIZE=5>ECHO</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>Les caract&egrave;res frapp&eacute;s au clavier sont
	apr&egrave;s transformation, d&eacute;finie dans le mode d'entr&eacute;e,
	ins&eacute;r&eacute;s dans le flux de sortie (&eacute;cho des
	caract&egrave;res en sh par exemple).</FONT></DD><DT>
	<FONT SIZE=5>ECHOE</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>dans ce mode et en mode ICANON, le caract&egrave;re de
	contr&ocirc;le </FONT><TT><FONT SIZE=5>erase</FONT></TT><FONT SIZE=5>
	a un &eacute;cho provoquant l'effacement du dernier caract&egrave;re
	sur l'&eacute;cran.</FONT></DD><DT>
	<FONT SIZE=5>ECHOK</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>dans ce mode et en mode ICANON, le caract&egrave;re de
	contr&ocirc;le </FONT><TT><FONT SIZE=5>kill</FONT></TT><FONT SIZE=5>
	a comme &eacute;cho le caract&egrave;re de fin de ligne.</FONT></DD><DT>
	<FONT SIZE=5>NOFLSH</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>dans ce mode, il n'y a pas de vidange par d&eacute;faut
	des tampons de lecture et d'&eacute;criture &agrave; la prise en
	compte des caract&egrave;res </FONT><TT><FONT SIZE=5>intr, quit,
	susp</FONT></TT><FONT SIZE=5> en mode ISIG. </FONT>
	</DD><DT>
	<FONT SIZE=5>TOSTOP</FONT></DT><DD>
	<FONT SIZE=5>dans ce mode, les processus du groupe de processus en
	arri&egrave;re-plan du terminal sont suspendus, lorsqu'ils essaient
	d'&eacute;crire sur le terminal, par le signal SIGTTOU. </FONT>
	</DD><DT>
	<FONT SIZE=5>ICANON</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>est un mode complexe, voir plus bas. </FONT>
	</DD></DL>
<H5>
<FONT SIZE=5><!--TOC paragraph <FONT SIZE=5>les modes canoniques et non-canoniques</FONT>-->les
modes canoniques et non-canoniques</FONT></H5>
<P><!--SEC END --><FONT SIZE=5>Le choix de l'option ICANON a un effet
sur la primitive </FONT><TT><FONT SIZE=5>read</FONT></TT><FONT SIZE=5>
en particulier l'accessibilit&eacute; des caract&egrave;res frapp&eacute;s
d&eacute;pend de choix effectu&eacute;s sur ce mode.</FONT></P>
<DL>
	<DT><FONT SIZE=5>Mode canonique</FONT></DT><DD>
	<FONT SIZE=5>: c'est le mode de fonctionnement d'un terminal en mode
	interactif, il se caract&eacute;rise de la mani&egrave;re suivante&nbsp;:
	le tampon d'entr&eacute;e est structur&eacute; en ligne, une ligne
	&eacute;tant une suite de caract&egrave;res termin&eacute;e par le
	caract&egrave;re newline de code ASCII 10 (le newline du C). Ceci
	signifie que les caract&egrave;res lus au cours d'une op&eacute;ration
	de lecture </FONT><TT><FONT SIZE=5>read</FONT></TT><FONT SIZE=5> sur
	le terminal sont extraits dans une et une seule ligne. Donc tout
	caract&egrave;re non suivi d'un newline n'est pas accessible en
	lecture&nbsp;! Une op&eacute;ration de lecture ne peut avoir lieu &agrave;
	cheval sur plusieurs lignes. </FONT>
	</DD><DT>
	<FONT SIZE=5>Mode non-canonique</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>: la structure de ligne ne d&eacute;finit plus le
	crit&egrave;re d'accessibilit&eacute; des caract&egrave;res et les 4
	caract&egrave;res </FONT><TT><FONT SIZE=5>erase, kill, eof, eol</FONT></TT><FONT SIZE=5>
	perdent leur qualit&eacute; de caract&egrave;res de contr&ocirc;le. </FONT>
	</DD></DL>
<P>
<FONT SIZE=5>Les crit&egrave;res d'accessibilit&eacute; en mode
non-canonique sont d&eacute;finis par deux caract&egrave;res sp&eacute;ciaux
</FONT><TT><FONT SIZE=5>MIN</FONT></TT><FONT SIZE=5> et </FONT><TT><FONT SIZE=5>TIME</FONT></TT><FONT SIZE=5>
du tableau </FONT><TT><FONT SIZE=5>c_cc</FONT></TT><FONT SIZE=5> de
la structure </FONT><TT><FONT SIZE=5>termios</FONT></TT><FONT SIZE=5>.<BR>Si
</FONT><TT><FONT SIZE=5>MIN</FONT></TT><FONT SIZE=5> &gt; 0 et </FONT><TT><FONT SIZE=5>TIME</FONT></TT><FONT SIZE=5>
&gt; 0 , </FONT><TT><FONT SIZE=5>TIME</FONT></TT><FONT SIZE=5> est un
minuteur inter-caract&egrave;res de granularit&eacute; 0.1 seconde. </FONT>
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>A chaque caract&egrave;re
	re&ccedil;u le minuteur est repositionn&eacute;. </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Si le nombre de
	caract&egrave;res re&ccedil;u avant l'expiration du minuteur est
	&eacute;gal &agrave; </FONT><TT><FONT SIZE=5>MIN</FONT></TT><FONT SIZE=5>
	l'appel </FONT><TT><FONT SIZE=5>read</FONT></TT><FONT SIZE=5>
	retourne ces caract&egrave;re au processus. </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Si le minuteur expire
	avant la reception de </FONT><TT><FONT SIZE=5>MIN</FONT></TT><FONT SIZE=5>
	caract&egrave;res, l'appel </FONT><TT><FONT SIZE=5>read</FONT></TT><FONT SIZE=5>
	retourne les caract&egrave;res re&ccedil;us au processus. </FONT>
	</P>
	<LI><P><FONT SIZE=5>Remarquer qu'au moins un caract&egrave;re sera
	renvoy&eacute;. Le </FONT><TT><FONT SIZE=5>read</FONT></TT><FONT SIZE=5>
	est bloquant tant que le premier caract&egrave;re n'est pas re&ccedil;u
	et que </FONT><TT><FONT SIZE=5>MIN</FONT></TT><FONT SIZE=5> et </FONT><TT><FONT SIZE=5>TIME</FONT></TT><FONT SIZE=5>
	ne sont pas mis en marche. </FONT>
	</P>
</UL>
<P><FONT SIZE=5>Pour certaines valeurs de </FONT><TT><FONT SIZE=5>MIN</FONT></TT><FONT SIZE=5>
et </FONT><TT><FONT SIZE=5>TIME</FONT></TT><FONT SIZE=5>&nbsp;: </FONT>
</P>
<DL>
	<DT><TT><FONT SIZE=5>MIN</FONT></TT><FONT SIZE=5> &gt; 0, </FONT><TT><FONT SIZE=5>TIME</FONT></TT><FONT SIZE=5>
	= 0</FONT></DT><DD>
	<FONT SIZE=5>M&ecirc;me comportement mais seul </FONT><TT><FONT SIZE=5>MIN</FONT></TT><FONT SIZE=5>
	est significatif. Le </FONT><TT><FONT SIZE=5>read</FONT></TT><FONT SIZE=5>
	est bloquant jusqu'&agrave; la reception de </FONT><TT><FONT SIZE=5>MIN</FONT></TT><FONT SIZE=5>
	caract&egrave;res. </FONT>
	</DD><DT>
	<TT><FONT SIZE=5>MIN</FONT></TT><FONT SIZE=5> = 0, </FONT><TT><FONT SIZE=5>TIME</FONT></TT><FONT SIZE=5>
	&gt; 0</FONT></DT><DD>
	<FONT SIZE=5>comme le nombre de caract&egrave;res &agrave; lire est
	nul (</FONT><TT><FONT SIZE=5>MIN</FONT></TT><FONT SIZE=5> = 0), le
	minuteur est initialis&eacute; au debut de l'appel </FONT><TT><FONT SIZE=5>read</FONT></TT><FONT SIZE=5>.
	L'appel </FONT><TT><FONT SIZE=5>read</FONT></TT><FONT SIZE=5>
	retourne soit parce qu'un caract&egrave;re a &eacute;t&eacute; lu ou
	que le d&eacute;lai a expir&eacute;. </FONT>
	</DD><DT>
	<TT><FONT SIZE=5>MIN</FONT></TT><FONT SIZE=5> = 0, </FONT><TT><FONT SIZE=5>TIME</FONT></TT><FONT SIZE=5>
	= 0</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>mode non bloquant &nbsp;: l'appel </FONT><TT><FONT SIZE=5>read</FONT></TT><FONT SIZE=5>
	retourne les caract&egrave;res disponibles (le minimum des
	caract&egrave;res disponibles et du nombre de caract&egrave;res
	demand&eacute;s dans l'appel de </FONT><TT><FONT SIZE=5>read</FONT></TT><FONT SIZE=5>).
	</FONT>
	</DD></DL>
<P>
<FONT SIZE=5>Les valeurs les plus couramment utilis&eacute;es sont
</FONT><TT><FONT SIZE=5>MIN</FONT></TT><FONT SIZE=5>=1, </FONT><TT><FONT SIZE=5>TIME</FONT></TT><FONT SIZE=5>=0,
ce qui est le mode CBREAK des versions BSD. Ce mode permet d'avoir
une saisie bloquante de chaque caract&egrave;re frapp&eacute; au
clavier (vi utilise ce mode), le </FONT><TT><FONT SIZE=5>read</FONT></TT><FONT SIZE=5>
retourne d&egrave;s qu'un caract&egrave;re est frapp&eacute;.<!--TOC subsection <FONT SIZE=5>Les caractères spéciaux</FONT>--></FONT></P>
<H3><FONT SIZE=5>12.3.6&nbsp;&nbsp; Les caract&egrave;res sp&eacute;ciaux</FONT></H3>
<P><FONT SIZE=5><!--SEC END -->Les caract&egrave;res sp&eacute;ciaux
sont d&eacute;finis par le tableau c_cc de la structure termios. Les
positions et les valeurs initiales du r&ocirc;le des diff&eacute;rents
caract&egrave;res sp&eacute;ciaux sont les suivantes&nbsp;:</FONT></P>
<TABLE CELLPADDING=0 CELLSPACING=2>
	<TR>
		<TD></TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>nom</FONT></P>
		</TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>code</FONT></P>
		</TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>caract&egrave;re</FONT></P>
		</TD>
	</TR>
	<TR>
		<TD></TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>EOF</FONT></P>
		</TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>VEOF</FONT></P>
		</TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>Control-D</FONT></P>
		</TD>
	</TR>
	<TR>
		<TD></TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>EOL</FONT></P>
		</TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>VEOL</FONT></P>
		</TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>NUL</FONT></P>
		</TD>
	</TR>
	<TR>
		<TD></TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>ERASE</FONT></P>
		</TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>VERASE</FONT></P>
		</TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>#</FONT></P>
		</TD>
	</TR>
	<TR>
		<TD></TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>INTR</FONT></P>
		</TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>VINTR</FONT></P>
		</TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>DEL</FONT></P>
		</TD>
	</TR>
	<TR>
		<TD></TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>KILL</FONT></P>
		</TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>VKILL</FONT></P>
		</TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>@</FONT></P>
		</TD>
	</TR>
	<TR>
		<TD></TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>MIN</FONT></P>
		</TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>VMIN</FONT></P>
		</TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>NUL</FONT></P>
		</TD>
	</TR>
	<TR>
		<TD></TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>QUIT</FONT></P>
		</TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>VQUIT</FONT></P>
		</TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>Control-pipe</FONT></P>
		</TD>
	</TR>
	<TR>
		<TD></TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>START</FONT></P>
		</TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>VSTART</FONT></P>
		</TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>Control-Q</FONT></P>
		</TD>
	</TR>
	<TR>
		<TD></TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>STOP</FONT></P>
		</TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>VSTOP</FONT></P>
		</TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>Control-S</FONT></P>
		</TD>
	</TR>
	<TR>
		<TD></TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>SUSP</FONT></P>
		</TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>VSUSP</FONT></P>
		</TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>disabled</FONT></P>
		</TD>
	</TR>
	<TR>
		<TD></TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>SWTCH</FONT></P>
		</TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>VSWTCH</FONT></P>
		</TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>NUL</FONT></P>
		</TD>
	</TR>
	<TR>
		<TD></TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>TIME</FONT></P>
		</TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>VTIME</FONT></P>
		</TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>Control-D</FONT></P>
		</TD>
	</TR>
</TABLE>
<P><!--TOC subsection <FONT SIZE=5>Manipulation du driver logiciel de terminaux 
et de la structure termios</FONT>--><BR><BR>
</P>
<H3><FONT SIZE=5>12.3.7&nbsp;&nbsp; Manipulation du driver logiciel
de terminaux et de la structure termios</FONT></H3>
<P><!--SEC END --><B><FONT SIZE=4>Attention</FONT><FONT SIZE=5>
toutes ces op&eacute;rations se font sur un unique terminal manipul&eacute;
par plusieurs descripteurs dans plusieurs processus. Attention donc
aux conflits &eacute;ventuels et faites attention &agrave;
repositionner la ligne apr&egrave;s usage.</FONT></B><FONT SIZE=5><BR>Les
fonctions suivantes permettent de manipuler la structure termios. </FONT>
</P>
<PRE>
<FONT SIZE=5>#include &lt;termios.h&gt;</FONT>
<FONT SIZE=5>int tcgetattr(int desc, struct termios *termios);</FONT></PRE><P>
<FONT SIZE=5>appels syst&egrave;mes!tcgetattr@</FONT><TT><FONT SIZE=5>tcgetattr</FONT></TT><FONT SIZE=5>
extraction des param&egrave;tres courants.</FONT></P>
<PRE>
<FONT SIZE=5>int tcsetattr(int desc, int option, struct termios *termios);</FONT></PRE><P>
<FONT SIZE=5>appels syst&egrave;mes!tcsetattr@</FONT><TT><FONT SIZE=5>tcsetattr</FONT></TT><FONT SIZE=5>
positionnement des param&egrave;tres.<BR>Le param&eacute;tre </FONT><TT><FONT SIZE=5>option</FONT></TT><FONT SIZE=5>
permet de sp&eacute;cifier le comportement de gestion des tampons
d'entr&eacute;e et de sortie de la ligne &nbsp;: </FONT>
</P>
<DL>
	<DT><FONT SIZE=5>TCSANOW</FONT></DT><DD>
	<FONT SIZE=5>changement imm&eacute;diat des attributs </FONT>
	</DD><DT>
	<FONT SIZE=5>TCSADRAIN</FONT></DT><DD>
	<FONT SIZE=5>les sorties en cours sont r&eacute;alis&eacute;es avant
	</FONT>
	</DD><DT>
	<FONT SIZE=5>TCSAFLUSH</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>idem et le tampon de lecture est vid&eacute;. </FONT>
	</DD></DL>
<P>
<FONT SIZE=5>La primitive </FONT>
</P>
<PRE>
<FONT SIZE=5>int tcdrain(int desc);</FONT></PRE><P>
<FONT SIZE=5>appels syst&egrave;mes!tcdrain@</FONT><TT><FONT SIZE=5>tcdrain</FONT></TT><FONT SIZE=5>
bloque le processus jusqu'&agrave; ce que tous les caract&egrave;res
&agrave; destination du terminal de descripteur </FONT><TT><FONT SIZE=5>desc</FONT></TT><FONT SIZE=5>
aient &eacute;t&eacute; transmis. </FONT>
</P>
<PRE>
<FONT SIZE=5>int tcflush(int desc, int option);</FONT></PRE><P>
<FONT SIZE=5>appels syst&egrave;mes!tcflush@</FONT><TT><FONT SIZE=5>tcflush</FONT></TT><FONT SIZE=5>
vidange des tampons.<BR>valeur de </FONT><TT><FONT SIZE=5>option</FONT></TT><FONT SIZE=5>&nbsp;:
</FONT>
</P>
<DL>
	<DT><FONT SIZE=5>TCIFLUSH</FONT></DT><DD>
	<FONT SIZE=5>tampon d'entr&eacute;e </FONT>
	</DD><DT>
	<FONT SIZE=5>TCOFLUSH</FONT></DT><DD>
	<FONT SIZE=5>tampon de sortie </FONT>
	</DD><DT>
	<FONT SIZE=5>TCIOFLUSH</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>les deux tampons. </FONT>
	</DD></DL>
<H3>
<FONT SIZE=5><!--TOC subsection <FONT SIZE=5>Manipulation de la vitesse de transmission</FONT>-->12.3.8&nbsp;&nbsp;
Manipulation de la vitesse de transmission</FONT></H3>
<P><FONT SIZE=5><!--SEC END -->Le mode de codage de la vitesse &eacute;tant
complexe, elle se manipule en deux &eacute;tapes, encodage/d&eacute;code,
positionnement/r&eacute;cup&eacute;ration.<BR><BR>Encodage: </FONT>
</P>
<PRE>
<FONT SIZE=5>speed_t cfgetispeed(const struct termios *termios);</FONT>
<FONT SIZE=5>speed_t cfgetospeed(const struct termios *termios);</FONT></PRE><P>
<FONT SIZE=5>appels syst&egrave;mes!cfgetispeed@</FONT><TT><FONT SIZE=5>cfgetispeed</FONT></TT><FONT SIZE=5>
appels syst&egrave;mes!cfgetospeed@</FONT><TT><FONT SIZE=5>cfgetospeed</FONT></TT><FONT SIZE=5>
Permet de lire la vitesse dans la structure termios.</FONT></P>
<PRE>
<FONT SIZE=5>int cfsetispeed(const struct *termios, speed_t vitesse);</FONT>
<FONT SIZE=5>int cfsetospeed(const struct *termios, speed_t vitesse);</FONT></PRE><P>
<FONT SIZE=5>appels syst&egrave;mes!cfsetispeed@</FONT><TT><FONT SIZE=5>cfsetispeed</FONT></TT><FONT SIZE=5>
appels syst&egrave;mes!cfsetospeed@</FONT><TT><FONT SIZE=5>cfsetospeed</FONT></TT><FONT SIZE=5>
permet de positionner la vitesse dans la structure
termios.<BR><BR>Positionnement/r&eacute;cup&eacute;ration de la
structure termios par les primitives </FONT><TT><FONT SIZE=5>tcgetattr
</FONT></TT><FONT SIZE=5>et </FONT><TT><FONT SIZE=5>tcsetattr</FONT></TT><FONT SIZE=5>.<!--TOC section <FONT SIZE=5>Pseudo-terminaux</FONT>--></FONT></P>
<H2><FONT SIZE=5>12.4&nbsp;&nbsp; Pseudo-terminaux</FONT></H2>
<P><!--SEC END --><FONT SIZE=5>Les pseudo-terminaux sont un m&eacute;canisme
permettant une connection entre processus, qui prend les attributs
d&eacute;finis dans la communication pour des terminaux physiques.
D'o&ugrave; le nom de pseudo-terminaux. Un pseudo-terminal est
compos&eacute; de deux entit&eacute;s appel&eacute;es pseudo-terminal
ma&icirc;tre et pseudo-terminal esclave, qui forment les deux
extr&eacute;mit&eacute;s de la connexion. /dev/pty pseudo-terminaux
L'ouverture des deux extr&eacute;mit&eacute;s suit les r&egrave;gles
suivantes &nbsp;: Le ma&icirc;tre </FONT><TT><FONT SIZE=5>/dev/pty</FONT><EM><FONT SIZE=5>xy</FONT></EM></TT><FONT SIZE=5>
ne peut &ecirc;tre ouvert qu'une seule fois. L'esclave </FONT><TT><FONT SIZE=5>/dev/tty</FONT><EM><FONT SIZE=5>xy</FONT></EM></TT><FONT SIZE=5>
ne peut &ecirc;tre ouvert que si le ma&icirc;tre correspondant est
ouvert.<BR><BR>Les pseudo-terminaux ont des noms o&ugrave; </FONT><TT><FONT SIZE=5>x
<FONT FACE="symbol">&Icirc;</FONT> [p-t]</FONT></TT><FONT SIZE=5> et
</FONT><TT><FONT SIZE=5>y <FONT FACE="symbol">&Icirc;</FONT>
[0-9a-f]</FONT></TT><FONT SIZE=5>. <BR><BR>Dans la figure </FONT><A HREF="#pseudo"><FONT SIZE=5>12.2</FONT></A><FONT SIZE=5>,
un <B>pseudo-terminal</B> est utilis&eacute; pour faire communiquer
deux processus. Toutes les &eacute;critures de A sur le ma&icirc;tre
sont lisibles sur l'esclave par le processus B et r&eacute;ciproquement.
Exactement comme si l'on avait utilis&eacute; deux tubes. De plus,
pour le processus B l'entr&eacute;e et la sortie standard sont
per&ccedil;ues comme un terminal qui se comporte normalement &agrave;
l'appel des fonctions de manipulation du driver de terminaux comme
</FONT><TT><FONT SIZE=5>tcsetattr</FONT></TT><FONT SIZE=5>. Et les
caract&egrave;res de contr&ocirc;le sont effectivement transform&eacute;s
en signaux.</FONT></P>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML063.gif" NAME="Image65" ALIGN=BOTTOM WIDTH=320 HEIGHT=55 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
12.2&nbsp;: Un exemple d'utilisation d'un pseudo terminal</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="pseudo"></A><BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<H2><!--TOC section <FONT SIZE=5>La primitive </FONT><FONT SIZE=5><TT>ioctl </TT></FONT>-->12.5&nbsp;&nbsp;
La primitive <TT>ioctl </TT>
</H2>
<P><!--SEC END --><FONT SIZE=5>La primitive </FONT><TT><FONT SIZE=5>ioctl
</FONT></TT><FONT SIZE=5>permet de r&eacute;aliser un certain nombre
d'op&eacute;rations sur les fichiers sp&eacute;ciaux. A l'inverse de
</FONT><TT><FONT SIZE=5>read</FONT></TT><FONT SIZE=5> et </FONT><TT><FONT SIZE=5>write</FONT></TT><FONT SIZE=5>
qui sont polymorphes et qui s'appliquent identiquement sur tous les
fichiers (sp&eacute;ciaux ou non), la primitive </FONT><TT><FONT SIZE=5>ioctl</FONT></TT><FONT SIZE=5>
a des argment diff&eacute;rents pour chaque type de fichier
sp&eacute;cial.<BR><BR></FONT><TT><FONT SIZE=5>#include&lt;sys/ioctl.h&gt;<BR><BR>int
ioctl(int desc, int requete, ... /* args */);<BR></FONT></TT><FONT SIZE=5>appels
syst&egrave;mes!ioctl@</FONT><TT><FONT SIZE=5>ioctl<!--TOC chapter <FONT SIZE=5>Les signaux</FONT>--></FONT></TT><FONT SIZE=5>
</FONT>
</P>
<H1><FONT SIZE=5>Chapitre&nbsp;13&nbsp;&nbsp; Les signaux</FONT></H1>
<P><!--SEC END --><FONT SIZE=5>signaux Les signaux sont un m&eacute;canisme
asynchrone de communication inter-processus. <BR>Intuitivement, il
sont comparables &agrave; des sonneries, les differentes sonneries
indiquant des &eacute;v&egrave;nements diff&eacute;rents. Les signaux
sont envoy&eacute;s &agrave; un ou plusieurs processus. Ce signal est
en g&eacute;n&eacute;ral associ&eacute; &agrave; un &eacute;v&egrave;nement.<BR><BR>Peu
portables entre BSD et ATT, ils deviennent plus commodes &agrave;
utiliser et portables avec la norme POSIX qui utilise la notion utile
de vecteur de signaux et qui fournit un m&eacute;canisme de masquage
automatique pendant les proc&eacute;dures de traitement (comme
BSD).<BR><BR>Un signal est envoy&eacute; &agrave; un processus en
utilisant l'appel syst&egrave;me&nbsp;: </FONT>
</P>
<PRE>
<FONT SIZE=5> kill(int pid, int signal); </FONT></PRE><P>
<FONT SIZE=5>appels syst&egrave;mes!kill@</FONT><TT><FONT SIZE=5>kill</FONT></TT><FONT SIZE=5>
signaux!kill </FONT><TT><FONT SIZE=5>signal</FONT></TT><FONT SIZE=5>
est un num&eacute;ro compris entre 1 et </FONT><TT><FONT SIZE=5>NSIG</FONT></TT><FONT SIZE=5>
(d&eacute;fini dans </FONT><TT><CODE><FONT SIZE=5>&lt;signal.h&gt;</FONT></CODE></TT><FONT SIZE=5>)
et </FONT><TT><FONT SIZE=5>pid</FONT></TT><FONT SIZE=5> le num&eacute;ro
du processus.<BR>Le processus vis&eacute; re&ccedil;oit le signal
sous forme d'un drapeau positionn&eacute; dans son bloc de
contr&ocirc;le.<BR>Le processus est interrompu et r&eacute;alise
&eacute;ventuellement un traitement de ce signal.<BR>On peut
consid&eacute;rer les signaux comme des interruptions logicielles,
ils interrompent le flot normal d'un processus mais ne sont pas
trait&eacute;s de fa&ccedil;on synchrone comme les interruptions
mat&eacute;rielles.<!--TOC subsection <FONT SIZE=5>Provenance des signaux</FONT>--></FONT></P>
<H3><FONT SIZE=5>13.0.1&nbsp;&nbsp; Provenance des signaux</FONT></H3>
<P><!--SEC END --><FONT SIZE=5>Certains signaux peuvent &ecirc;tre
lanc&eacute;s &agrave; partir d'un terminal gr&acirc;ce aux
caract&egrave;res sp&eacute;ciaux comme </FONT><TT><FONT SIZE=5>intr</FONT></TT><FONT SIZE=5>,
</FONT><TT><FONT SIZE=5>quit</FONT></TT><FONT SIZE=5> dont la frappe
est transform&eacute;e en l'envoi des signaux </FONT><TT><FONT SIZE=5>SIGINT</FONT></TT><FONT SIZE=5>
et </FONT><TT><FONT SIZE=5>SIGQUIT</FONT></TT><FONT SIZE=5>.
intrquitsusp SIGINT D'autres sont d&ucirc;s &agrave; des causes
internes au processus, par exemple&nbsp;: </FONT><TT><FONT SIZE=5>SIGSEGV</FONT></TT><FONT SIZE=5>
qui est envoy&eacute; en cas d'erreur d'adressage, </FONT><TT><FONT SIZE=5>SIGFPE</FONT></TT><FONT SIZE=5>
division par z&eacute;ro (Floating Point Exception).<BR><BR>Enfin
certains sont d&ucirc;s &agrave; des &eacute;v&egrave;nements comme
la d&eacute;connection de la ligne (le terminal) utilis&eacute;&nbsp;:
si le processus leader d'un groupe de processus est d&eacute;connect&eacute;,
il envoie &agrave; l'ensemble des processus de son groupe le signal
</FONT><TT><FONT SIZE=5>SIGHUP</FONT></TT><FONT SIZE=5> (Hangup =
raccrocher). SIGHUP<!--TOC subsection <FONT SIZE=5>Gestion interne des signaux</FONT>--></FONT></P>
<H3><FONT SIZE=5>13.0.2&nbsp;&nbsp; Gestion interne des signaux</FONT></H3>
<P><!--SEC END --><FONT SIZE=5>C'est dans le bloc de contr&ocirc;le
(BCP) de chaque processus que l'on trouve la table de gestion des
signaux (attention, sous System V &lt; V.4, la table de gestion des
processus est dans la </FONT><TT><FONT SIZE=5>zone u</FONT></TT><FONT SIZE=5>,
c'est &agrave; dire dans l'espace-m&eacute;moire du
processus).<BR><BR>Cette table contient, pour chaque signal d&eacute;fini
sur la machine, une structure </FONT><TT><FONT SIZE=5>sigvec</FONT></TT><FONT SIZE=5>
suivante&nbsp;: </FONT>
</P>
<PRE>
<FONT SIZE=5>   {</FONT>
<FONT SIZE=5>       bit pendant;</FONT>
<FONT SIZE=5>       void (*traitement)(int);</FONT>
<FONT SIZE=5>   } </FONT></PRE><P>
<FONT SIZE=5>handler pendant En BSD et POSIX, on a un champ
suppl&eacute;mentaire&nbsp;: </FONT><TT><FONT SIZE=5>bit masque;</FONT></TT><FONT SIZE=5><BR>Le
drapeau </FONT><TT><FONT SIZE=5>pendant</FONT></TT><FONT SIZE=5>
indique que le processus a re&ccedil;u un signal, mais n'a pas encore
eu l'occasion de prendre en compte ce signal.<BR>Remarque&nbsp;:
comme </FONT><TT><FONT SIZE=5>pendant</FONT></TT><FONT SIZE=5> est un
unique bit, si un processus re&ccedil;oit plusieurs fois le m&ecirc;me
signal avant de le prendre en compte, alors il n'y a pas m&eacute;morisation
des r&eacute;ceptions successives, un seul traitement sera donc
r&eacute;alis&eacute;.<BR><BR>Comme nous l'avons vu dans le graphe
d'&eacute;tat des processus, la prise en compte des signaux se fait
au passage de l'&eacute;tat actif noyau &agrave; l'&eacute;tat actif
utilisateur. Pourquoi la prise en compte de signaux se fait-elle
uniquement &agrave; ce moment l&agrave; ?<BR><B>Parce que</B><BR>Une
sauvegarde de la pile utilisateur et du contexte a &eacute;t&eacute;
effectu&eacute;e quand le processus est pass&eacute; en mode noyau.
Il n'est pas n&eacute;cessaire de faire un nouveau changement de
contexte. Il est facile pour traiter le signal de r&eacute;aliser
imm&eacute;diatement une nouvelle augmentation de pile pour le
traitement du signal, de plus la pile noyau est vide (remarque &nbsp;:
en POSIX, il devient possible de cr&eacute;er une pile sp&eacute;ciale
pour les fonctions de traitement de signaux).<BR><BR>L'appel &agrave;
la fonction de traitement est r&eacute;alis&eacute; de fa&ccedil;on &agrave;
ce qu'au retour de la fonction, le processus continue son ex&eacute;cution
normalement en poursuivant ce qui &eacute;tait en cours de
r&eacute;alisation avant la r&eacute;ception du signal. Si l'on veut
que le processus se poursuive dans un autre contexte (de pile), il
doit g&eacute;rer lui-m&ecirc;me la restauration de ce contexte.<BR><BR>La
primitive </FONT><TT><FONT SIZE=5>longjmp</FONT></TT><FONT SIZE=5>
peut permettre de r&eacute;aliser des changements de contexte interne
au processus, gr&acirc;ce &agrave; un d&eacute;sempilement brutal.
longjmp</FONT><BR><BR><FONT SIZE=5>Pendant ce changement d'&eacute;tat,
la table de gestion des signaux du processus est test&eacute;e pour
la pr&eacute;sence d'un signal re&ccedil;u mais non trait&eacute;
(c'est un simple vecteur de bit pour le bit pendant, et donc testable
en une seule instruction, ceci doit &ecirc;tre fait rapidement comme
le test de r&eacute;ception d'un signal est souvent r&eacute;alis&eacute;).<BR>Si
un signal a &eacute;t&eacute; re&ccedil;u ( et qu'il n'est pas
masqu&eacute;), alors la fonction de traitement associ&eacute;e est
r&eacute;alis&eacute;e. Le masquage permet au processus de temporiser
la mise en &oslash;euvre du traitement.<!--TOC subsection <FONT SIZE=5>L'envoi de signaux &nbsp;: la primitive kill</FONT>--></FONT></P>
<H3><FONT SIZE=5>13.0.3&nbsp;&nbsp; L'envoi de signaux &nbsp;: la
primitive kill</FONT></H3>
<PRE><!--SEC END -->
<FONT SIZE=5>     kill(int pid, int sig)</FONT></PRE><P>
<FONT SIZE=5>appels syst&egrave;mes!kill@</FONT><TT><FONT SIZE=5>kill</FONT></TT><FONT SIZE=5>
<BR><BR>Il y a NSIG signaux sur une machine, d&eacute;clar&eacute;s
dans le fichier /usr/include/signal.h.<BR>La valeur de </FONT><TT><FONT SIZE=5>pid</FONT></TT><FONT SIZE=5>
indique le </FONT><TT><FONT SIZE=5>PID</FONT></TT><FONT SIZE=5> du
processus auquel le signal est envoy&eacute;. </FONT>
</P>
<DL>
	<DT><FONT SIZE=5>0</FONT></DT><DD>
	<FONT SIZE=5>Tous les processus du <B>groupe</B> du processus
	r&eacute;alisant l'appel </FONT><TT><FONT SIZE=5>kill</FONT></TT><FONT SIZE=5>
	</FONT>
	</DD><DT>
	<FONT SIZE=5>1</FONT></DT><DD>
	<FONT SIZE=5>En syst&egrave;me V.4 tous les processus du syst&egrave;me
	sauf 0 et 1 </FONT>
	</DD><DT>
	<FONT SIZE=5>pid positif</FONT></DT><DD>
	<FONT SIZE=5>le processus du pid indiqu&eacute; </FONT>
	</DD><DT>
	<FONT SIZE=5>pid n&eacute;gatif</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>tous les processus du groupe | pid | </FONT>
	</DD></DL>
<P>
<FONT SIZE=5>le param&egrave;tre </FONT><TT><FONT SIZE=5>sig</FONT></TT><FONT SIZE=5>
est interpr&eacute;t&eacute; comme un signal si </FONT><TT><FONT SIZE=5>sig</FONT></TT><FONT SIZE=5>
<FONT FACE="symbol">&Icirc;</FONT> [0-NSIG], ou comme une demande
d'information si </FONT><TT><FONT SIZE=5>sig</FONT></TT><FONT SIZE=5>
= 0 (suis-je autoris&eacute; &agrave; envoyer un signal &agrave;
ce(s) processus ?). Comme un param&egrave;tre erron&eacute; sinon.<BR>La
fonction </FONT><TT><FONT SIZE=5>raise(int signal)</FONT></TT><FONT SIZE=5>
est un raccourci pour </FONT><TT><FONT SIZE=5>kill(getpid(), signal)</FONT></TT><FONT SIZE=5>,
le processus s'envoie &agrave; lui-m&ecirc;me un signal.<BR>Remarquez
que l'on peut r&eacute;&eacute;crire </FONT><TT><FONT SIZE=5>kill(0,
signal)</FONT></TT><FONT SIZE=5> par </FONT><TT><FONT SIZE=5>kill(-getpid(),
signal)</FONT></TT><FONT SIZE=5>. Rappel&nbsp;: les PID sont toujours
positifs.<!--TOC section <FONT SIZE=5>La gestion simplifiée avec la fonction </FONT><FONT SIZE=5><TT>signal</TT></FONT>--></FONT></P>
<H2>13.1&nbsp;&nbsp; La gestion simplifi&eacute;e avec la fonction
<TT>signal</TT></H2>
<P><FONT SIZE=5><!--SEC END -->ZZZ&nbsp;: cette section est
historique, utiliser la norme POSIX d&eacute;crite plus loin. </FONT>
</P>
<PRE>
<FONT SIZE=5>ancien C : (*signal(sig, func))()</FONT>
<FONT SIZE=5>           int sig;</FONT>
<FONT SIZE=5>           int (*func)();</FONT>
<FONT SIZE=5> </FONT>
<FONT SIZE=5>ANSI C :   void (*signal(int sig, void (*action)(int)))(int);</FONT></PRE><P>
<FONT SIZE=5>appels syst&egrave;mes!signal@</FONT><TT><FONT SIZE=5>signal</FONT></TT><FONT SIZE=5>
La fonction </FONT><TT><FONT SIZE=5>signal</FONT></TT><FONT SIZE=5>
permet de sp&eacute;cifier ou de conna&icirc;tre le comportement du
processus &agrave; la r&eacute;ception d'un signal donn&eacute;, il
faut donner en param&egrave;tre &agrave; la fonction le num&eacute;ro
du signal </FONT><TT><FONT SIZE=5>sig</FONT></TT><FONT SIZE=5> que
l'on veut d&eacute;tourner et la fonction de traitement </FONT><TT><FONT SIZE=5>action</FONT></TT><FONT SIZE=5>
&agrave; r&eacute;aliser &agrave; la r&eacute;ception du
signal.<BR>Trois possibilit&eacute;s pour ce param&egrave;tre </FONT><TT><FONT SIZE=5>action</FONT></TT><FONT SIZE=5>
</FONT>
</P>
<DL>
	<DT><FONT SIZE=5>SIG_DFL</FONT></DT><DD>
	<FONT SIZE=5>Comportement par d&eacute;faut, plusieurs possibilit&eacute;s
	<B>exit</B> Le processus se termine (avec si possible la r&eacute;alisation
	d'un core) <B>ignore</B> Le processus ignore le signal <B>pause</B>
	Suspension du processus <B>continue</B> Reprise du processus si il
	&eacute;tait suspendu. </FONT>
	</DD><DT>
	<FONT SIZE=5>SIG_IGN</FONT></DT><DD>
	<FONT SIZE=5>le signal est ignor&eacute;.<BR>Remarque&nbsp;: les
	signaux SIGKILL, SIGSTOP ne peuvent pas &ecirc;tre ignor&eacute;s. </FONT>
	</DD><DT>
	<FONT SIZE=5>HANDLER</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>Une fonction de votre cru. </FONT>
	</DD></DL>
<H3>
<FONT SIZE=5><!--TOC subsection <FONT SIZE=5>Un exemple</FONT>-->13.1.1&nbsp;&nbsp;
Un exemple</FONT></H3>
<P><FONT SIZE=5><!--SEC END -->Exemple pour rendre un programme
insensible &agrave; la frappe du caract&egrave;re de contr&ocirc;le
intr sur le terminal de contr&ocirc;le du processus. </FONT>
</P>
<PRE>
<FONT SIZE=5>void got_the_blody_signal(int n) {</FONT>
<FONT SIZE=5>    signal(SIGINT, got_the_blody_signal);</FONT>
<FONT SIZE=5>    printf(&quot; gotcha!!  your  (%d) signal is useless \n&quot;);</FONT>
<FONT SIZE=5>}</FONT>

<FONT SIZE=5>main() {</FONT>
<FONT SIZE=5>    signal(SIGINT, got_the_blody_signal);</FONT>
<FONT SIZE=5>    printf(&quot; kill me now !! \n&quot;);</FONT>
<FONT SIZE=5>    for(;;);</FONT>
<FONT SIZE=5>}</FONT></PRE><P>
<FONT SIZE=5>une version plus &eacute;l&eacute;gante et plus fiable&nbsp;:
</FONT>
</P>
<PRE>
<FONT SIZE=5>    signal(SIGINT, SIG_IGN);</FONT></PRE><H2>
<FONT SIZE=5><!--TOC section <FONT SIZE=5>Problèmes de la gestion de signaux ATT</FONT>-->13.2&nbsp;&nbsp;
Probl&egrave;mes de la gestion de signaux ATT</FONT></H2>
<P><FONT SIZE=5><!--SEC END -->Les ph&eacute;nom&egrave;nes suivants
sont d&eacute;crits comme des probl&egrave;mes mais la norme POSIX
permet d'en conserver certains, mais fournit aussi les moyens de les
&eacute;viter. </FONT>
</P>
<OL>
	<LI><P><FONT SIZE=5>un signal est repositionn&eacute; &agrave; sa
	valeur par d&eacute;faut au d&eacute;but de son traitement
	(handler).</FONT></P>
	<PRE>
<FONT SIZE=5>#include &lt;signal.h&gt;</FONT>

<FONT SIZE=5>traitement()  {</FONT>
<FONT SIZE=5>    printf(&quot;PID %d en a capture un \n&quot;, getpid());</FONT>
<FONT SIZE=5>-&gt;     reception du deuxieme signal, realisation d'un exit </FONT>
<FONT SIZE=5>    signal(SIGINT, traitement);</FONT>
<FONT SIZE=5>}</FONT>

<FONT SIZE=5>main() {</FONT>
<FONT SIZE=5>    int ppid;</FONT>
<FONT SIZE=5>    signal(SIGINT,traitement);</FONT>
<FONT SIZE=5>    if (fork()==0)</FONT>
<FONT SIZE=5>    {/* attendre que pere ait realise son nice() */</FONT>
<FONT SIZE=5>        sleep(5);</FONT>
<FONT SIZE=5>        ppid = getppid(); /* numero de pere */</FONT>
<FONT SIZE=5>        for(;;)</FONT>
<FONT SIZE=5>            if (kill(ppid,SIGINT) == -1)</FONT>
<FONT SIZE=5>                exit();</FONT>
<FONT SIZE=5>    }</FONT>
<FONT SIZE=5>/* pere ralenti pour un conflit plus sur */</FONT>
<FONT SIZE=5>    nice(10);</FONT>
<FONT SIZE=5>    for(;;) pause();  &lt;- reception du premier signal  </FONT>
<FONT SIZE=5>/* pause c'est mieux qu'une attente active */</FONT>
<FONT SIZE=5>}</FONT></PRE><P>
	<FONT SIZE=5>Si l'on cherche &agrave; corriger ce d&eacute;faut, on
	repositionne la fonction </FONT><TT><FONT SIZE=5>traitement</FONT></TT><FONT SIZE=5>
	au d&eacute;but du traitement du signal. Ceci risque de nous placer
	dans une situation de d&eacute;passement de pile&nbsp;: en effet,
	dans le programme pr&eacute;c&eacute;dent, nous pouvons imaginer que
	le p&egrave;re peut recevoir un nombre de signaux arbitrairement
	grand pendant le traitement d'un seul signal, d'o&ugrave; une
	explosion assur&eacute;e de la pile (il suffit en effet que chaque
	empilement de la fonction </FONT><TT><FONT SIZE=5>traitement</FONT></TT><FONT SIZE=5>
	soit interrompu par un signal) </FONT>
	</P>
	<PRE>
<FONT SIZE=5>traitement(){</FONT>
<FONT SIZE=5>    signal(SIGINT,traitement);</FONT>
<FONT SIZE=5>-&gt;   signal SIGINT</FONT>
<FONT SIZE=5>    printf(&quot;PID %d en a capture un \n&quot;,getpid());</FONT>
<FONT SIZE=5>}</FONT></PRE><P>
	<FONT SIZE=5>On peut aussi ignorer les signaux pendant leur
	traitement, mais cela peut cr&eacute;er des pertes de
	r&eacute;ception.<BR>Enfin, la solution BSD/POSIX o&ugrave; l'on
	peut bloquer et d&eacute;bloquer la r&eacute;ception de signaux &agrave;
	l'aide du vecteur de masquage (sans pour autant nous assurer de la
	r&eacute;ception de tous les signaux !!). De plus, en POSIX, le
	traitement d'un signal comporte une clause de blocage automatique.
	On indique quels signaux doivent &ecirc;tre bloqu&eacute;s pendant
	le traitement du signal, gr&acirc;ce &agrave; un vecteur de masquage
	dans la structure </FONT><TT><FONT SIZE=5>sigaction</FONT></TT><FONT SIZE=5>.<BR><BR>Ceci
	est le comportement naturel de gestion des interruptions
	mat&eacute;rielles&nbsp;: on bloque les interruptions de priorit&eacute;
	inf&eacute;rieure pendant le traitement d'un interruption.</FONT></P>
	<LI><P><FONT SIZE=5>Seconde anomalie des signaux sous System V &lt;
	V4&nbsp;: certains appels syst&egrave;mes peuvent &ecirc;tre
	interrompus et dans ce cas la valeur de retour de l'appel syst&egrave;me
	est -1 (&eacute;chec). Il faudrait, pour r&eacute;aliser
	correctement le mod&egrave;le d'une interruption logicielle,
	relancer l'appel syst&egrave;me en fin de traitement du signal.
	(Sous BSD ou POSIX, il est possible de choisir le comportement en
	cas d'interruption d'un appel syst&egrave;me gr&acirc;ce &agrave; la
	fonction </FONT><TT><FONT SIZE=5>siginterrupt</FONT></TT><FONT SIZE=5>,
	c-a-d relancer ou non l'appel syst&egrave;me, un appel &agrave;
	</FONT><TT><FONT SIZE=5>read</FONT></TT><FONT SIZE=5>, par exemple,
	peut facilement &ecirc;tre interrompu si il n&eacute;cessite un
	acc&egrave;s disque).</FONT></P>
	<LI><P><FONT SIZE=5>Troisi&egrave;me anomalie des signaux sous ATT&nbsp;:
	si un signal est ignor&eacute; par un processus endormi, celui-ci
	sera r&eacute;veill&eacute; par le syst&egrave;me uniquement pour
	apprendre qu'il ignore le signal et doit donc &ecirc;tre endormi de
	nouveau. Cette perte de temps est d&ucirc;e au fait que le vecteur
	des signaux est dans la zone u et non pas dans le bloc de contr&ocirc;le
	du processus.</FONT></P>
</OL>
<H3><FONT SIZE=5><!--TOC subsection <FONT SIZE=5>Le signal SIGCHLD</FONT>-->13.2.1&nbsp;&nbsp;
Le signal SIGCHLD</FONT></H3>
<P><!--SEC END --><FONT SIZE=5>Le signal SIGCHLD (anciennement
SIGCLD) est un signal utilis&eacute; pour r&eacute;veiller un
processus dont un des fils vient de mourir. C'est pourquoi il est
trait&eacute; diff&eacute;remment des autres signaux. La r&eacute;action
&agrave; la r&eacute;ception d'un signal SIGCHLD est de repositionner
le bit pendant &agrave; z&eacute;ro, et d'ignorer le signal, mais le
processus a quand m&ecirc;me &eacute;t&eacute; r&eacute;veill&eacute;
pour cela. L'effet d'un signal SIGCHLD est donc uniquement de
r&eacute;veiller un processus endormi en priorit&eacute;
interruptible.<BR>Si le processus capture les signaux SIGCHLD, il
invoque alors la proc&eacute;dure de traitement d&eacute;finie par
l'utilisateur comme il le fait pour les autres signaux, ceci en plus
du traitement par d&eacute;faut.<BR>Le traitement normal est li&eacute;
&agrave; la primitive </FONT><TT><FONT SIZE=5>wait</FONT></TT><FONT SIZE=5>
qui permet de r&eacute;cup&eacute;rer la valeur de retour (exit
status) d'un processus fils. En effet, la primitive </FONT><TT><FONT SIZE=5>wait</FONT></TT><FONT SIZE=5>
est bloquante et c'est la r&eacute;ception du signal qui va r&eacute;veiller
le processus, et permettre la fin de l'ex&eacute;cution de la
primitive </FONT><TT><FONT SIZE=5>wait</FONT></TT><FONT SIZE=5>.<BR>Un
des probl&egrave;mes de la gestion de signaux System V est le fait
que le signal SIGCHLD est re&ccedil;u (raised) au moment de la pose
d'une fonction de traitement.<BR>Ces propri&eacute;t&eacute;s du
signal SIGCHLD peuvent induire un bon nombre d'erreurs.<BR><BR>Par
exemple, dans le programme suivant nous positionnons une fonction de
traitement dans laquelle nous repositionnons la fonction de
traitement. Comme sous System V, le comportement par d&eacute;faut
est repositionn&eacute; pendant le traitement d'un signal. Or le
signal est lev&eacute; &agrave; la pose de la fonction de traitement,
d'o&ugrave; une explosion de la pile. </FONT>
</P>
<PRE>
<FONT SIZE=5>#include &lt;stdio.h&gt;</FONT>
<FONT SIZE=5>#include &lt;unistd.h&gt; /* ancienne norme */</FONT>
<FONT SIZE=5>#include &lt;signal.h&gt;</FONT>

<FONT SIZE=5>void hand(int sig) { </FONT>
<FONT SIZE=5>    signal(sig, hand);</FONT>
<FONT SIZE=5>    printf(&quot;message qui n'est pas affiche\n&quot;);</FONT>
<FONT SIZE=5>}</FONT>

<FONT SIZE=5>main() {</FONT>
<FONT SIZE=5>    if (fork()) { exit(0); /* creation d'un zombi */ } </FONT>
<FONT SIZE=5>    signal(SIGCHLD, hand);</FONT>
<FONT SIZE=5>    printf(&quot;ce printf n'est pas execute\n&quot;);</FONT>
<FONT SIZE=5>}</FONT></PRE><P>
<FONT SIZE=5>Sur les HP, un message d'erreur vous informe que la pile
est pleine &nbsp;: </FONT><TT><FONT SIZE=5>stack growth
failure</FONT></TT><FONT SIZE=5>.<BR><BR>Deuxi&egrave;me exemple &nbsp;:
</FONT>
</P>
<PRE>
<FONT SIZE=5>#include &lt;signal.h&gt;</FONT>
<FONT SIZE=5>#include &lt;sys/wait.h&gt;</FONT>

<FONT SIZE=5>int pid, status;</FONT>

<FONT SIZE=5>void hand(int sig) {</FONT>
<FONT SIZE=5>    printf(&quot; Entree dans le handler \n&quot;);</FONT>
<FONT SIZE=5>    system(&quot;ps -l&quot;);                 /* affichage avec etat zombi du fils */</FONT>
<FONT SIZE=5>    if ((pid = wait(&amp;status)) == -1) /* suppression du fils zombi */</FONT>
<FONT SIZE=5>    {</FONT>
<FONT SIZE=5>         perror(&quot;wait handler &quot;);</FONT>
<FONT SIZE=5>         return ;</FONT>
<FONT SIZE=5>    }</FONT>
<FONT SIZE=5>    printf(&quot; wait handler  pid: %d    status %d \n&quot;, pid, status);</FONT>
<FONT SIZE=5>    return;</FONT>
<FONT SIZE=5>}</FONT>

<FONT SIZE=5>main() {</FONT>
<FONT SIZE=5>    signal(SIGCHLD,hand);  /* installation du handler */</FONT>
<FONT SIZE=5>    if (fork() ==  0)</FONT>
<FONT SIZE=5>    {   /* dans le fils */</FONT>
<FONT SIZE=5>        sleep(5);</FONT>
<FONT SIZE=5>        exit(2);</FONT>
<FONT SIZE=5>    } </FONT>
<FONT SIZE=5>/* dans le pere */</FONT>
<FONT SIZE=5>    if ((pid = wait(&amp;status)) == -1) /* attente de terminaison du fils */</FONT>
<FONT SIZE=5>    {</FONT>
<FONT SIZE=5>        perror(&quot;wait main &quot;);</FONT>
<FONT SIZE=5>        return ;</FONT>
<FONT SIZE=5>    }</FONT>
<FONT SIZE=5>    printf(&quot; wait main  pid: %d    status %d \n&quot;, pid, status);</FONT>
<FONT SIZE=5>}</FONT></PRE><P>
<FONT SIZE=5>r&eacute;sultat&nbsp;: </FONT>
</P>
<PRE>
<FONT SIZE=5> Entree dans le handler </FONT>
<FONT SIZE=5>F S  UID   PID  PPID  C PRI NI     ADDR   SZ  WCHAN    TTY  TIME COMD</FONT>
<FONT SIZE=5>1 S  121  6792  6667  0 158 20  81ac180    6  49f5fc  ttys1 0:00 sigchld</FONT>
<FONT SIZE=5>1 S  121  6667  6666  0 168 20  81ac700  128 7ffe6000 ttys1 0:00 tcsh</FONT>
<FONT SIZE=5>1 Z  121  6793  6792  0 178 20  81bda80    0          ttys1 0:00 sigchld</FONT>
<FONT SIZE=5>1 S  121  6794  6792  0 158 20  81ac140   78  4a4774  ttys1 0:00 sh</FONT>
<FONT SIZE=5>1 R  121  6795  6794  4 179 20  81bd000   43          ttys1 0:00 ps</FONT>
<FONT SIZE=5>wait handler  pid: 6793    status 512     (2 * 256)</FONT>
<FONT SIZE=5>wait main: Interrupted system call</FONT>
</PRE><P>
<FONT SIZE=5>A la mort du fils, Le p&egrave;re re&ccedil;oit le
signal SIGCHLD (alors qu'il &eacute;tait dans le </FONT><TT><FONT SIZE=5>wait</FONT></TT><FONT SIZE=5>
du main), puis le handler est execut&eacute;, et </FONT><TT><FONT SIZE=5>ps</FONT></TT><FONT SIZE=5>
affiche bien le fils zombi. Ensuite c'est le </FONT><TT><FONT SIZE=5>wait</FONT></TT><FONT SIZE=5>
du handler qui prend en compte la terminaison du fils. Au retour du
handler, l'appel a </FONT><TT><FONT SIZE=5>wait</FONT></TT><FONT SIZE=5>
du main retourne -1, puisqu'il avait &eacute;t&eacute; interrompu par
SIGCHLD.<!--TOC section <FONT SIZE=5>Manipulation de la pile d'exécution</FONT>--></FONT></P>
<H2><FONT SIZE=5>13.3&nbsp;&nbsp; Manipulation de la pile d'ex&eacute;cution</FONT></H2>
<P><FONT SIZE=5><!--SEC END -->La primitive </FONT>
</P>
<PRE>
<FONT SIZE=5>#include &lt;setjmp.h&gt;</FONT>
<FONT SIZE=5>int sigsetjmp(sigjmp_buf env, int indicateur);</FONT></PRE><P>
<FONT SIZE=5>appels syst&egrave;mes!sigsetjmp@</FONT><TT><FONT SIZE=5>sigsetjmp</FONT></TT><FONT SIZE=5>
sauvegarde un environnement d'ex&eacute;cution, c'est &agrave; dire
un &eacute;tat de la pile, et si </FONT><EM><FONT SIZE=5>indicateur</FONT></EM><FONT SIZE=5>
est non nul, sauvegarde le masque de signaux courant. La valeur de
retour de cette fonction est z&eacute;ro quand on fait une
sauvegarde, et sinon d&eacute;pend du param&egrave;tre </FONT><EM><FONT SIZE=5>valeur</FONT></EM><FONT SIZE=5>
de la fonction </FONT><TT><FONT SIZE=5>siglongjmp</FONT></TT><FONT SIZE=5>.
</FONT>
</P>
<PRE>
<FONT SIZE=5>int siglongjmp(sigjmp_buf env, int valeur);</FONT></PRE><P>
<FONT SIZE=5>appels syst&egrave;mes!siglongjmp@</FONT><TT><FONT SIZE=5>siglongjmp</FONT></TT><FONT SIZE=5>
La primitive </FONT><TT><FONT SIZE=5>siglongjmp</FONT></TT><FONT SIZE=5>
permet de reprendre l'ex&eacute;cution &agrave; l'endroit sauvegard&eacute;
par </FONT><TT><FONT SIZE=5>sigsetjmp</FONT></TT><FONT SIZE=5> dans
la variable </FONT><EM><FONT SIZE=5>env</FONT></EM><FONT SIZE=5>.<BR><BR>Deux
remarques&nbsp;: </FONT><TT><FONT SIZE=5>env</FONT></TT><FONT SIZE=5>
doit avoir &eacute;t&eacute; initialis&eacute; par </FONT><TT><FONT SIZE=5>sigsetjmp</FONT></TT><FONT SIZE=5>,
les valeurs de pile plac&eacute;es au-dessus de l'environnement
repris sont perdues. L'environnement de pile doit encore exister dans
la pile au moment de l'appel, sinon le r&eacute;sultat est
ind&eacute;termin&eacute;.<!--TOC section <FONT SIZE=5>Quelques exemples d'utilisation</FONT>--></FONT></P>
<H2><FONT SIZE=5>13.4&nbsp;&nbsp; Quelques exemples d'utilisation</FONT></H2>
<PRE><!--SEC END -->
<FONT SIZE=5>/*un exemple de signaux BSD */</FONT>
<FONT SIZE=5>#include &lt;stdio.h&gt;</FONT>
<FONT SIZE=5>#include &lt;signal.h&gt;</FONT>
<FONT SIZE=5>void gots1(int n)   { raise(SIGUSR2);  printf(&quot;got  s1(%d) &quot;, n); }</FONT>
<FONT SIZE=5>void gots2(int n)   { printf(&quot;got  s2(%d) &quot;, n); }</FONT>

<FONT SIZE=5>main()</FONT>
<FONT SIZE=5>{</FONT>
<FONT SIZE=5>    int mask ;</FONT>
<FONT SIZE=5>    struct sigvec s1,s2;</FONT>

<FONT SIZE=5>    s1.sv_handler = gots1;</FONT>
<FONT SIZE=5>    s1.sv_mask = sigmask(SIGUSR1);</FONT>
<FONT SIZE=5>    sigvec(SIGUSR1, &amp;s1, NULL);</FONT>

<FONT SIZE=5>    s2.sv_handler = gots2;</FONT>
<FONT SIZE=5>    s2.sv_mask = sigmask(SIGUSR2);</FONT>
<FONT SIZE=5>    sigvec(SIGUSR2, &amp;s2, NULL);</FONT>

<FONT SIZE=5>    printf(&quot; sans masquage de SIGUSR2: &quot;)</FONT>
<FONT SIZE=5>    raise(SIGUSR1);</FONT>

<FONT SIZE=5>    printf(&quot; \n avec masquage de SIGUSR2: &quot; );</FONT>
<FONT SIZE=5>    s1.sv_mask = sigmask(SIGUSR2);</FONT>
<FONT SIZE=5>    sigvec(SIGUSR1, &amp;s1, NULL);</FONT>

<FONT SIZE=5>    raise(SIGUSR1);</FONT>
<FONT SIZE=5>}</FONT></PRE><P>
<FONT SIZE=5>Nous donne les affichages suivant&nbsp;: </FONT>
</P>
<PRE>
<FONT SIZE=5> sans masquage de SIGUSR2: got  s2(31) got  s1(30)</FONT>
<FONT SIZE=5> avec masquage de SIGUSR2: got  s1(30) got  s2(31)</FONT></PRE><P>
<FONT SIZE=5>Sous BSD, pas de fonction de manipulation propre des
groupes de signaux (on regroupe les signaux par des conjonctions de
masques).<BR><BR>Le probl&egrave;me de &quot;l'interruption&quot; des
appels syst&egrave;me par les signaux est corrig&eacute; par la
fonction&nbsp;: </FONT>
</P>
<PRE>
<FONT SIZE=5>int  siginterrupt(int sig, int flag);</FONT></PRE><P>
<FONT SIZE=5>appels syst&egrave;mes!siginterrupt@</FONT><TT><FONT SIZE=5>siginterrupt</FONT></TT><FONT SIZE=5>
le drapeau </FONT><TT><FONT SIZE=5>flag</FONT></TT><FONT SIZE=5>
prend comme valeur 0 ou 1, ce qui signifie que les appels syst&egrave;mes
interrompus par un signal seront&nbsp;:<BR>soit relanc&eacute;s avec
les m&ecirc;mes param&egrave;tres. <BR>soit retourneront la valeur
-1, et dans ce cas la valeur de </FONT><TT><FONT SIZE=5>errno</FONT></TT><FONT SIZE=5>
est positionn&eacute;e &agrave; </FONT><TT><FONT SIZE=5>EINTR</FONT></TT><FONT SIZE=5>.<BR>Certaines
fonctions comme </FONT><TT><FONT SIZE=5>readdir</FONT></TT><FONT SIZE=5>
utilisent des variables statiques, ces fonctions sont dites non
r&eacute;entrantes. Il faut &eacute;viter d'appeler ce type de
fonctions dans un handler de signal, dans le cas o&ugrave; l'on fait
d&eacute;j&agrave; appel &agrave; la fonction dans le reste du
processus. De la m&ecirc;me fa&ccedil;on la variable </FONT><TT><FONT SIZE=5>errno</FONT></TT><FONT SIZE=5>
est unique. Si celle-ci est positionn&eacute;e dans le </FONT><TT><FONT SIZE=5>main</FONT></TT><FONT SIZE=5>
mais qu'un signal arrive avant son utilisation, une primitive appel&eacute;e
dans le handler peut en changer la valeur! (ce probl&egrave;me de
r&eacute;entrance sera vu plus en d&eacute;tail avec les processus
multi-activit&eacute;s).<!--TOC subsection <FONT SIZE=5>L'appel pause</FONT>--></FONT></P>
<H3><FONT SIZE=5>13.4.1&nbsp;&nbsp; L'appel pause</FONT></H3>
<P><FONT SIZE=5><!--SEC END -->Fonction de mise en attente de
r&eacute;ception d'un signal&nbsp;: </FONT>
</P>
<PRE>
<FONT SIZE=5>pause(void);</FONT></PRE><P>
<FONT SIZE=5>appels syst&egrave;mes!pause@</FONT><TT><FONT SIZE=5>pause</FONT></TT><FONT SIZE=5>
cette primitive est le standard UNIX d'attente de la r&eacute;ception
d'un signal quelconque, BSD propose la primitive suivante&nbsp;: </FONT>
</P>
<PRE>
<FONT SIZE=5>sigpause(int sigmask)</FONT></PRE><P>
<FONT SIZE=5>appels syst&egrave;mes!sigpause@</FONT><TT><FONT SIZE=5>sigpause</FONT></TT><FONT SIZE=5>
qui permet l'attente d'un groupe sp&eacute;cifique de signaux,
attention les signaux du masque sont d&eacute;bloqu&eacute;s (c.f.
</FONT><TT><FONT SIZE=5>sigprocmask</FONT></TT><FONT SIZE=5>).<!--TOC section <FONT SIZE=5>La norme POSIX</FONT>--></FONT></P>
<H2><FONT SIZE=5>13.5&nbsp;&nbsp; La norme POSIX</FONT></H2>
<P><FONT SIZE=5><!--SEC END -->La norme POSIX ne d&eacute;finit pas
le comportement d'interruption des appels syst&egrave;mes, il faut le
sp&eacute;cifier dans la structure de traitement du signal.<!--TOC paragraph <FONT SIZE=5>Les ensembles de signaux</FONT>--></FONT></P>
<H5><FONT SIZE=5>Les ensembles de signaux</FONT></H5>
<P><FONT SIZE=5><!--SEC END -->La norme POSIX introduit les ensembles
de signaux&nbsp;:<BR>ces ensembles de signaux permettent de d&eacute;passer
la contrainte classique qui veut que le nombre de signaux soit
inf&eacute;rieur ou &eacute;gal au nombre de bits des entiers de la
machine. D'autre part, des fonctions de manipulation de ces ensembles
sont fournies et permettent de d&eacute;finir simplement des masques.
Ces ensembles de signaux sont du type sigset_t et sont manipulables
gr&acirc;ce aux fonctions suivantes&nbsp;:</FONT></P>
<PRE>
<FONT SIZE=5>int sigemptyset(sigset_t *ens)           /* raz */</FONT>
<FONT SIZE=5>int sigfillset(sigset_t *ens)            /* ens = { 1,2,...,NSIG} */</FONT>
<FONT SIZE=5>int sigaddset(sigset_t *ens, int sig)    /* ens = ens + {sig} */</FONT>
<FONT SIZE=5>int sigdelset(sigset_t *ens, int sig)     /* ens = ens - {sig } */</FONT></PRE><P>
<FONT SIZE=5>Ces fonctions retournent -1 en cas d'&eacute;chec et 0
sinon. </FONT>
</P>
<PRE>
<FONT SIZE=5>int sigismember(sigset_t *ens, int sig);   /* sig appartient &agrave; ens ?*/</FONT></PRE><P>
<FONT SIZE=5>retourne vrai si le signal appartient &agrave;
l'ensemble.<!--TOC subsection <FONT SIZE=5>Le blocage des signaux</FONT>--></FONT></P>
<H3><FONT SIZE=5>13.5.1&nbsp;&nbsp; Le blocage des signaux</FONT></H3>
<P><FONT SIZE=5><!--SEC END -->La fonction suivante permet de
manipuler le masque de signaux du processus&nbsp;: </FONT>
</P>
<PRE>
<FONT SIZE=5>#include &lt;signal.h&gt;</FONT>
<FONT SIZE=5>int sigprocmask(int op, const sigset_t  *nouv, sigset_t *anc);</FONT></PRE><P>
<FONT SIZE=5>appels syst&egrave;mes!sigprocmask@</FONT><TT><FONT SIZE=5>sigprocmask</FONT></TT><FONT SIZE=5>
<BR><BR>L'op&eacute;ration </FONT><TT><FONT SIZE=5>op</FONT></TT><FONT SIZE=5>&nbsp;:
</FONT>
</P>
<DL>
	<DT><FONT SIZE=5>SIG_SETMASK</FONT></DT><DD>
	<FONT SIZE=5>affectation du </FONT><TT><FONT SIZE=5>nouv</FONT></TT><FONT SIZE=5>eau
	masque, recup&eacute;ration de la valeur de l'</FONT><TT><FONT SIZE=5>anc</FONT></TT><FONT SIZE=5>ien
	masque. </FONT>
	</DD><DT>
	<FONT SIZE=5>SIG_BLOCK</FONT></DT><DD>
	<FONT SIZE=5>union des deux ensembles </FONT><TT><FONT SIZE=5>nouv</FONT></TT><FONT SIZE=5>
	et </FONT><TT><FONT SIZE=5>anc</FONT></TT><FONT SIZE=5> </FONT>
	</DD><DT>
	<FONT SIZE=5>SIG_UNBLOCK</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>soustraction </FONT><TT><FONT SIZE=5>anc</FONT></TT><FONT SIZE=5>
	- </FONT><TT><FONT SIZE=5>nouv</FONT></TT><FONT SIZE=5> </FONT>
	</DD></DL>
<P>
<FONT SIZE=5>On peut savoir si un signal est </FONT><EM><FONT SIZE=5>pendant</FONT></EM><FONT SIZE=5>
et donc </FONT><EM><FONT SIZE=5>bloqu&eacute;</FONT></EM><FONT SIZE=5>
gr&acirc;ce &agrave; la fonction&nbsp;: </FONT>
</P>
<PRE>
<FONT SIZE=5>int sigpending(sigset_t *ens);</FONT></PRE><P>
<FONT SIZE=5>retourne -1 en cas d'&eacute;chec et 0 sinon et
l'ensemble des signaux pendants est stock&eacute; &agrave; l'adresse
</FONT><TT><FONT SIZE=5>ens</FONT></TT><FONT SIZE=5>.<!--TOC subsection <FONT SIZE=5>sigaction</FONT>--></FONT></P>
<H3><FONT SIZE=5>13.5.2&nbsp;&nbsp; sigaction</FONT></H3>
<P><!--SEC END --><FONT SIZE=5>La structure </FONT><TT><FONT SIZE=5>sigaction</FONT></TT><FONT SIZE=5>
d&eacute;crit le comportement utilis&eacute; pour le traitement d'un
signal&nbsp;: </FONT>
</P>
<PRE>
<FONT SIZE=5>struct sigaction { </FONT>
<FONT SIZE=5>        void (*sa_handler) ();  </FONT>
<FONT SIZE=5>        sigset_t sa_mask;</FONT>
<FONT SIZE=5>        int sa_flags;}</FONT></PRE><P>
<FONT SIZE=5>appels syst&egrave;mes!sigaction@</FONT><TT><FONT SIZE=5>sigaction</FONT></TT><FONT SIZE=5>
</FONT>
</P>
<DL>
	<DT><FONT SIZE=5>sa_handler</FONT></DT><DD>
	<FONT SIZE=5>fonction de traitement (ou </FONT><TT><FONT SIZE=5>SIG_DFL</FONT></TT><FONT SIZE=5>
	et </FONT><TT><FONT SIZE=5>SIG_IGN</FONT></TT><FONT SIZE=5>) </FONT>
	</DD><DT>
	<FONT SIZE=5>sa_mask</FONT></DT><DD>
	<FONT SIZE=5>ensemble de signaux suppl&eacute;mentaires &agrave;
	bloquer pendant le traitement </FONT>
	</DD><DT>
	<FONT SIZE=5>sa_flags</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>diff&eacute;rentes options </FONT>
	</DD><DL>
		<DT STYLE="margin-right: 1cm; margin-bottom: 0.5cm">
		<FONT SIZE=5>SA_NOCLDSTOP</FONT></DT><DD STYLE="margin-right: 1cm; margin-bottom: 0.5cm">
		<FONT SIZE=5>le signal SIGCHLD n'est pas envoy&eacute; &agrave; un
		processus lorsque l'un de ses fils est stopp&eacute;. </FONT>
		</DD><DT STYLE="margin-right: 1cm; margin-bottom: 0.5cm">
		<FONT SIZE=5>SA_RESETHAND</FONT></DT><DD STYLE="margin-right: 1cm; margin-bottom: 0.5cm">
		<FONT SIZE=5>simulation de l'ancienne m&eacute;thode de gestion des
		signaux, pas de blocage du signal pendant le handler et
		repositionnement du handler par d&eacute;faut au lancement du
		handler. </FONT>
		</DD><DT STYLE="margin-right: 1cm; margin-bottom: 0.5cm">
		<FONT SIZE=5>SA_RESTART</FONT></DT><DD STYLE="margin-right: 1cm; margin-bottom: 0.5cm">
		<FONT SIZE=5>les appels syst&egrave;me interrompus par un signal
		capt&eacute; sont relanc&eacute;s au lieu de renvoyer -1. Cet
		indicateur joue le r&ocirc;le de l'appel </FONT><TT><FONT SIZE=5>siginterrupt(sig,0)</FONT></TT><FONT SIZE=5>
		des versions BSD. </FONT>
		</DD><DT STYLE="margin-right: 1cm; margin-bottom: 0.5cm">
		<FONT SIZE=5>SA_NOCLDWAIT</FONT></DT><DD STYLE="margin-right: 1cm; margin-bottom: 0.5cm">
		<FONT SIZE=5>si le signal est SIGCHLD, ses fils qui se terminent ne
		deviennent pas zombis. Cet indicateur correspond au comportement
		des processus pour SIG_IGN dans les versions ATT. </FONT>
		</DD></DL>
</DL>
<P>
<FONT SIZE=5>Le positionnement du comportement de reception d'un
signal se fait par la primitive </FONT><TT><FONT SIZE=5>sigaction</FONT></TT><FONT SIZE=5>.<BR>L'installation
d'une fonction de traitement du signal SIGCHLD peut avoir pour effet
d'envoyer un signal au processus, ceci dans le cas o&ugrave; le
processus a des fils zombis, c'est toujours le probl&egrave;me li&eacute;
&agrave; ce signal qui n'a pas le m&ecirc;me comportement que les
autres signaux.<BR>Un handler positionn&eacute; par </FONT><TT><FONT SIZE=5>sigaction</FONT></TT><FONT SIZE=5>
reste jusqu'&agrave; ce qu'un autre handler soit positionn&eacute;, &agrave;
la diff&eacute;rence des versions ATT o&ugrave; le handler par d&eacute;faut
est repositionn&eacute; automatiquement au d&eacute;but du traitement
du signal.</FONT></P>
<PRE>
<FONT SIZE=5>        #include &lt;signal.h&gt;</FONT>
<FONT SIZE=5>        int sigaction(int sig,</FONT>
<FONT SIZE=5>                      const struct sigaction *paction,</FONT>
<FONT SIZE=5>                      struct sigaction       *paction_precedente);</FONT></PRE><P>
<FONT SIZE=5>appels syst&egrave;mes!sigaction@</FONT><TT><FONT SIZE=5>sigaction</FONT></TT><FONT SIZE=5>
Cette fonction r&eacute;alise soit une demande d'information. Si le
pointeur </FONT><TT><FONT SIZE=5>paction</FONT></TT><FONT SIZE=5> est
null, on obtient la structure </FONT><TT><FONT SIZE=5>sigaction</FONT></TT><FONT SIZE=5>
courante. Sinon c'est une demande de modification du comportement.<!--TOC subsection <FONT SIZE=5>L'attente d'un signal</FONT>--></FONT></P>
<H3><FONT SIZE=5>13.5.3&nbsp;&nbsp; L'attente d'un signal</FONT></H3>
<P><!--SEC END --><FONT SIZE=5>appels syst&egrave;mes!pause@</FONT><TT><FONT SIZE=5>pause</FONT></TT><FONT SIZE=5>
En plus de l'appel </FONT><TT><FONT SIZE=5>pause</FONT></TT><FONT SIZE=5>,
on trouve sous POSIX l'appel </FONT><TT><FONT SIZE=5>int
sigsuspend(const sigset_t *ens);</FONT></TT><FONT SIZE=5> qui permet
de r&eacute;aliser de fa&ccedil;ons </FONT><TT><FONT SIZE=5>atomique</FONT></TT><FONT SIZE=5>
les actions suivantes&nbsp;: </FONT>
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>l'installation du
	masque de blocage d&eacute;fini par </FONT><TT><FONT SIZE=5>ens</FONT></TT><FONT SIZE=5>
	(qui sera repositionn&eacute; &agrave; sa valeur d'origine) &agrave;
	la fin de l'appel, </FONT>
	</P>
	<LI><P><FONT SIZE=5>mise en attente de la r&eacute;ception d'un
	signal non bloqu&eacute;. </FONT>
	</P>
</UL>
<H1><FONT SIZE=5><!--TOC chapter <FONT SIZE=5>Les verrous de fichiers</FONT>-->Chapitre&nbsp;14&nbsp;&nbsp;
Les verrous de fichiers</FONT></H1>
<P><!--SEC END --><FONT SIZE=5>M&eacute;canismes de contr&ocirc;le
d'acc&egrave;s concurrents &agrave; un fichier, les verrous sont
d'une grande utilit&eacute; dans les applications de gestion et dans
l'&eacute;laboration de bases de donn&eacute;es partag&eacute;es.<BR>Les
verrous sont rattach&eacute;s aux <B>inoeuds</B>. Ainsi toutes les
ouvertures d'un m&ecirc;me fichier, et &agrave; fortiori tous les
descripteurs sur ces ouvertures, &quot;voient&quot; le verrou.<BR>La
protection r&eacute;alis&eacute;e par le verrou a donc lieu sur le
fichier physique.<BR>Un verrou est la <B>propri&eacute;t&eacute;</B>
d'un seul <B>processus</B>, et seul le processus propri&eacute;taire
du verrou peut le modifier ou l'enlever, attention le verrou ne
prot&egrave;ge pas contre les acc&egrave;s du processus propri&eacute;taire
(attention &agrave; une situation multi-thread).<!--TOC section <FONT SIZE=5>Caractéristiques d'un verrou</FONT>--></FONT></P>
<H2><FONT SIZE=5>14.1&nbsp;&nbsp; Caract&eacute;ristiques d'un verrou</FONT></H2>
<P STYLE="margin-bottom: 0cm"><!--SEC END --><FONT SIZE=5>Les verrous
sont d&eacute;finis par deux caract&eacute;ristiques&nbsp;:<BR></FONT><TT><B><FONT SIZE=5>La
port&eacute;e</FONT></B></TT><FONT SIZE=5>&nbsp;: Ensemble des
positions du fichier auxquelles le verrou s'applique. Cet ensemble
est un intervalle, soit une portion du fichier</FONT></P>
<P ALIGN=CENTER STYLE="margin-bottom: 0cm"><TT><FONT SIZE=5>[position1,
position2] </FONT></TT>
</P>
<P STYLE="margin-bottom: 0cm"><FONT SIZE=5><BR>soit jusqu'&agrave; la
fin du fichier </FONT>
</P>
<P ALIGN=CENTER STYLE="margin-bottom: 0cm"><TT><FONT SIZE=5>[position1,
fin de fichier[</FONT></TT></P>
<P><FONT SIZE=5><BR>dans ce dernier cas si le fichier augmente, le
verrou prot&egrave;ge les nouvelles positions.<BR></FONT><TT><B><FONT SIZE=5>Le
type</FONT></B></TT><FONT SIZE=5>&nbsp;: qui d&eacute;crit les
possibilit&eacute;s de cohabitation des diff&eacute;rents verrous.</FONT></P>
<DL>
	<DT><FONT SIZE=5>F_RDLCK</FONT></DT><DD>
	<FONT SIZE=5>partag&eacute;, plusieurs verrous de ce type peuvent
	avoir des port&eacute;es non disjointes, par exemple les verrous
	[80,150] et [100,123] </FONT>
	</DD><DT>
	<FONT SIZE=5>F_WRLCK</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>exclusif, pas de cohabitation possible avec un autre
	verrou quelque soit son type. </FONT>
	</DD></DL>
<H2>
<FONT SIZE=5><!--TOC section <FONT SIZE=5>Le mode opératoire des verrous</FONT>-->14.2&nbsp;&nbsp;
Le mode op&eacute;ratoire des verrous</FONT></H2>
<P><!--SEC END --><FONT SIZE=5>Le mode op&eacute;ratoire joue sur le
comportement des primitives </FONT><TT><FONT SIZE=5>read</FONT></TT><FONT SIZE=5>
et </FONT><TT><FONT SIZE=5>write</FONT></TT><FONT SIZE=5>. Les
verrous d'un fichier sont soit <B>consultatifs</B>, soit
<B>imp&eacute;ratifs</B>.<BR>Dans le premier mode <B>advisory</B>
(consultatif), la pr&eacute;sence d'un verrou n'est test&eacute;e
qu'&agrave; la pose d'un verrou, la pose sera refus&eacute;e s'il
existe un verrou de port&eacute;e non disjointe et que l'un des deux
verrous est exclusif.<BR>Dans le second mode <B>mandatory</B>, la
pr&eacute;sence de verrous est test&eacute;e pour la pose mais aussi
pour les appels syst&egrave;mes </FONT><TT><FONT SIZE=5>read</FONT></TT><FONT SIZE=5>
et </FONT><TT><FONT SIZE=5>write</FONT></TT><FONT SIZE=5>. <BR>Dans
le mode consultatif, les verrous n'ont d'effet que sur les processus
jouant effectivement le jeu, c'est-&agrave;-dire, posant des verrous
sur les zones du fichiers sur lesquels ils veulent r&eacute;aliser
une lecture (verrou partag&eacute;) ou une &eacute;criture (verrou
exclusif).<BR>Dans le mode imp&eacute;ratif, les verrous ont un
impact sur les lectures/&eacute;critures de tous les processus&nbsp;:
</FONT>
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>sur les verrous de
	type partag&eacute; (F_RDLCK), toute tentative d'&eacute;criture par
	un autre processus est bloqu&eacute;e; </FONT>
	</P>
	<LI><P><FONT SIZE=5>sur les verrous de type exclusif (F_WRLCK),
	toute tentative de lecture ou d'&eacute;criture par un autre
	processus est bloqu&eacute;e. </FONT>
	</P>
</UL>
<H2><FONT SIZE=5><!--TOC section <FONT SIZE=5>Manipulation des verrous</FONT>-->14.3&nbsp;&nbsp;
Manipulation des verrous</FONT></H2>
<P><!--SEC END --><FONT SIZE=5>La structure de verrou </FONT><TT><FONT SIZE=5>flock</FONT></TT><FONT SIZE=5>&nbsp;:
</FONT>
</P>
<PRE>
<FONT SIZE=5>struct flock  {          </FONT>
<FONT SIZE=5>      short    l_type;      /* F_RDLCK, F_WRLCK,F_UNLCK */</FONT>
<FONT SIZE=5>      short    l_whence;    /* SEEK_SET,SEEK_CUR,SEEK_END */</FONT>
<FONT SIZE=5>      off_t    l_start;     /* position relative a l_whence */</FONT>
<FONT SIZE=5>      off_t    l_len;       /* longueur de l'intervalle */</FONT>
<FONT SIZE=5>      pid_t    l_pid;       /* PID du processus propri&eacute;taire */</FONT>
<FONT SIZE=5>};</FONT></PRE><P>
<FONT SIZE=5>le champ </FONT><TT><FONT SIZE=5>l_type </FONT></TT>
</P>
<DL>
	<DT><FONT SIZE=5>F_RDLCK</FONT></DT><DD>
	<FONT SIZE=5>verrou partag&eacute; </FONT>
	</DD><DT>
	<FONT SIZE=5>F_WRLCK</FONT></DT><DD>
	<FONT SIZE=5>verrou exclusif </FONT>
	</DD><DT>
	<FONT SIZE=5>F_UNLCK</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>d&eacute;verrouillage </FONT>
	</DD></DL>
<P>
<FONT SIZE=5>Les manipulations de verrous se font avec la primitive
</FONT><TT><FONT SIZE=5>fcntl</FONT></TT><FONT SIZE=5>, c'est-&agrave;-dire
par le biais d'un descripteur. Pour poser un verrou partag&eacute;,
ce descripteur doit pointer sur une ouverture en lecture. De m&ecirc;me,
il faut un descripteur sur une ouverture en &eacute;criture pour un
verrou de type exclusif<BR>.<BR><BR>Pour d&eacute;crire la port&eacute;e
du verrou que l'on veut poser, on utilise la m&ecirc;me syntaxe que
pour la primitive </FONT><TT><FONT SIZE=5>lseek</FONT></TT><FONT SIZE=5>,
le d&eacute;but de l'intervalle est <B>whence+l_start</B>&nbsp;:<BR></FONT><TT><FONT SIZE=5>l_whence</FONT></TT><FONT SIZE=5>
= SEEK_SET <FONT FACE="symbol">&frac34;&reg;</FONT> whence =
0<BR></FONT><TT><FONT SIZE=5>l_whence</FONT></TT><FONT SIZE=5> =
SEEK_CUR <FONT FACE="symbol">&frac34;&reg;</FONT> whence = offset
courrant<BR></FONT><TT><FONT SIZE=5>l_whence</FONT></TT><FONT SIZE=5>
= SEEK_END <FONT FACE="symbol">&frac34;&reg;</FONT> whence = taille
du fichier.<BR>La longueur du verrou est d&eacute;finie par le champ
</FONT><TT><FONT SIZE=5>l_len</FONT></TT><FONT SIZE=5>. Si cette
valeur est nulle, le verrou va jusqu'&agrave; la fin du fichier (m&ecirc;me
si le processus change cette fin). Remarque&nbsp;: il est possible de
poser un verrou dont la port&eacute;e est sup&eacute;rieure &agrave;
la taille du fichier.<BR>Le champ </FONT><TT><FONT SIZE=5>l_pid</FONT></TT><FONT SIZE=5>
contient le pid du processus propri&eacute;taire du verrou, ce champ
est rempli par </FONT><TT><FONT SIZE=5>fcntl</FONT></TT><FONT SIZE=5>
dans le cas d'un appel consultatif (</FONT><TT><FONT SIZE=5>F_GETLK</FONT></TT><FONT SIZE=5>).<!--TOC section <FONT SIZE=5>Utilisation de </FONT><FONT SIZE=5><TT>fcntl</TT></FONT><FONT SIZE=5> pour manipuler les verrous</FONT>--></FONT></P>
<H2>14.4&nbsp;&nbsp; Utilisation de <TT>fcntl</TT> pour manipuler les
verrous</H2>
<PRE><!--SEC END -->
<FONT SIZE=5>         #include &lt;sys/types.h&gt;</FONT>
<FONT SIZE=5>         #include &lt;unistd.h&gt;</FONT>
<FONT SIZE=5>         #include &lt;fcntl.h&gt;</FONT>
<FONT SIZE=5>         int fcntl(int desc, int commande, struct flock *verrou);</FONT></PRE><P>
<TT><FONT SIZE=5>fcntl</FONT></TT><FONT SIZE=5> retourne 0 en cas de
succ&egrave;s, ou -1 en cas d'echec.<BR>Trois commandes possibles&nbsp;:
</FONT>
</P>
<DL>
	<DT><FONT SIZE=5>F_SETLKW</FONT></DT><DD>
	<FONT SIZE=5>pose bloquante (Wait) si il existe un verrou
	incompatible, </FONT><TT><FONT SIZE=5>errno</FONT></TT><FONT SIZE=5>
	a pour valeur EAGAIN si l'on n'a pas les droits d'acc&egrave;s sur
	le fichier pour le type de verrou demand&eacute;, alors </FONT><TT><FONT SIZE=5>errno</FONT></TT><FONT SIZE=5>
	a pour valeur EACCES; si la pose du verrou cr&eacute;e une situation
	d'interblocage, alors </FONT><TT><FONT SIZE=5>errno</FONT></TT><FONT SIZE=5>
	a pour valeur EDEADLK. </FONT>
	</DD><DT>
	<FONT SIZE=5>F_SETLK</FONT></DT><DD>
	<FONT SIZE=5>pose non bloquante succ&egrave;s imm&eacute;diat si il
	n'y a pas de verrou incompatible, ou une fois les verrous
	incompatibles lev&eacute;s. si l'appel est interrompu, </FONT><TT><FONT SIZE=5>errno</FONT></TT><FONT SIZE=5>
	a pour valeur EINTR si une situation d'interblocage est d&eacute;tect&eacute;e,
	alors </FONT><TT><FONT SIZE=5>errno</FONT></TT><FONT SIZE=5> a pour
	valeur EDEADLK. </FONT>
	</DD><DT>
	<FONT SIZE=5>F_GETLK</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>Test d'existence d'un verrou incompatible avec le
	verrou pass&eacute; en param&egrave;tre (retour -1 sur des
	param&egrave;tres incorrects) si il existe un tel verrou
	incompatible, alors la structure flock pass&eacute;e en param&egrave;tre
	est remplie avec les valeurs de ce verrou incompatible. Le champ
	</FONT><TT><FONT SIZE=5>l_pid</FONT></TT><FONT SIZE=5> indique alors
	l'identit&eacute; du processus propri&eacute;taire de ce verrou
	incompatible. sinon, la structure flock reste inchang&eacute;e
	except&eacute; le champ type qui contient F_UNLCK.</FONT></DD></DL>
<P>
<FONT SIZE=5>Attention, apr&egrave;s un test d'existence qui nous
informe de l'absence de verrou incompatible, nous ne sommes pas
assur&eacute; qu'au prochain appel la pose de ce verrou soit
possible, en effet un autre processus a peut-&ecirc;tre pos&eacute;
un verrou incompatible entre-temps (cf. interblocages chapitre </FONT><A HREF="#interblocages"><FONT SIZE=5>15</FONT></A><FONT SIZE=5>).<!--TOC chapter <FONT SIZE=5>Algorithmes Distribués &amp; Interblocages</FONT>--></FONT></P>
<H1><FONT SIZE=5>Chapitre&nbsp;15&nbsp;&nbsp; Algorithmes Distribu&eacute;s
&amp; Interblocages</FONT></H1>
<P><A NAME="interblocages"></A><FONT SIZE=5><!--SEC END -->Ce
chapitre introduit les probl&egrave;mes li&eacute;s &agrave; la
gestion de processus concurrents. Le probl&egrave;me &agrave;
resoudre est le partage de ressources entre diff&eacute;rents
processus asynchrones. Les I.P.C. et les verrous sont deux types
d'outils permettant le partage asynchrone de ressources entre
processus. <BR>Prenons un exemple simple pour d&eacute;crire les
probl&egrave;mes de partages.<BR><BR><BR>Probl&egrave;me&nbsp;: il y
a une rivi&egrave;re que l'on peut traverser par un gu&eacute; fait
de pierre align&eacute;es, o&ugrave; il n'est pas possible de se
croiser, et il n'est pas possible de faire demi-tour. Comment
doit-t-on organiser le passage ?<BR>Solutions&nbsp;: </FONT>
</P>
<OL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>regarder avant de
	traverser </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>si deux personnes
	arrivent en m&ecirc;me temps sur chaque rive, si elles avancent en
	m&ecirc;me temps <FONT FACE="symbol">&frac34;&reg;</FONT>
	interblocage si elles attendent en m&ecirc;me temps <FONT FACE="symbol">&frac34;&reg;</FONT>
	interblocage </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Un rem&egrave;de&nbsp;:
	un c&ocirc;t&eacute; prioritaire <FONT FACE="symbol">&frac34;&reg;</FONT>
	famine. En effet si le cot&eacute; OUEST est prioritaire et qu'un
	flot continu de personnes arrive de ce c&ocirc;t&eacute;, les
	personnes &agrave; l'EST sont bloqu&eacute;es ind&eacute;finiment. </FONT>
	</P>
	<LI><P><FONT SIZE=5>Une solution&nbsp;: alterner les priorit&eacute;s.
	</FONT>
	</P>
</OL>
<P><FONT SIZE=5>Pour des ressources syst&egrave;me comme les
fichiers, le partage n'est pas g&eacute;r&eacute; par le SGF. Il faut
donc un m&eacute;canisme de partage &nbsp;: les verrous, qui
permettent un partage dynamique et partiel (portions de fichiers).
Pour un partage entre utilisateurs, on utilise plut&ocirc;t des
outils comme </FONT><TT><FONT SIZE=5>SCCS, RCS</FONT></TT><FONT SIZE=5>.<!--TOC subsection <FONT SIZE=5>Mode d'utilisation des ressources par un processus.</FONT>--></FONT></P>
<H3><FONT SIZE=5>15.0.1&nbsp;&nbsp; Mode d'utilisation des ressources
par un processus.</FONT></H3>
<P><FONT SIZE=5><!--SEC END -->Formalisons les op&eacute;rations
r&eacute;alisables sur une ressource. </FONT>
</P>
<UL>
	<LI><P><FONT SIZE=5>requ&ecirc;te&nbsp;: demande bloquante de
	ressources</FONT></P>
	<LI><P><FONT SIZE=5>utilisation&nbsp;: lecture/&eacute;criture sur
	la zone verrouill&eacute;e</FONT></P>
	<LI><P><FONT SIZE=5>lib&eacute;ration&nbsp;: verrou L-type </FONT>
	</P>
</UL>
<H3><FONT SIZE=5><!--TOC subsection <FONT SIZE=5>Définition de l'interblocage (deadlock)</FONT>-->15.0.2&nbsp;&nbsp;
D&eacute;finition de l'interblocage (deadlock)</FONT></H3>
<P><!--SEC END --><FONT SIZE=5>Un ensemble de processus est en
<B>interblocage</B> si et seulement si tout processus de l'ensemble
est en attente d'un &eacute;v&egrave;nement qui ne peut &ecirc;tre
r&eacute;alis&eacute; que par un autre processus de
l'ensemble.<BR>Exemple&nbsp;:<BR>Le processus A poss&egrave;de un
verrou de port&eacute;e [0,400] sur un fichier f, et demande un
verrou de port&eacute;e [800,1000] sur ce m&ecirc;me fichier, alors
qu'un processus B poss&egrave;de un verrou de port&eacute;e [600,900]
sur le fichier f et demande un verrou de port&eacute;e [0,33] sur f.
Les deux processus sont en interblocage. Dans le cas de la pose de
verrous sous UNIX, il y a d&eacute;tection de cet interblocage et la
commande </FONT><TT><FONT SIZE=5>fcntl</FONT></TT><FONT SIZE=5>
&eacute;choue.<!--TOC subsection <FONT SIZE=5>Quatre conditions nécessaires à l'interblocage.</FONT>--></FONT></P>
<H3><FONT SIZE=5>15.0.3&nbsp;&nbsp; Quatre conditions n&eacute;cessaires
&agrave; l'interblocage.</FONT></H3>
<P><!--SEC END --><FONT SIZE=5>Les conditions suivantes sont
<B>n&eacute;cessaires</B> pour avoir une possibilit&eacute;
d'interblocage.</FONT></P>
<DL>
	<DT><FONT SIZE=5>Exclusion mutuelle</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>les ressources ne sont pas partageables, un seul
	processus &agrave; la fois peut utiliser la ressource.</FONT></DD><DT>
	<FONT SIZE=5>Possession &amp; attente</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>il doit exister un processus qui utilise une ressource
	et qui est en attente sur une requ&ecirc;te.</FONT></DD><DT>
	<FONT SIZE=5>Sans pr&eacute;emption</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>les ressources ne sont pas pr&eacute;emptibles
	c'est-&agrave;-dire que les lib&eacute;rations sont faites
	volontairement par les processus. On ne peut pas forcer un processus
	&agrave; rendre une ressource. (Contre exemple : le CPU sous Unix
	est pr&eacute;emptible)</FONT></DD><DT>
	<FONT SIZE=5>Attente circulaire</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>il doit exister un ensemble de processus <I>P</I></FONT><I><FONT SIZE=4><SUB>i</SUB></FONT></I><FONT SIZE=5>
	tel que <I>P</I></FONT><I><FONT SIZE=4><SUB>i</SUB></FONT></I><FONT SIZE=5>
	attend une ressource poss&eacute;d&eacute;e par <I>P</I></FONT><I><FONT SIZE=4><SUB>i</SUB></FONT></I><FONT SIZE=4><SUB>+1</SUB></FONT><FONT SIZE=5>.</FONT></DD></DL>
<P>
<FONT SIZE=5>Les quatre conditions sont n&eacute;cessaires pour
qu'une situation d'interblocage ait lieu.<BR>Exercice&nbsp;: montrer
que pour les verrous, les quatre conditions tiennent.<BR>Exercice&nbsp;:
montrer que si l'une des condition n'est pas v&eacute;rifi&eacute;e
alors il ne peut y avoir d'interblocage.<!--TOC subsection <FONT SIZE=5>Les graphes d'allocation de ressources</FONT>--></FONT></P>
<H3><FONT SIZE=5>15.0.4&nbsp;&nbsp; Les graphes d'allocation de
ressources</FONT></H3>
<P><!--SEC END --><FONT SIZE=5>Les graphes d'allocation de ressources
permettent de d&eacute;crire simplement les probl&egrave;mes
d'interblocage.<BR><BR></FONT><CODE><FONT SIZE=5>G = (N,T) N = P U
R</FONT></CODE><FONT SIZE=5><BR>P : ensemble des processus<BR>R :
ensemble des ressources<BR>T est inclus dans RXP U PXR <BR>Soit le
couple (x,y) appartenant &agrave; T,<BR>si (x,y) appartient &agrave;
RXP, cela signifie que la ressource x est utilis&eacute;e par le
processus y.<BR>si (x,y) appartient &agrave; PXR, cela signifie que
le processus x demande la ressource y.<BR><!--TOC chapter <FONT SIZE=5> Inter Processus Communications (I.P.C.)</FONT>--></FONT><BR><BR>
</P>
<H1><FONT SIZE=5>Chapitre&nbsp;16&nbsp;&nbsp; Inter Processus
Communications (I.P.C.)</FONT></H1>
<P><A NAME="IPC"></A><FONT SIZE=5><!--SEC END -->Les m&eacute;canismes
d'IPC permettent de faire communiquer et/ou de synchroniser n'importe
quel couple de processus locaux (de la m&ecirc;me machine).<BR>Les
trois m&eacute;canismes d'IPC : files de messages, segments de
m&eacute;moire partag&eacute;e, s&eacute;maphores, sont purement
m&eacute;moire. Ils n'ont pas de liens avec le syst&egrave;me de
fichiers, ce qui les sort de la philosophie UNIX. <BR>Ces m&eacute;canismes
ne sont plus d&eacute;sign&eacute;s localement dans les processus par
des descripteurs standards, et de ce fait il n'est plus possible
d'utiliser les m&eacute;canismes de lecture et d'&eacute;criture
standards sur de tels objets.<BR>Le syst&egrave;me prend en charge la
gestion de ces objets. C'est lui qui tient &agrave; jour les tables
qui les contiennent.<!--TOC section <FONT SIZE=5>Références d'IPC</FONT>--></FONT></P>
<H2><FONT SIZE=5>16.1&nbsp;&nbsp; R&eacute;f&eacute;rences d'IPC</FONT></H2>
<P><!--SEC END --><FONT SIZE=5>Les objets sont r&eacute;f&eacute;renc&eacute;s
par deux noms : le num&eacute;ro d'identification dans le processus,
qui est retourn&eacute; par les fonctions get : </FONT><TT><FONT SIZE=5>msgget,
semget, shmget</FONT></TT><FONT SIZE=5>.<BR><BR>Nous appellerons par
la suite </FONT><TT><FONT SIZE=5>dipc</FONT></TT><FONT SIZE=5> ce
descripteur d'IPC. L'autre r&eacute;f&eacute;rence de l'IPC est la
cl&eacute; (</FONT><TT><FONT SIZE=5>key</FONT></TT><FONT SIZE=5>) qui
est utilis&eacute;e dans l'appel de la fonction </FONT><TT><FONT SIZE=5>get</FONT></TT><FONT SIZE=5>
pour identifier l'objet IPC (du syst&egrave;me) auquel on cherche &agrave;
acc&eacute;der.<BR><BR>La cl&eacute; permet &agrave; plusieurs
processus d'acc&eacute;der au m&ecirc;me objet IPC (ce qui est
fondamental). Mais ce syst&egrave;me de cl&eacute; est d'une gestion
d&eacute;licate, et pose des probl&egrave;mes.<BR><BR>Comme les cl&eacute;s
sont arbitraires (un entier long de la machine H&ocirc;te), des
probl&egrave;mes de droits et de choix de la cl&eacute; se
posent.<BR><BR>Il n'est pas assur&eacute; &agrave; un syst&egrave;me
client/serveur qui d&eacute;marre que sa cl&eacute; priv&eacute;e
n'est pas d&eacute;j&agrave; utilis&eacute;e par un autre processus !
Comme le client et le serveur doivent avoir la m&ecirc;me cl&eacute;,
des complications surviennent.<!--TOC subsection <FONT SIZE=5>Création de clés</FONT>--></FONT></P>
<H3><FONT SIZE=5>16.1.1&nbsp;&nbsp; Cr&eacute;ation de cl&eacute;s</FONT></H3>
<P><!--SEC END --><FONT SIZE=5>Pour r&eacute;soudre ce probl&egrave;me,
une fonction de cr&eacute;ation automatique de cl&eacute; a &eacute;t&eacute;
mise au point. Cette fonction </FONT><TT><FONT SIZE=5>ftock()</FONT></TT><FONT SIZE=5>
utilise une r&eacute;f&eacute;rence de l'arborescence pour cr&eacute;er
une cl&eacute; unique.</FONT></P>
<PRE>
<FONT SIZE=5>key_t ftok(const char *, char);</FONT></PRE><P>
<FONT SIZE=5>Si tout le monde utilise de telles cl&eacute;s, le
probl&egrave;me soulev&eacute; pr&eacute;c&eacute;demment
disparait.<BR><BR>Malheureusement, cette fonction </FONT><TT><FONT SIZE=5>ftock</FONT></TT><FONT SIZE=5>
utilise pour cr&eacute;er une cl&eacute; le num&eacute;ro de disque
logique et d'inode de la r&eacute;f&eacute;rence donn&eacute;e en
param&egrave;tre (il faut que la r&eacute;f&eacute;rence pass&eacute;e
en param&egrave;tre &agrave; </FONT><TT><FONT SIZE=5>ftock</FONT></TT><FONT SIZE=5>
existe, sinon </FONT><TT><FONT SIZE=5>ftock</FONT></TT><FONT SIZE=5>
renvoie -1). <BR><BR>Ceci pose un autre type de probl&egrave;me : si
l'on change l'inode associ&eacute;e &agrave; la r&eacute;f&eacute;rence,
cela change la valeur de la cl&eacute;, donc il n'est plus possible
de retrouver la cl&eacute; originale.<BR><BR>Le conseil de tonton
Doum&eacute; : utiliser un fichier verrouill&eacute; comme r&eacute;f&eacute;rence
et faire le m&eacute;nage ... comme pour les pseudo-terminaux, ou les
tubes.<!--TOC subsection <FONT SIZE=5>La structure ipc_perm</FONT>--></FONT></P>
<H3><FONT SIZE=5>16.1.2&nbsp;&nbsp; La structure ipc_perm</FONT></H3>
<P><!--SEC END --><FONT SIZE=5>La structure </FONT><TT><FONT SIZE=5>ipc_perm</FONT></TT><FONT SIZE=5>
est commune aux trois m&eacute;canismes d'ipc. Elle permet, comme le
fait une inode, de stocker l'utilisateur cr&eacute;ateur,
l'utilisateur propri&eacute;taire ainsi que leurs groupes. On
diff&eacute;rencie pour les IPC, l'utilisateur cr&eacute;ateur (qui a
r&eacute;alis&eacute; la fonction get) du propri&eacute;taire de
l'IPC. Les droits d'acc&egrave;s sont limit&eacute;s &agrave; la
lecture et l'&eacute;criture (l'ex&eacute;cution n'ayant pas de sens
...).<BR><BR>La structure </FONT><TT><FONT SIZE=5>ipc_perm</FONT></TT><FONT SIZE=5>
et les droits d'acc&egrave;s &agrave; un objet IPC &nbsp;: </FONT>
</P>
<PRE>
<FONT SIZE=5>     typedef long key_t;    /* for ftok() function */</FONT>
<FONT SIZE=5>     typedef long uid_t;    /* Used for user IDs */</FONT>
<FONT SIZE=5>     typedef long gid_t;    /* Used for group IDs */</FONT>

<FONT SIZE=5> /* Common IPC Access Structure */</FONT>
<FONT SIZE=5>   struct ipc_perm {</FONT>
<FONT SIZE=5>        uid_t           uid;    /* owner's user id */</FONT>
<FONT SIZE=5>        gid_t           gid;    /* owner's group id */</FONT>
<FONT SIZE=5>        uid_t           cuid;   /* creator's user id */</FONT>
<FONT SIZE=5>        gid_t           cgid;   /* creator's group id */</FONT>
<FONT SIZE=5>        unsigned short  mode;   /* access modes */</FONT>
<FONT SIZE=5>        unsigned short  seq;    /* slot usage sequence number */</FONT>
<FONT SIZE=5>        key_t           key;    /* key */</FONT>
<FONT SIZE=5>   };</FONT></PRE><H3>
<FONT SIZE=5><!--TOC subsection <FONT SIZE=5>Les options de la structure ipc_perm</FONT>-->16.1.3&nbsp;&nbsp;
Les options de la structure ipc_perm</FONT></H3>
<PRE><!--SEC END -->
<FONT SIZE=5>#  define  IPC_CREAT   0001000     /* create entry if key doesn't exist */</FONT>
<FONT SIZE=5>#  define  IPC_EXCL    0002000     /* fail if key exists */</FONT>
<FONT SIZE=5>#  define  IPC_NOWAIT  0004000     /* error if request must wait */</FONT>

<FONT SIZE=5>   /* Keys. */</FONT>
<FONT SIZE=5>#  define  IPC_PRIVATE  (key_t)0    /* private key */</FONT>

<FONT SIZE=5>   /* Control Commands. */</FONT>
<FONT SIZE=5>#  define  IPC_RMID    0           /* remove identifier */</FONT>
<FONT SIZE=5>#  define  IPC_SET     1           /* set options */</FONT>
<FONT SIZE=5>#  define  IPC_STAT    2           /* get options */</FONT>

<FONT SIZE=5>  /* Common IPC Definitions. */</FONT>
<FONT SIZE=5>   /* Mode bits. */</FONT>
<FONT SIZE=5>#  define  IPC_ALLOC   0100000     /* entry currently allocated */</FONT>
<FONT SIZE=5>#  define  IPC_LOCKED  0040000     /* structure is locked */</FONT>
<FONT SIZE=5>#  define  IPC_WANTED  0004000     /* process waiting for lock *</FONT></PRE><H3>
<FONT SIZE=5><!--TOC subsection <FONT SIZE=5>L'accès aux tables d'IPC par le shell</FONT>-->16.1.4&nbsp;&nbsp;
L'acc&egrave;s aux tables d'IPC par le shell</FONT></H3>
<P><!--SEC END --><FONT SIZE=5>La commande </FONT><TT><FONT SIZE=5>ipcs</FONT></TT><FONT SIZE=5>
(IPC state ) permet de conna&icirc;tre l'&eacute;tat des IPC de la
machine (comme la commande ps pour les processus). Par exemple sur
fillmore &nbsp;: </FONT>
</P>
<PRE>
<FONT SIZE=5>IPC status from /dev/kmem as of Mon Apr  5 18:23:31 1993</FONT>
<FONT SIZE=5>T     ID     KEY        MODE       OWNER    GROUP</FONT>
<FONT SIZE=5>Message Queues:</FONT>
<FONT SIZE=5>q      3 0x4917dfe1 --rw-rw-rw-     root     root</FONT>
<FONT SIZE=5>q      4 0xd5dcf701 --rw-rw-rw-     root     root</FONT>
<FONT SIZE=5>Shared Memory:</FONT>
<FONT SIZE=5>m      0 0x41440010 --rw-rw-rw-     root     root</FONT>
<FONT SIZE=5>m      1 0x414461bf --rw-rw-rw-     root     root</FONT>
<FONT SIZE=5>m      2 0x41460741 --rw-rw-rw-     root     root</FONT>
<FONT SIZE=5>m      3 0xff46df0e --rw-rw-rw-     root     root</FONT>
<FONT SIZE=5>m      4 0xfe46df0e --rw-rw-rw-     root     root</FONT>
<FONT SIZE=5>m    808 0x44446180 --rw-r-----     root  licence</FONT>
<FONT SIZE=5>Semaphores:</FONT>
<FONT SIZE=5>s      0 0x414461bf --ra-ra-ra-     root     root</FONT>
<FONT SIZE=5>s      1 0x41460741 --ra-ra-ra-     root     root</FONT>
<FONT SIZE=5>s      2 0x00446f6d --ra-r--r--     root     root</FONT>
<FONT SIZE=5>s      3 0x01090522 --ra-r--r--     root     root</FONT>
<FONT SIZE=5>s      4 0x054baa58 --ra-r--r--     root     root</FONT>
<FONT SIZE=5>s      5 0xff46df0e --ra-ra-ra-     root     root</FONT>
<FONT SIZE=5>s      6 0x00000000 --ra-ra----   oracle      dba</FONT></PRE><P>
<FONT SIZE=5>O&ugrave; l'on a les informations suivantes &nbsp;:</FONT></P>
<DL>
	<DT><FONT SIZE=5>T</FONT></DT><DD>
	<FONT SIZE=5>type </FONT>
	</DD><DT>
	<FONT SIZE=5>ID</FONT></DT><DD>
	<FONT SIZE=5>identification interne de l'objet </FONT>
	</DD><DT>
	<FONT SIZE=5>KEY</FONT></DT><DD>
	<FONT SIZE=5>cl&eacute; de l'objet (en hexa) avec 0x000000 mode
	IPC_PRIVATE </FONT>
	</DD><DT>
	<FONT SIZE=5>MODE</FONT></DT><DD>
	<FONT SIZE=5>droits d'acc&egrave;s </FONT>
	</DD><DT>
	<FONT SIZE=5>OWNER</FONT></DT><DD>
	<FONT SIZE=5>propri&eacute;taire </FONT>
	</DD><DT>
	<FONT SIZE=5>GROUP</FONT></DT><DD>
	<FONT SIZE=5>propri&eacute;taire </FONT>
	</DD><DT>
	<FONT SIZE=5>CREATOR</FONT></DT><DT STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>CGROUP</FONT></DT></DL>
<P>
<FONT SIZE=5>D'autres options, -q -m -s -a -c <BR>L'autre commande
</FONT><TT><FONT SIZE=5>ipcrm</FONT></TT><FONT SIZE=5> permet de
d&eacute;truire les ipc dont on donne soit </FONT>
</P>
<DL>
	<DT><FONT SIZE=5>l'identifiant</FONT></DT><DD>
	<FONT SIZE=5>avec -q -m et -s, soit par exemple, </FONT><TT><FONT SIZE=5>ipcrm
	-q 5</FONT></TT><FONT SIZE=5> d&eacute;truit les files de messages
	d'identifiant 5. </FONT>
	</DD><DT>
	<FONT SIZE=5>la cl&eacute;</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>avec -Q -M -S, soit par exemple </FONT><TT><FONT SIZE=5>ipcrm
	-M 0x01090522</FONT></TT><FONT SIZE=5> d&eacute;truit les segments
	de m&eacute;moire de cl&eacute; 0x01090522 </FONT>
	</DD></DL>
<P>
<FONT SIZE=5>Ces options sont combinables.<BR><BR><B>Attention</B> ne
jamais utiliser les identifiants fournis par </FONT><TT><FONT SIZE=5>ipcs</FONT></TT><FONT SIZE=5>
dans un programme. Ils ne sont pas totalement compatibles, c'est la
cl&eacute; qui est la seule r&eacute;f&eacute;rence solide.<!--TOC section <FONT SIZE=5>Les files de messages</FONT>--></FONT></P>
<H2><FONT SIZE=5>16.2&nbsp;&nbsp; Les files de messages</FONT></H2>
<P><!--SEC END --><FONT SIZE=5>Utilise le principe des bo&icirc;tes
aux lettres &nbsp;: on d&eacute;pose dans la bo&icirc;te un message
que d'autres processus pourront lire.<BR>Le mode de lecture/&eacute;criture
se fait de mani&egrave;re group&eacute;e par une structure de taille
donn&eacute;e. Chaque instruction de lecture ou d'&eacute;criture se
fait sur un message entier (toute la structure de message). Pour que
les lectures soient compatibles avec les &eacute;critures, les
messages sont typ&eacute;s. On utilisera une structure dont le
premier champ est un entier long qui doit contenir le type du
message.<BR><B>R&egrave;gle d'or</B> &nbsp;: le type d'un message est
un entier strictement positif.<BR>Le type du message permet aux
applications d'effectuer les bons ordres de lecture, mais aussi
permet de s&eacute;lectionner le ou les messages dans la file
d'attente.<BR><BR>Le fichier </FONT><CODE><TT><FONT SIZE=5>&lt;sys/msg.h&gt;</FONT></TT></CODE><FONT SIZE=5><BR>Quelques
macros permettant de param&egrave;trer les appels&nbsp;:</FONT></P>
<DL>
	<DT><FONT SIZE=5>MSG_NOERROR</FONT></DT><DD>
	<FONT SIZE=5>l'extraction d'un message trop long n'entraine pas
	d'erreur (le message est tronqu&eacute;). </FONT>
	</DD><DT>
	<FONT SIZE=5>MSG_R</FONT></DT><DD>
	<FONT SIZE=5>autorisation de lire dans la file. </FONT>
	</DD><DT>
	<FONT SIZE=5>MSG_W</FONT></DT><DD>
	<FONT SIZE=5>autorisation d'&eacute;crire dans la file. </FONT>
	</DD><DT>
	<FONT SIZE=5>MSG_RWAIT</FONT></DT><DD>
	<FONT SIZE=5>indication qu'un processus est bloqu&eacute; en
	lecture. </FONT>
	</DD><DT>
	<FONT SIZE=5>MSG_WWAIT</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>indication qu'un processus est bloqu&eacute; en
	&eacute;criture. </FONT>
	</DD></DL>
<H3>
<!--TOC subsection <FONT SIZE=5>la structure ms</FONT><FONT SIZE=5><B>q</B></FONT><FONT SIZE=5>id_ds </FONT>--><FONT SIZE=5>16.2.1&nbsp;&nbsp;
la structure msqid_ds </FONT>
</H3>
<PRE><!--SEC END -->
<FONT SIZE=5> struct msqid_ds {</FONT>
<FONT SIZE=5>    struct ipc_perm    msg_perm;       /* op&eacute;ration permission struct */</FONT>
<FONT SIZE=5>    struct __msg       *msg_first;     /* ptr to first message on q */</FONT>
<FONT SIZE=5>    struct __msg       *msg_last;      /* ptr to last message on q */</FONT>
<FONT SIZE=5>    unsigned short int msg_qnum;       /* # of messages on q */</FONT>
<FONT SIZE=5>    unsigned short int msg_qbytes;     /* max # of bytes on q */</FONT>
<FONT SIZE=5>    pid_t              msg_lspid;      /* pid of last msgsnd */</FONT>
<FONT SIZE=5>    pid_t              msg_lrpid;      /* pid of last msgrcv */</FONT>
<FONT SIZE=5>    time_t             msg_stime;      /* last msgsnd time */</FONT>
<FONT SIZE=5>    time_t             msg_rtime;      /* last msgrcv time */</FONT>
<FONT SIZE=5>    time_t             msg_ctime;      /* last change time */</FONT>
<FONT SIZE=5>    unsigned short int msg_cbytes;     /* current # bytes on q */</FONT>
<FONT SIZE=5>    char               msg_pad[22];    /* room for future expansion */</FONT>
<FONT SIZE=5>   };</FONT></PRE><H3>
<FONT SIZE=5><!--TOC subsection <FONT SIZE=5>La structure générique d'un message </FONT>-->16.2.2&nbsp;&nbsp;
La structure g&eacute;n&eacute;rique d'un message </FONT>
</H3>
<P><FONT SIZE=5><!--SEC END -->La structure suivante est un mod&egrave;le
pour les messages &nbsp;:</FONT></P>
<PRE>
<FONT SIZE=5>struct msgbuf { </FONT>
<FONT SIZE=5>    long mtype;    /* type du message */</FONT>
<FONT SIZE=5>    char mtext[1]; /* texte du message */</FONT>
<FONT SIZE=5>};</FONT></PRE><P>
<FONT SIZE=5>par exemple : </FONT>
</P>
<PRE>
<FONT SIZE=5>struct msg_buffer {</FONT>
<FONT SIZE=5>    long toto; /* type */</FONT>
<FONT SIZE=5>    float a;</FONT>
<FONT SIZE=5>    char m[7];</FONT>
<FONT SIZE=5>};</FONT></PRE><P>
<FONT SIZE=5><B>Attention</B> on ne peut pas &eacute;changer des
adresses, en effet les adresses virtuelles utilis&eacute;es par les
diff&eacute;rents programmes qui &eacute;changent des messages sont &agrave;
priori diff&eacute;rentes, de plus les zones de m&eacute;moire
manipulables par deux processus sont disjointes.<BR><BR><B>Important</B>
: le premier champ doit &ecirc;tre un entier long qui contiendra le
type du message. On trouvera d'autres structures dans le fichier
sys/msg.h, mais elle ne sont pas utilis&eacute;es par les
applications utilisateur. <BR><BR>Par exemple, la structure de file
de message &nbsp;: </FONT>
</P>
<PRE>
<FONT SIZE=5>struct __msg {</FONT>
<FONT SIZE=5>    struct __msg        *msg_next; </FONT>
<FONT SIZE=5>    long                msg_type;</FONT>
<FONT SIZE=5>    unsigned short int  msg_ts;   /*  taille du texte */</FONT>
<FONT SIZE=5>    long                msg_spot; /* &quot;adresse&quot; du texte */</FONT>
<FONT SIZE=5>};</FONT></PRE><P>
<FONT SIZE=5>ou la structure </FONT><TT><FONT SIZE=5>msginfo</FONT></TT><FONT SIZE=5>
utilis&eacute; par le noyau.<!--TOC subsection <FONT SIZE=5>Utilisation des files de messages</FONT>--></FONT></P>
<H3><FONT SIZE=5>16.2.3&nbsp;&nbsp; Utilisation des files de messages</FONT></H3>
<P><FONT SIZE=5><!--SEC END -->La primitive </FONT>
</P>
<PRE>
<FONT SIZE=5>#include &lt;sys/msg.h&gt;</FONT>
<FONT SIZE=5>int msgget (key_t  cle, int options);</FONT></PRE><P STYLE="margin-bottom: 0cm">
<FONT SIZE=5>est une fonction proche de la fonction </FONT><TT><FONT SIZE=5>open</FONT></TT><FONT SIZE=5>.
Elle renvoie un descripteur d'IPC de file de messages de key = </FONT><TT><FONT SIZE=5>cle</FONT></TT><FONT SIZE=5>.
Avec cr&eacute;ation ou non de la file de messages en fonction de
l'existence de celle-ci et du param&egrave;tre </FONT><TT><FONT SIZE=5>options</FONT></TT><FONT SIZE=5>.<BR>La
valeur du param&egrave;tre </FONT><TT><FONT SIZE=5>options</FONT></TT><FONT SIZE=5>
doit &ecirc;tre construite avec une conjonction du mode d'acc&egrave;s
et des constantes IPC_CREAT et IPC_EXCL. </FONT>
</P>
<TABLE CELLPADDING=0 CELLSPACING=2>
	<TR>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>Si cle == IPC_PRIVATE</FONT></P>
		</TD>
		<TD VALIGN=TOP></TD>
		<TD VALIGN=TOP></TD>
		<TD VALIGN=TOP></TD>
	</TR>
	<TR>
		<TD></TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>une nouvelle file de messages priv&eacute;e
			est cr&eacute;e.</FONT></P>
		</TD>
		<TD VALIGN=TOP></TD>
		<TD VALIGN=TOP></TD>
	</TR>
	<TR>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>Sinon</FONT></P>
		</TD>
		<TD VALIGN=TOP></TD>
		<TD VALIGN=TOP></TD>
		<TD VALIGN=TOP></TD>
	</TR>
	<TR>
		<TD></TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>Si la cle correspond &agrave; une file
			inexistante:</FONT></P>
		</TD>
		<TD VALIGN=TOP></TD>
		<TD VALIGN=TOP></TD>
	</TR>
	<TR>
		<TD></TD>
		<TD></TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>SI IPC_CREAT est positionn&eacute;
			(dans options), une nouvelle file est cr&eacute;e associ&eacute; &agrave;
			cette cl&eacute;,</FONT></P>
		</TD>
		<TD VALIGN=TOP></TD>
	</TR>
	<TR>
		<TD></TD>
		<TD></TD>
		<TD></TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>avec les droits d&eacute;finis dans
			options.</FONT></P>
		</TD>
	</TR>
	<TR>
		<TD></TD>
		<TD></TD>
		<TD></TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>Le cr&eacute;ateur et le propri&eacute;taire
			sont positionn&eacute;s</FONT></P>
		</TD>
	</TR>
	<TR>
		<TD></TD>
		<TD></TD>
		<TD></TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>aux valeurs de l'euid et du egid du
			processus r&eacute;alisant l'appel,</FONT></P>
		</TD>
	</TR>
	<TR>
		<TD></TD>
		<TD></TD>
		<TD></TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>le dipc interne de la file est
			retourn&eacute;.</FONT></P>
		</TD>
	</TR>
	<TR>
		<TD></TD>
		<TD></TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>sinon erreur retour -1</FONT></P>
		</TD>
		<TD VALIGN=TOP></TD>
	</TR>
	<TR>
		<TD></TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>Sinon la cle correspond &agrave; une
			file d&eacute;j&agrave; existante :</FONT></P>
		</TD>
		<TD COLSPAN=2 VALIGN=TOP></TD>
	</TR>
	<TR>
		<TD></TD>
		<TD></TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>Si les 2 indicateurs IPC_CREAT et
			IPC_EXCL sont positionn&eacute;s dans options</FONT></P>
		</TD>
		<TD VALIGN=TOP></TD>
	</TR>
	<TR>
		<TD></TD>
		<TD></TD>
		<TD></TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>une erreur est d&eacute;tect&eacute;e,
			retour -1, errno = EEXIST.</FONT></P>
		</TD>
	</TR>
	<TR>
		<TD></TD>
		<TD></TD>
		<TD>
			<P ALIGN=LEFT><FONT SIZE=5>sinon l'identification de la file est
			retourn&eacute;. </FONT>
			</P>
		</TD>
		<TD VALIGN=TOP></TD>
	</TR>
</TABLE>
<P><BR><FONT SIZE=5>En bref, IPC_EXCL nous permet de v&eacute;rifier
que la file n'existait pas.<!--TOC subsection <FONT SIZE=5>L'envoi de message</FONT>--></FONT></P>
<H3><FONT SIZE=5>16.2.4&nbsp;&nbsp; L'envoi de message</FONT></H3>
<PRE><!--SEC END -->
<FONT SIZE=5>#include &lt;sys/msg.h&gt;</FONT>
<FONT SIZE=5>int msgsnd (int dipc, const void *p_msg, int lg, int options);</FONT></PRE><P>
<FONT SIZE=5>Envoie dans la file </FONT><TT><FONT SIZE=5>dipc</FONT></TT><FONT SIZE=5>
le message point&eacute; par </FONT><TT><FONT SIZE=5>p_msg</FONT></TT><FONT SIZE=5>.<BR><BR><B>lg</B>
taille du message &eacute;gale &agrave; </FONT><TT><FONT SIZE=5>sizeof(struct
msgbuf)-sizeof(long)</FONT></TT><FONT SIZE=5>, le type du message
n'&eacute;tant pas compt&eacute; dans cette longueur.<BR><BR>Valeur
de retour (0) succes (-1) &eacute;chec.<BR><BR>Valeur de </FONT><TT><FONT SIZE=5>errno</FONT></TT><FONT SIZE=5>
en cas d'&eacute;chec: </FONT>
</P>
<DL>
	<DT><FONT SIZE=5>EINVAL</FONT></DT><DD>
	<FONT SIZE=5>file inexistante </FONT>
	</DD><DT>
	<FONT SIZE=5>EPERM</FONT></DT><DD>
	<FONT SIZE=5>pas de droits d'&eacute;criture </FONT>
	</DD><DT>
	<FONT SIZE=5>EINVAL</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>type de message incorrect </FONT>
	</DD></DL>
<P>
<FONT SIZE=5>Si IPC_NOWAIT est positionn&eacute;, l'envoi de messages
sur une file pleine n'est plus bloquant, alors dans le cas d'une file
pleine, la fonction retourne -1 et </FONT><TT><FONT SIZE=5>errno</FONT></TT><FONT SIZE=5>
est positionn&eacute; &agrave; EAGAIN.<BR><BR>Un appel de </FONT><TT><FONT SIZE=5>msgsnd</FONT></TT><FONT SIZE=5>
bloqu&eacute; peut &ecirc;tre interrompu par un signal ou par la
destruction de la file de message. Dans ce cas, elle renvoie (-1) et
</FONT><TT><FONT SIZE=5>errno</FONT></TT><FONT SIZE=5> est positionn&eacute;
&agrave; [EINTR] ou [EIDRM].<!--TOC subsection <FONT SIZE=5>La primitive d'extraction</FONT>--></FONT></P>
<H3><FONT SIZE=5>16.2.5&nbsp;&nbsp; La primitive d'extraction</FONT></H3>
<PRE><!--SEC END -->
<FONT SIZE=5>#include &lt;sys/msg.h&gt;</FONT>
<FONT SIZE=5>int msgrcv(int dipc, void *p_msg, int taille, long type, int options);</FONT></PRE><P>
<FONT SIZE=5>est une demande de lecture dans la file </FONT><TT><FONT SIZE=5>dipc</FONT></TT><FONT SIZE=5>
d'un message de longueur inf&eacute;rieure ou &eacute;gale &agrave;
</FONT><TT><FONT SIZE=5>taille</FONT></TT><FONT SIZE=5>, qui sera
copi&eacute; dans la zone point&eacute;e par </FONT><TT><FONT SIZE=5>p_msg</FONT></TT><FONT SIZE=5>.
</FONT><TT><FONT SIZE=5>options</FONT></TT><FONT SIZE=5> est une
combinaison des constantes: </FONT>
</P>
<DL>
	<DT><FONT SIZE=5>IPC_NOWAIT</FONT></DT><DD>
	<FONT SIZE=5>si la file est vide, le message est non-bloquant. </FONT>
	</DD><DT>
	<FONT SIZE=5>MSG_NOERROR</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>si le texte du message &agrave; extraire est de
	longueur sup&eacute;rieure &agrave; </FONT><TT><FONT SIZE=5>taille</FONT></TT><FONT SIZE=5>,
	alors le message est extrait tronqu&eacute; sans signaler d'erreur. </FONT>
	</DD></DL>
<P>
<FONT SIZE=5>Le param&egrave;tre </FONT><TT><FONT SIZE=5>type</FONT></TT><FONT SIZE=5>
permet de sp&eacute;cifier le type du message &agrave; extraire: </FONT>
</P>
<UL>
	<LI><P><FONT SIZE=5>si type &gt; 0, le plus vieux message de ce type
	est extrait;</FONT></P>
	<LI><P><FONT SIZE=5>si type == 0, le plus vieux message est extrait;</FONT></P>
	<LI><P><FONT SIZE=5>si type &lt; 0, le message le plus vieux du type
	le plus petit, mais inf&eacute;rieur ou &eacute;gal &agrave; | type
	|, est extrait. Ceci permet de d&eacute;finir des priorit&eacute;s
	entre les messages. </FONT>
	</P>
</UL>
<P><FONT SIZE=5>Dans tous les cas, l'appel est bloquant si il n'y a
pas de message du type voulu en attente.<BR><BR>Les causes d'&eacute;chec
: </FONT>
</P>
<DL>
	<DT><FONT SIZE=5>EINVAL</FONT></DT><DD>
	<FONT SIZE=5>file inexistante </FONT>
	</DD><DT>
	<FONT SIZE=5>EINVAL</FONT></DT><DD>
	<FONT SIZE=5>taille n&eacute;gative </FONT>
	</DD><DT>
	<FONT SIZE=5>E2BIG</FONT></DT><DD>
	<FONT SIZE=5>taille message &gt; taille, et pas de MSG_NOERROR </FONT>
	</DD><DT>
	<FONT SIZE=5>ENOMSG</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>pas de message et IPC_NOWAIT </FONT>
	</DD></DL>
<P>
<FONT SIZE=5>et les m&ecirc;mes codes d'interruptions que </FONT><TT><FONT SIZE=5>msgsnd</FONT></TT><FONT SIZE=5>.<!--TOC subsection <FONT SIZE=5>La primitive de contrôle</FONT>--></FONT></P>
<H3><FONT SIZE=5>16.2.6&nbsp;&nbsp; La primitive de contr&ocirc;le</FONT></H3>
<PRE><!--SEC END -->
<FONT SIZE=5>#include &lt;sys/msg.h&gt;</FONT>
<FONT SIZE=5>int msgctl (int dipc, int options, struct msqid *pmsqid);</FONT></PRE><P>
<FONT SIZE=5>permet de travailler sur la structure </FONT><TT><FONT SIZE=5>msqid</FONT></TT><FONT SIZE=5>
point&eacute;e par </FONT><TT><FONT SIZE=5>pmsqid</FONT></TT><FONT SIZE=5>
de la file de message </FONT><TT><FONT SIZE=5>dipc</FONT></TT><FONT SIZE=5>.
Valeur de </FONT><TT><FONT SIZE=5>options</FONT></TT><FONT SIZE=5> &nbsp;:
</FONT>
</P>
<DL>
	<DT><FONT SIZE=5>IPC_STAT</FONT></DT><DD>
	<FONT SIZE=5>lecture de la structure </FONT>
	</DD><DT>
	<FONT SIZE=5>IPC_SET</FONT></DT><DD>
	<FONT SIZE=5>positionnement, seuls les champs uid,gid et perm sont
	modifiables </FONT>
	</DD><DT>
	<FONT SIZE=5>IPC_RMID</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>permet de d&eacute;truire la file de messages
	(super-utilisateur, ou cr&eacute;ateur de la file de messages) </FONT>
	</DD></DL>
<H2>
<FONT SIZE=5><!--TOC section <FONT SIZE=5>Les sémaphores</FONT>-->16.3&nbsp;&nbsp;
Les s&eacute;maphores</FONT></H2>
<P><!--SEC END --><FONT SIZE=5>Les s&eacute;maphores permettent de
r&eacute;aliser l'acc&egrave;s en exclusion mutuelle &agrave; une
ressource (par exemple une zone de m&eacute;moire partag&eacute;e).<BR><BR>Un
peu de th&eacute;orie &nbsp;:<BR>Les s&eacute;maphores garantissent
l'acc&egrave;s d'un nombre born&eacute; de processus &agrave; une
donn&eacute;e. Ils permettent de placer en exclusion mutuelle une
ressource (par exemple la m&eacute;moire).<BR><BR>Dijkstra a &eacute;crit
de nombreux algorithmes d'exclusion mutuelle, et a d&eacute;fini les
s&eacute;maphores pour faciliter l'&eacute;criture de ces
algorithmes. Les s&eacute;maphores sont des variables partag&eacute;es,
dont l'acc&egrave;s ne se fait que gr&acirc;ce aux deux op&eacute;rations
atomiques P et V.<BR>On appelle </FONT><EM><FONT SIZE=5>section
critique</FONT></EM><FONT SIZE=5> la partie de programme qui doit
&ecirc;tre r&eacute;alis&eacute;e en exclusion.<BR>P(S)</FONT></P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Soit la valeur du
	s&eacute;maphore S est positive, il y a donc encore au moins une
	place en section critique pour le processus qui r&eacute;alise le P,
	le s&eacute;maphore est alors d&eacute;cr&eacute;ment&eacute; (une
	place de moins) et le processus utilise la ressource.</FONT></P>
	<LI><P><FONT SIZE=5>Soit la valeur de S est nulle (plus de place),
	le processus est mis en attente. </FONT>
	</P>
</UL>
<P><FONT SIZE=5>V(S)</FONT></P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Si un ou plusieurs
	processus sont en attente du s&eacute;maphore, ils sont r&eacute;veill&eacute;s
	et l'un d'eux rentre en section critique. Les autres sont remis en
	attente. </FONT>
	</P>
	<LI><P><FONT SIZE=5>Sinon le s&eacute;maphore est incr&eacute;ment&eacute;
	(lib&eacute;ration d'une place en section critique). </FONT>
	</P>
</UL>
<P><FONT SIZE=5>Ces op&eacute;rations sont <B>atomiques</B> :
totalement ininterruptibles, ont toujours lieu s&eacute;quentiellement
m&ecirc;me sur une machine multi-processeurs. <BR>Le fichier
</FONT><CODE><TT><FONT SIZE=5>&lt;sys/sem.h&gt;</FONT></TT></CODE><FONT SIZE=5>
&nbsp;:<BR><BR>Pour chaque s&eacute;maphore : </FONT>
</P>
<PRE>
<FONT SIZE=5>  struct __sem {</FONT>
<FONT SIZE=5>      unsigned short int semval;    /* adresse */</FONT>
<FONT SIZE=5>      unsigned short int sempid;    /* pid de derni&egrave;re op&eacute;ration */</FONT>
<FONT SIZE=5>      unsigned short int semncnt;   /* # de Proc. en attente de V */</FONT>
<FONT SIZE=5>      unsigned short int semzcnt;   /* # en attente de S = 0 */</FONT>
<FONT SIZE=5>  };</FONT></PRE><P>
<FONT SIZE=5>Pour chaque dipc de s&eacute;maphore: </FONT>
</P>
<PRE>
<FONT SIZE=5> struct semid_ds {</FONT>
<FONT SIZE=5>     struct ipc_perm    sem_perm;   /* droits  */</FONT>
<FONT SIZE=5>     struct __sem       *sem_base;  /* premier &eacute;l&eacute;ment de l'ensemble*/</FONT>
<FONT SIZE=5>     time_t             sem_otime;  /* last semop time */</FONT>
<FONT SIZE=5>     time_t             sem_ctime;  /* last change time */</FONT>
<FONT SIZE=5>     unsigned short int sem_nsems;  /* taille de l'ensemble */</FONT>
<FONT SIZE=5> };</FONT></PRE><H3>
<!--TOC subsection <FONT SIZE=5>La primitive de manipulation </FONT><FONT SIZE=5><TT>semop()</TT></FONT><FONT SIZE=5> </FONT>--><FONT SIZE=5>16.3.1&nbsp;&nbsp;
La primitive de manipulation </FONT><TT><FONT SIZE=5>semop()</FONT></TT><FONT SIZE=5>
</FONT>
</H3>
<P><FONT SIZE=5><!--SEC END -->La primitive </FONT>
</P>
<PRE>
<FONT SIZE=5>#include &lt;sys/sem.h&gt;</FONT>
<FONT SIZE=5>int semop(int dipc, struct sembuf *sops, unsigned int nsops);</FONT></PRE><P>
<FONT SIZE=5>est utilis&eacute;e pour r&eacute;aliser un tableau
d'op&eacute;rations de s&eacute;maphores sur un ensemble de
s&eacute;maphores indiqu&eacute; par </FONT><TT><FONT SIZE=5>dipc</FONT></TT><FONT SIZE=5>.
</FONT><EM><FONT SIZE=5>sops</FONT></EM><FONT SIZE=5> est un pointeur
sur tableau de structures </FONT><TT><FONT SIZE=5>sembuf</FONT></TT><FONT SIZE=5>,
et </FONT><EM><FONT SIZE=5>nsops</FONT></EM><FONT SIZE=5> indique le
nombre d'&eacute;l&eacute;ments du tableau. <BR><BR>La structure
</FONT><TT><FONT SIZE=5>sembuf</FONT></TT><FONT SIZE=5> </FONT>
</P>
<PRE>
<FONT SIZE=5>  struct sembuf {</FONT>
<FONT SIZE=5>      unsigned short int sem_num;    /* # s&eacute;maphore */</FONT>
<FONT SIZE=5>      short              sem_op;     /* op&eacute;ration du s&eacute;maphore */</FONT>
<FONT SIZE=5>      short              sem_flg;    /* flags de l'op&eacute;ration */</FONT>
<FONT SIZE=5>  };</FONT></PRE><P>
<FONT SIZE=5>Nature de l'op&eacute;ration dans la structure
</FONT><TT><FONT SIZE=5>sembuf</FONT></TT><BR><BR><FONT SIZE=5>Si
sem_num &gt; 0 <BR><FONT FACE="symbol">&frac34;&reg;</FONT> une
op&eacute;ration V est effectu&eacute;e sur le s&eacute;maphore
sem_num<BR>Si sem_num &lt; 0 <BR><FONT FACE="symbol">&frac34;&reg;</FONT>
une op&eacute;ration P est effectu&eacute;e sur le s&eacute;maphore
|sem_num|<BR>Si sem_num == 0 <BR>c'est une op&eacute;ration d'attente
qui se termine quand l'ensemble des s&eacute;maphores d&eacute;sign&eacute;s
par </FONT><TT><FONT SIZE=5>dipc</FONT></TT><FONT SIZE=5> sont &agrave;
z&eacute;ro.<BR>La primitive </FONT>
</P>
<PRE>
<FONT SIZE=5>#include &lt;sys/sem.h&gt;</FONT>
<FONT SIZE=5>int semop (int dipc, struct sembuf *tab_op, int nb_op);</FONT></PRE><P>
<FONT SIZE=5>Les </FONT><TT><FONT SIZE=5>nb_op</FONT></TT><FONT SIZE=5>
op&eacute;rations plac&eacute;es &agrave; l'adresse </FONT><TT><FONT SIZE=5>tab_op</FONT></TT><FONT SIZE=5>
sont r&eacute;alis&eacute;es atomiquement, c'est &agrave; dire toutes
r&eacute;alis&eacute;es ou aucune !! Le noyau g&eacute;rant
l'atomicit&eacute;. Si la i-&egrave;me op&eacute;ration ne peut &ecirc;tre
r&eacute;alis&eacute;e, les (i-1) premi&egrave;res sont
annul&eacute;es.<BR><BR>Chaque op&eacute;ration du tableau peut &ecirc;tre
rendue non bloquante.<BR><BR>Le fait d'avoir un appel bloquant on non
bloquant va donc d&eacute;pendre de l'ordre dans lequel on place les
op&eacute;rations &agrave; effectuer dans le tableau ...<BR><BR>Les
cas d'&eacute;chec </FONT>
</P>
<DL>
	<DT><FONT SIZE=5>EINVAL</FONT></DT><DD>
	<FONT SIZE=5>identification invalide </FONT>
	</DD><DT>
	<FONT SIZE=5>EACCESS</FONT></DT><DD>
	<FONT SIZE=5>acc&egrave;s interdit </FONT>
	</DD><DT>
	<FONT SIZE=5>E2BIG</FONT></DT><DD>
	<FONT SIZE=5>trop d'op&eacute;rations </FONT>
	</DD><DT>
	<FONT SIZE=5>EFBIG</FONT></DT><DD>
	<FONT SIZE=5>num&eacute;ro de s&eacute;maphore incorrect </FONT>
	</DD><DT>
	<FONT SIZE=5>EAGAIN</FONT></DT><DD>
	<FONT SIZE=5>Non r&eacute;alisable + non bloquant </FONT>
	</DD><DT>
	<FONT SIZE=5>EINVAL,ENOSPC</FONT></DT><DD>
	<FONT SIZE=5>trop d'op&eacute;rations ou de SEM_UNDO </FONT>
	</DD><DT>
	<FONT SIZE=5>ERANGE</FONT></DT><DD>
	<FONT SIZE=5>valeur du s&eacute;maphore trop grande !! </FONT>
	</DD><DT>
	<FONT SIZE=5>EINTR</FONT></DT><DD>
	<FONT SIZE=5>interruption </FONT>
	</DD><DT>
	<FONT SIZE=5>EIDRM</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>sem supprim&eacute; </FONT>
	</DD></DL>
<H3>
<FONT SIZE=5><!--TOC subsection <FONT SIZE=5>La primitive de contrôle des sémaphores</FONT>-->16.3.2&nbsp;&nbsp;
La primitive de contr&ocirc;le des s&eacute;maphores</FONT></H3>
<PRE><!--SEC END -->
<FONT SIZE=5>#include &lt;sys/sem.h&gt;</FONT>
<FONT SIZE=5>int semctl(int dipc, int semnum, int op, ... /* arg variables */);</FONT></PRE><P>
<FONT SIZE=5>En fonction de </FONT><TT><FONT SIZE=5>op</FONT></TT><FONT SIZE=5>
la fonction r&eacute;alise : </FONT>
</P>
<DL>
	<DT><FONT SIZE=5>GETNCNT</FONT></DT><DD>
	<FONT SIZE=5>renvoi de la valeur de semncnt </FONT>
	</DD><DT>
	<FONT SIZE=5>GETZCNT</FONT></DT><DD>
	<FONT SIZE=5>renvoi de la valeur de semzcnt </FONT>
	</DD><DT>
	<FONT SIZE=5>GETVAL</FONT></DT><DD>
	<FONT SIZE=5>renvoi de la valeur du s&eacute;maphore </FONT>
	</DD><DT>
	<FONT SIZE=5>GETPID</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>renvoi du pid du dernier processus ayant r&eacute;alis&eacute;
	une op&eacute;ration. </FONT>
	</DD></DL>
<P>
<TT><FONT SIZE=5>semnum</FONT></TT><FONT SIZE=5> est pour les
commandes suivantes interpr&eacute;t&eacute; comme un nombre de
s&eacute;maphores</FONT></P>
<DL>
	<DT><FONT SIZE=5>GETALL</FONT></DT><DD>
	<FONT SIZE=5>r&eacute;cup&eacute;ration du tableau des valeurs des
	</FONT><TT><FONT SIZE=5>semnum</FONT></TT><FONT SIZE=5> premiers
	s&eacute;maphores </FONT>
	</DD><DT>
	<FONT SIZE=5>SETALL</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>positionnement des </FONT><TT><FONT SIZE=5>semnum</FONT></TT><FONT SIZE=5>
	premi&egrave;res valeurs du tableau </FONT>
	</DD></DL>
<P>
<FONT SIZE=5>Et les commandes de manipulation de l'IPC&nbsp;: </FONT>
</P>
<DL>
	<DT><FONT SIZE=5>IPC_STAT</FONT></DT><DD>
	<FONT SIZE=5>lecture de la structure </FONT><TT><FONT SIZE=5>semid_ds</FONT></TT><FONT SIZE=5>
	</FONT>
	</DD><DT>
	<FONT SIZE=5>IPC_SET</FONT></DT><DD>
	<FONT SIZE=5>positionnement de la structure </FONT><TT><FONT SIZE=5>semid_ds</FONT></TT><FONT SIZE=5>
	</FONT>
	</DD><DT>
	<FONT SIZE=5>IPC_RMID</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>permet de d&eacute;truire le tableau de s&eacute;maphores
	(super-utilisateur, ou cr&eacute;ateur du s&eacute;maphore) </FONT>
	</DD></DL>
<H2>
<FONT SIZE=5><!--TOC section <FONT SIZE=5>Les segments de mémoire partagée</FONT>-->16.4&nbsp;&nbsp;
Les segments de m&eacute;moire partag&eacute;e</FONT></H2>
<P><!--SEC END --><FONT SIZE=5>Avec les segments de m&eacute;moire
partag&eacute;e, des processus vont partager des pages physiques par
l'interm&eacute;diaire de leur espace d'adressage. Il n'y aura plus
de copie d'information. Cette m&eacute;moire partag&eacute;e devient
un espace critique. Il faudra sans doute en prot&eacute;ger les acc&egrave;s
avec des s&eacute;maphores par exemple...<BR><BR>Un segment de
m&eacute;moire est ind&eacute;pendant de tout processus. Il peut
exister sans qu'aucun processus n'y acc&egrave;de.<BR><BR>Un
processus rattachera le segment &agrave; son espace d'adressage, puis
pourra manipuler cette m&eacute;moire de la m&ecirc;me fa&ccedil;on
qu'il peut manipuler sa propre m&eacute;moire.<BR><BR>Le fichier
</FONT><CODE><FONT SIZE=5>&lt;sys/shm.h&gt;</FONT></CODE><FONT SIZE=5>
&nbsp;:</FONT></P>
<PRE>
<FONT SIZE=5>struct shmid_ds {</FONT>
<FONT SIZE=5>     struct ipc_perm  shm_perm;       /* operation permission struct */</FONT>
<FONT SIZE=5>     int              shm_segsz;      /* size of segment in bytes */</FONT>
<FONT SIZE=5>     struct vas       *shm_vas;       /* virtual address space this entry */</FONT>
<FONT SIZE=5>     pid_t            shm_lpid;       /* pid of last shmop */</FONT>
<FONT SIZE=5>     pid_t            shm_cpid;       /* pid of creator */</FONT>
<FONT SIZE=5>     unsigned short int shm_nattch;   /* current # attached  */</FONT>
<FONT SIZE=5>     unsigned short int shm_cnattch;  /* in memory # attached */</FONT>
<FONT SIZE=5>     time_t           shm_atime;      /* last shmat time */</FONT>
<FONT SIZE=5>     time_t           shm_dtime;      /* last shmdt time */</FONT>
<FONT SIZE=5>     time_t           shm_ctime;      /* last change time */</FONT>
<FONT SIZE=5>     char             shm_pad[24];    /* room for future expansion */</FONT>
<FONT SIZE=5>};</FONT></PRE><H3>
<FONT SIZE=5><!--TOC subsection <FONT SIZE=5>Utilisation des segments de mémoire partagée</FONT>-->16.4.1&nbsp;&nbsp;
Utilisation des segments de m&eacute;moire partag&eacute;e</FONT></H3>
<P><!--SEC END --><FONT SIZE=5>La primitive </FONT><TT><FONT SIZE=5>shmget</FONT></TT><FONT SIZE=5>&nbsp;:
</FONT>
</P>
<PRE>
<FONT SIZE=5>#include &lt;sys/shm.h&gt;</FONT>
<FONT SIZE=5>int shmget(key_t cle, int taille, int options);</FONT></PRE><P>
<FONT SIZE=5>Cr&eacute;ation/ouverture d'un segment de </FONT><TT><FONT SIZE=5>taille</FONT></TT><FONT SIZE=5>
octets, si le segment existe d&eacute;j&agrave; il faut que la </FONT><TT><FONT SIZE=5>taille</FONT></TT><FONT SIZE=5>
soit inf&eacute;rieure ou &eacute;gale &agrave; celle du segment que
l'on veut ouvrir.<BR>La primitive d'attachement </FONT><TT><FONT SIZE=5>shmat</FONT></TT><FONT SIZE=5>&nbsp;:
</FONT>
</P>
<PRE>
<FONT SIZE=5>#include &lt;sys/shm.h&gt;</FONT>
<FONT SIZE=5>void  *shmat(int dipc, const void *adr, int option);</FONT></PRE><P>
<FONT SIZE=5>Cette primitive est une demande d'attachement du segment
</FONT><TT><FONT SIZE=5>dipc</FONT></TT><FONT SIZE=5> &agrave;
l'adresse </FONT><TT><FONT SIZE=5>adr</FONT></TT><FONT SIZE=5> de
l'espace d'adressage du processus. La valeur de retour est l'adresse
o&ugrave; l'attachement a &eacute;t&eacute; efffectivement r&eacute;alis&eacute;,
c'est-&agrave;-dire celle attribu&eacute;e au premier octet du
segment (ou -1 en cas d'&eacute;chec).<BR><BR>Le choix du param&egrave;tre
</FONT><TT><FONT SIZE=5>adr</FONT></TT><FONT SIZE=5> est d&eacute;licat.
Il faut en effet respecter un certain nombre de conditions, variables
d'une machine &agrave; l'autre&nbsp;: l'alignement, la plage
d'adresses autoris&eacute;es aux segments de m&eacute;moire partag&eacute;e,
les adresses de pages virtuelles et physiques etc. On utilisera de
pref&eacute;rence </FONT><TT><FONT SIZE=5>adr = NULL</FONT></TT><FONT SIZE=5>,
c'est-&agrave;-dire qu'on laisse le soin au syst&egrave;me de
s&eacute;lectionner l'adresse.<BR><BR>Si l'on veut quand m&ecirc;me
positionner le segment dans une certaine zone de l'espace
d'adressage, on utilise l'indicateur </FONT><TT><FONT SIZE=5>SHM_RND</FONT></TT><FONT SIZE=5>
dans le param&egrave;tre </FONT><TT><FONT SIZE=5>options</FONT></TT><FONT SIZE=5>
pour que le syst&egrave;me choisisse une adresse valable la plus
proche possible de </FONT><TT><FONT SIZE=5>adr</FONT></TT><FONT SIZE=5>.
<BR><BR>Remarques&nbsp;: l'attachement multiple par un m&ecirc;me
processus n'est pas autoris&eacute; sur tous les
syst&egrave;mes.<BR>L'attachement n'est valable que dans un seul
processus, l'adresse d'attachement n'a aucune raison d'&ecirc;tre
identique dans tous les processus, on ne pourra donc pas utiliser de
structures cha&icirc;n&eacute;es dans le segment de m&eacute;moire
partag&eacute;e.<BR>La primitve de d&eacute;tachement&nbsp;: </FONT>
</P>
<PRE>
<FONT SIZE=5>#include &lt;sys/shm.h&gt;</FONT>
<FONT SIZE=5>int shmdt (const void *adr);</FONT></PRE><P>
<FONT SIZE=5>d&eacute;tache le segment attach&eacute; &agrave;
l'adresse </FONT><TT><FONT SIZE=5>adr</FONT></TT><FONT SIZE=5> par
</FONT><TT><FONT SIZE=5>shmat</FONT></TT><FONT SIZE=5>.<BR>La
primitive de contr&ocirc;le&nbsp;: </FONT>
</P>
<PRE>
<FONT SIZE=5>#include &lt;sys/shm.h&gt;</FONT>
<FONT SIZE=5>int shmctl(int dipc, int op, struct shmid_ds *pshmid);</FONT></PRE><P>
<FONT SIZE=5>est extr&ecirc;mement simple, les seules op&eacute;rations
sont celles qui sont g&eacute;n&eacute;riques &agrave; tous les IPC. </FONT>
</P>
<DL>
	<DT><FONT SIZE=5>IPC_STAT</FONT></DT><DD>
	<FONT SIZE=5>lecture de la structure </FONT><TT><FONT SIZE=5>shmid_ds</FONT></TT><FONT SIZE=5>
	</FONT>
	</DD><DT>
	<FONT SIZE=5>IPC_SET</FONT></DT><DD>
	<FONT SIZE=5>positionnement de la structure </FONT><TT><FONT SIZE=5>shmid_ds</FONT></TT><FONT SIZE=5>
	</FONT>
	</DD><DT>
	<FONT SIZE=5>IPC_RMID</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>permet de d&eacute;truire le segment
	(super-utilisateur, ou cr&eacute;ateur du s&eacute;maphore) </FONT>
	</DD></DL>
<P>
<FONT SIZE=5>Une autre technique de partage de m&eacute;moire existe,
avec la projection de fichier en m&eacute;moire (voir section </FONT><A HREF="#mmap"><FONT SIZE=5>10.5</FONT></A><FONT SIZE=5>).<!--TOC chapter <FONT SIZE=5>La Sécurité</FONT>-->
</FONT>
</P>
<H1><FONT SIZE=5>Chapitre&nbsp;17&nbsp;&nbsp; La S&eacute;curit&eacute;</FONT></H1>
<P><FONT SIZE=5><!--SEC END -->La s&eacute;curit&eacute; est le
probl&egrave;me de tout le monde. Pour que la s&eacute;curit&eacute;
fonctionne, il faut que toutes les personnes ayant un acc&egrave;s &agrave;
une ressource soient conscient du degr&eacute; de s&eacute;curit&eacute;
associ&eacute; &agrave; la ressource.<!--TOC section <FONT SIZE=5>Protection des systèmes d'exploitation</FONT>--></FONT></P>
<H2><FONT SIZE=5>17.1&nbsp;&nbsp; Protection des syst&egrave;mes
d'exploitation</FONT></H2>
<P><FONT SIZE=5><!--SEC END -->S&eacute;curiser un syst&egrave;me,
c'est prot&eacute;ger ce syst&egrave;me contre un fonctionnement
impr&eacute;vu ou d&eacute;fectueux.<BR>Il peut s'agir&nbsp;: </FONT>
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>d'erreurs de
	programmation (d'un utilisateur, ou du syst&egrave;me lui-m&ecirc;me)
	qui se propagent au syst&egrave;me (du fait de contr&ocirc;les
	insuffisants ou mal effectu&eacute;s). </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>d'un mauvais
	fonctionnement du mat&eacute;riel. </FONT>
	</P>
	<LI><P><FONT SIZE=5>enfin, d'un op&eacute;rateur, concepteur ou
	r&eacute;alisateur malveillant ou peu scrupuleux (quand il s'agit
	d'informations financi&egrave;res!). </FONT>
	</P>
</UL>
<P><FONT SIZE=5>Le recensement des op&eacute;rations frauduleuses aux
Etats-Unis au cours d'une ann&eacute;e a donn&eacute; 339 cas de
fraude, pour un co&ucirc;t d'un milliard de francs.<BR>La protection
des sites a &eacute;galement un co&ucirc;t tr&egrave;s important
(temps et complexit&eacute;), d'o&ugrave; des syst&egrave;mes de
protection qui r&eacute;sultaient d'un compromis co&ucirc;t/efficacit&eacute;.<BR>Le
co&ucirc;t en ressources de la protection &eacute;tant rest&eacute;
stationnaire, les syst&egrave;mes et les machines actuelles plus
rapides ont rendu ce co&ucirc;t moins prohibitif.<BR>L'id&eacute;e
d'un syst&egrave;me de protection est de traiter les diff&eacute;rents
types de probl&egrave;mes de mani&egrave;re g&eacute;n&eacute;rale et
unitaire.<BR>Implant&eacute;s seuls, les dispositifs de protection
co&ucirc;tent cher. <BR>Heureusement, si ces dispositifs permettent
d'augmenter les performances du logiciel, dans des domaines comme
celui de la fiabilit&eacute; ou de la r&eacute;sistance aux erreurs,
leur co&ucirc;t relatif diminue. Si, de plus, ces dispositifs
permettent une gestion des ressources partag&eacute;es plus facile et
plus s&ucirc;re, ils peuvent devenir comp&eacute;titifs d'un point de
vue commercial.<BR>Il est difficile de d&eacute;finir pr&eacute;cis&eacute;ment
ce que l'on entend par protection d'un syst&egrave;me d'exploitation
(et d'information en g&eacute;n&eacute;ral), tant les facteurs qui
peuvent influer sur cette notion (humains, sociaux, &eacute;conomiques),
sont nombreux. On peut dire cependant que la protection se rapporte &agrave;
tout ce par quoi l'information peut &ecirc;tre modifi&eacute;e,
divulgu&eacute;e ou d&eacute;truite. Dans certains cas, la gestion du
trafic a&eacute;rien par exemple, elle peut &ecirc;tre la garantie
des performances du syst&egrave;me. La confidentialit&eacute;
d'enregistrements financiers, m&eacute;dicaux ou personnels rel&egrave;ve
aussi de la protection, comme le fait qu'un processus utilisateur ne
puisse &ecirc;tre ex&eacute;cut&eacute; en mode syst&egrave;me. La
protection exige enfin la correction des processus syst&egrave;me. </FONT>
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>p&eacute;rennit&eacute;
	du syst&egrave;me </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>confidentialit&eacute;
	des donn&eacute;es (syst&egrave;me, utilisateur, etc.) </FONT>
	</P>
	<LI><P><FONT SIZE=5>correction du syst&egrave;me </FONT>
	</P>
</UL>
<P><FONT SIZE=5>A l'oppos&eacute;, nous ne parlerons pas de&nbsp;: </FONT>
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>protection physique
	de l'ordinateur (feu, vol, coupures, etc.) </FONT>
	</P>
	<LI><P><FONT SIZE=5>malveillance ou incomp&eacute;tence de
	l'op&eacute;rateur (il est &eacute;ventuellement possible de limiter
	soigneusement les privil&egrave;ges du super-utilisateur afin de
	pr&eacute;server le syst&egrave;me). </FONT>
	</P>
</UL>
<P><FONT SIZE=5>Le degr&eacute; de protection du syst&egrave;me
d&eacute;pend de deux facteurs&nbsp;: </FONT>
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>le degr&eacute; de
	protection des informations qu'il manipule </FONT>
	</P>
	<LI><P><FONT SIZE=5>le degr&eacute; de confiance en ses logiciels,
	en particulier le syst&egrave;me d'exploitation. </FONT>
	</P>
</UL>
<P><FONT SIZE=5>Un logiciel est fiable quand il satisfait
correctement ses sp&eacute;cifications et quand, de plus, il est
capable de r&eacute;sister &agrave; un environnement impr&eacute;vu
(donn&eacute;es erron&eacute;es, pannes, etc.), soit en corrigeant
l'anomalie, soit en la signalant, mais en &eacute;vitant que les
erreurs ne se propagent et ne contaminent le syst&egrave;me tout
entier.<BR>La protection, l'int&eacute;grit&eacute; et l'authenticit&eacute;
des donn&eacute;es qui transitent dans un syst&egrave;me
d'information sont r&eacute;alis&eacute;es par les syst&egrave;mes
cryptographiques (ATHENA et Kerberos au MIT).<BR>Le confinement des
erreurs est obtenu en contr&ocirc;lant les acc&egrave;s aux entit&eacute;s
du syst&egrave;me d'exploitation, par les domaines de protection.<!--TOC section <FONT SIZE=5>Généralités sur le contrôle d'accès</FONT>--></FONT></P>
<H2><FONT SIZE=5>17.2&nbsp;&nbsp; G&eacute;n&eacute;ralit&eacute;s
sur le contr&ocirc;le d'acc&egrave;s</FONT></H2>
<P><FONT SIZE=5><!--SEC END -->Contr&ocirc;le tr&egrave;s pr&eacute;cis
de l'utilisation des ressources par les processus.<BR>Deux niveaux&nbsp;:
</FONT>
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>un niveau logique
	(soft), celui du mod&egrave;le de protection, ensemble de r&egrave;gles
	qui d&eacute;finissent quels acc&egrave;s (aux ressources) sont
	autoris&eacute;s et quels acc&egrave;s sont interdits. Ces r&egrave;gles
	sont d&eacute;finies soit &agrave; la conception du syst&egrave;me,
	soit par les utilisateurs. </FONT>
	</P>
	<LI><P><FONT SIZE=5>un niveau mat&eacute;riel qui permet d'appliquer
	le mod&egrave;le r&eacute;ellement. C'est le r&ocirc;le des
	m&eacute;canismes de protection. </FONT>
	</P>
</UL>
<P><FONT SIZE=5>Le premier doit &ecirc;tre dynamique. Par contre, le
deuxi&egrave;me doit &ecirc;tre stable pour faciliter
l'impl&eacute;mentation, le contr&ocirc;le et la fiabillisation.<BR>Les
deux doivent de surcro&icirc;t &ecirc;tre ind&eacute;pendants du
mod&egrave;le pour offrir un vaste ensemble de r&egrave;gles
possibles.<!--TOC subsection <FONT SIZE=5>Domaines de protection et matrices d'accès</FONT>--></FONT></P>
<H3><FONT SIZE=5>17.2.1&nbsp;&nbsp; Domaines de protection et
matrices d'acc&egrave;s</FONT></H3>
<P><FONT SIZE=5><!--SEC END -->On formalise le syst&egrave;me comme
un ensemble d'entit&eacute;s actives, les sujets, un ensemble
d'entit&eacute;s accessibles, les objets. Le mod&egrave;le de
protection d&eacute;finit quels sujets ont acc&egrave;s &agrave;
quels objets et comment (modalit&eacute;s d'acc&egrave;s). <BR><BR>On
parle alors de droit d'acc&egrave;s, d&eacute;finis par le couple
(objet, modalit&eacute;s)<BR><BR>Exemple&nbsp;: (fichier, lire)<BR>Le
mod&egrave;le doit fixer &agrave; tout instant les droits d'acc&egrave;s
dont dispose chaque processus. Cet ensemble de droits est le domaine
de protection du processus.</FONT></P>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML064.gif" NAME="Image66" ALIGN=BOTTOM WIDTH=636 HEIGHT=314 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
17.1&nbsp;: Matrice d'acc&egrave;s</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="matricedacces1"></A><BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<H3><FONT SIZE=5><!--TOC subsection <FONT SIZE=5>Domaines de protection restreints</FONT>-->17.2.2&nbsp;&nbsp;
Domaines de protection restreints</FONT></H3>
<P><!--SEC END --><FONT SIZE=5>Il est souhaitable que la matrice
d'acc&egrave;s puisse &eacute;voluer dynamiquement. En effet, un m&ecirc;me
processus peut avoir, au cours de son existence, des besoins
variables afin que chaque module qui compose un processus ne mette
pas en danger des ressources non utilis&eacute;es. Par exemple&nbsp;:
un module de lecture de donn&eacute;es, un module de calcul, un
module d'impression. On va donc ex&eacute;cuter chaque module dans un
domaine de protection le plus r&eacute;duit possible.<BR><BR>C'est le
<I>principe du moindre privil&egrave;ge</I>&nbsp;: un programme ne
peut endommager un objet auquel il n'a pas acc&egrave;s !<BR><BR>Pour
mettre en place ces domaines dynamiques, une possibilit&eacute; est
de changer les droits d'acc&egrave;s du processus au cours de son
ex&eacute;cution. Une autre possibilit&eacute; est d'ajouter aux
objets le type &quot;domaine&quot; et de contr&ocirc;ler les acc&egrave;s
&agrave; la matrice. L'&eacute;dition de cases de la matrice devient
une op&eacute;ration prot&eacute;g&eacute;e.</FONT></P>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML065.gif" NAME="Image67" ALIGN=BOTTOM WIDTH=314 HEIGHT=709 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
17.2&nbsp;: Matrice d'acc&egrave;s</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="matricedacces3"></A><BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<H3><FONT SIZE=5><!--TOC subsection <FONT SIZE=5>Avantages des domaines de protections restreints</FONT>-->17.2.3&nbsp;&nbsp;
Avantages des domaines de protections restreints</FONT></H3>
<P><FONT SIZE=5><!--SEC END -->Avantages de cette souplesse &nbsp;: </FONT>
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>le maillon faible&nbsp;:
	un syst&egrave;me rigide laisse souvent des &quot;poternes&quot;
	(portes d&eacute;rob&eacute;es) pour pouvoir impl&eacute;menter
	certaines op&eacute;rations&nbsp;; </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>si les mesures de
	protection sont trop pesantes, l'exp&eacute;rience prouve que l'on
	cr&eacute;e souvent des moyens &quot;exceptionnels&quot; pour les
	contourner&nbsp;; </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>il est int&eacute;ressant
	de faire varier les contr&ocirc;les suivant les utilisateurs&nbsp;; </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>on peut r&eacute;aliser
	des acc&egrave;s &agrave; la carte sur certains objets&nbsp;; </FONT>
	</P>
	<LI><P><FONT SIZE=5>enfin, certains probl&egrave;mes de protection
	n&eacute;cessitent des mesures souples, ce sont&nbsp;: &quot;le
	cheval de Troie&quot; et le confinement. </FONT>
	</P>
</UL>
<H2><FONT SIZE=5><!--TOC section <FONT SIZE=5>Le cheval de Troie</FONT>-->17.3&nbsp;&nbsp;
Le cheval de Troie</FONT></H2>
<P><FONT SIZE=5><!--SEC END -->Un utilisateur fait souvent appel &agrave;
un certain nombre de programmes qu'il n'a pas &eacute;crit lui-m&ecirc;me
(heureusement), un &eacute;diteur par exemple. Ce programme peut &ecirc;tre
un cheval de Troie&nbsp;: il va profiter des droits donn&eacute;s par
l'utilisateur pour consulter, copier, modifier ou alt&eacute;rer des
donn&eacute;es auxquelles il n'est pas cens&eacute; acc&eacute;der.<!--TOC section <FONT SIZE=5>Le confinement</FONT>--></FONT></P>
<H2><FONT SIZE=5>17.4&nbsp;&nbsp; Le confinement</FONT></H2>
<P><FONT SIZE=5><!--SEC END -->Le probl&egrave;me ici est tout
simplement le fait que le programme ne manipule pas de donn&eacute;es
de l'utilisateur mais simplement enregistre ses param&egrave;tres
d'appels (les utilisateurs &agrave; qui vous envoyez du courrier par
exemple). Le probl&egrave;me du confinement est donc de vous prot&eacute;ger
contre ce type d'extraction d'informations (ce qui peut par exemple
&ecirc;tre utilis&eacute; en bourse pour connaitre votre comportement
d'achat).<!--TOC section <FONT SIZE=5>les mécanismes de contrôle</FONT>--></FONT></P>
<H2><FONT SIZE=5>17.5&nbsp;&nbsp; les m&eacute;canismes de contr&ocirc;le</FONT></H2>
<P><!--SEC END --><FONT SIZE=5>Acc&egrave;s hi&eacute;rarchiques<BR>UNIX
(4)/ MULTICS (8) / VMS <BR>Listes d'acc&egrave;s
<BR>UNIX/MULTICS<BR>Capacit&eacute;s<BR>Les capacit&eacute;s sont des
triplets <FONT COLOR="#000080">(utilisateur, droits, pointeur)</FONT>.
La manipulation des capacit&eacute;s est r&eacute;alis&eacute;e de
fa&ccedil;on prot&eacute;g&eacute;e. Le pointeur n'est pas
directement utilisable par l'utilisateur de la capacit&eacute;. La
capacit&eacute; donne le droit d'acc&egrave;s &agrave; certains
utilisateurs d'une certaine ressource. Pour qu'un autre utilisateur
puisse utiliser votre ressource, vous devez lui donner une capacit&eacute;.</FONT></P>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML066.gif" NAME="Image68" ALIGN=BOTTOM WIDTH=634 HEIGHT=57 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
17.3&nbsp;: Une capacit&eacute;</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="capacite1"></A><BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<P><FONT SIZE=5>Changer de protection revient &agrave; changer de
C-liste.<BR><BR>La notion de domaine se mat&eacute;rialise par une
simple indirection sur une autre C-liste.</FONT></P>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML067.gif" NAME="Image69" ALIGN=BOTTOM WIDTH=645 HEIGHT=254 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
17.4&nbsp;: Une liste de capacit&eacute;s</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="capacite2"></A><BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<P><FONT SIZE=5>Comme les capacit&eacute;s donnent un acc&egrave;s
sans contr&ocirc;le aux objets, la protection des capacit&eacute;s
doit &ecirc;tre absolue. Elle est donc r&eacute;alis&eacute;e de
fa&ccedil;on mat&eacute;rielle.<!--TOC subsection <FONT SIZE=5>Application des capacités au domaines de protection restreints</FONT>--></FONT></P>
<H3><FONT SIZE=5>17.5.1&nbsp;&nbsp; Application des capacit&eacute;s
au domaines de protection restreints</FONT></H3>
<P><FONT SIZE=5><!--SEC END -->Les C-listes sont des objets d'un type
n'ayant qu'un droit d'entr&eacute;e, la C-liste contenant le droit
r&eacute;el. <BR><BR>Cette technique sur les C-listes permet
d'implanter facilement le principe de moindre privil&egrave;ge. </FONT>
</P>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML068.gif" NAME="Image70" ALIGN=BOTTOM WIDTH=638 HEIGHT=309 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
17.5&nbsp;: Changement du domaine de protection</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="capacite3"></A><BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<P><FONT SIZE=5>Les m&eacute;canismes d'acc&egrave;s m&eacute;moire
modernes permettent ais&eacute;ment de r&eacute;aliser les
capacit&eacute;s.<BR><BR>Un probl&egrave;me important est la
r&eacute;vocation <BR><BR>En effet, une fois que vous avez donn&eacute;
une capacit&eacute;, l'acc&egrave;s est d&eacute;finitivement donn&eacute;.
Pour r&eacute;gler ce probl&egrave;me, on ne fournira pas la capacit&eacute;
d'acc&egrave;s &agrave; un objet mais &agrave; un domaine, et on
d&eacute;truira ce domaine si l'on veut de nouveau interdire l'acc&egrave;s
&agrave; l'objet. On cr&eacute;e deux capacit&eacute;s en chaine et
l'on d&eacute;truit celle que l'on poss&egrave;de quand ont veut
retirer l'acc&egrave;s.</FONT></P>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML069.gif" NAME="Image71" ALIGN=BOTTOM WIDTH=558 HEIGHT=323 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
17.6&nbsp;: Transmission d'une capacit&eacute;</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="capacite4"></A><BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML070.gif" NAME="Image72" ALIGN=BOTTOM WIDTH=558 HEIGHT=323 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
17.7&nbsp;: R&eacute;vocation d'une capacit&eacute;</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="capacite5"></A><BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<H2><FONT SIZE=5><!--TOC section <FONT SIZE=5>Les ACL</FONT>-->17.6&nbsp;&nbsp;
Les ACL</FONT></H2>
<P><!--SEC END --><FONT SIZE=5>Les ACL (access control lists) sont
une extension des modes de protection standard d'UNIX. Les ACL sont
des droits que l'on d&eacute;finit en plus des 9 bits de protection
classiques, ils permettent en particulier d'autoriser l'acc&egrave;s
ou de le refuser, &agrave; un utilisateur donn&eacute;, ou &agrave;
un groupe donn&eacute;. <BR><BR>Deux commandes permettent de
manipuler les ACL, ce sont </FONT><TT><FONT SIZE=5>chacl</FONT></TT><FONT SIZE=5>
et </FONT><TT><FONT SIZE=5>lsacl</FONT></TT><FONT SIZE=5>.<BR>La
syntaxe de la commande shell </FONT><TT><FONT SIZE=5>chacl</FONT></TT><FONT SIZE=5>&nbsp;:<BR></FONT><TT><FONT SIZE=5>chacl
'(dr.staff,r-x)(zipstein.%,r-x)(%.licence,---)' proj</FONT></TT><FONT SIZE=5><BR>qui
donne sur le fichier </FONT><TT><FONT SIZE=5>proj</FONT></TT><FONT SIZE=5>
les droits de lecture et d'&eacute;criture &agrave; l'utilisateur </FONT><TT><FONT SIZE=5>dr</FONT></TT><FONT SIZE=5>
du groupe </FONT><TT><FONT SIZE=5>staff</FONT></TT><FONT SIZE=5> et &agrave;
l'utilisateur </FONT><TT><FONT SIZE=5>zipstein</FONT></TT><FONT SIZE=5>
quelque soit son groupe et qui refuse cet acc&egrave;s aux
utilisateurs du groupe </FONT><TT><FONT SIZE=5>licence</FONT></TT><FONT SIZE=5>.<BR></FONT><TT><FONT SIZE=5>chacl
'(binome.%,rwx)(%.@,--x)(%.%,---)' catalogue_projet</FONT></TT><FONT SIZE=5><BR>qui
donne le droit d'acc&egrave;s total &agrave; l'utilisateur </FONT><TT><FONT SIZE=5>binome</FONT></TT><FONT SIZE=5>
(quelque soit son groupe), permet le parcours du r&eacute;pertoire
aux membres du groupe propri&eacute;taire et refuse l'acc&egrave;s &agrave;
tous les autres utilisateurs.<BR>Deux symboles sp&eacute;ciaux&nbsp;:
</FONT>
</P>
<DL>
	<DT><TT><FONT SIZE=5>%</FONT></TT></DT><DD>
	<FONT SIZE=5>pour n'importe qui (utilisateur ou groupe) </FONT>
	</DD><DT>
	<TT><FONT SIZE=5>@</FONT></TT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>pour le propri&eacute;taire ou le groupe propri&eacute;taire
	</FONT>
	</DD></DL>
<P>
<FONT SIZE=5>On retrouve aussi les autres syntaxes de </FONT><TT><FONT SIZE=5>chmod</FONT></TT><FONT SIZE=5>
par exemple&nbsp;:<BR></FONT><TT><FONT SIZE=5>chacl %.%=r fichier</FONT></TT><FONT SIZE=5>
<BR>ou<BR></FONT><TT><FONT SIZE=5>chacl @.%=5 fichier</FONT></TT><BR><BR><FONT SIZE=5><BR><BR><B>Attention</B>
les acl sont d&eacute;truits par la commande </FONT><TT><FONT SIZE=5>chmod</FONT></TT><FONT SIZE=5>
et la commande </FONT><TT><FONT SIZE=5>chacl</FONT></TT><FONT SIZE=5>
ne permet pas de positioner les autres bits d&eacute;finis dans
l'inode&nbsp;; seuls les 9 bits de protections sont positionnables
par </FONT><TT><FONT SIZE=5>chacl</FONT></TT><FONT SIZE=5>.<BR><BR>Pour
positionner les droits standard et des acl, il faut donc r&eacute;aliser
en succession un </FONT><TT><FONT SIZE=5>chmod</FONT></TT><FONT SIZE=5>
puis un </FONT><TT><FONT SIZE=5>chacl</FONT></TT><FONT SIZE=5>. <BR><BR>On
utilisera&nbsp;:<BR></FONT><TT><FONT SIZE=5>chacl '(prof.%,rwx)'
catalogue_projet</FONT></TT><FONT SIZE=5><BR>pour les projets de C ou
de syst&egrave;me.<BR><BR>La commande </FONT><TT><FONT SIZE=5>lsacl
[fichiers]</FONT></TT><FONT SIZE=5> permet de conna&icirc;tre les acl
associ&eacute;s aux fichiers, remarquer qu'&agrave; l'inverse de
</FONT><TT><FONT SIZE=5>/bin/ls </FONT></TT><FONT SIZE=5>cette
commande n'a pas de param&egrave;tres par d&eacute;faut.<!--TOC subsection <FONT SIZE=5>Appels systemes </FONT><FONT SIZE=5><TT>setacl</TT></FONT><FONT SIZE=5> et </FONT><FONT SIZE=5><TT>getacl</TT></FONT>--></FONT></P>
<H3><FONT SIZE=5>17.6.1&nbsp;&nbsp; Appels systemes </FONT><TT><FONT SIZE=5>setacl</FONT></TT><FONT SIZE=5>
et </FONT><TT><FONT SIZE=5>getacl</FONT></TT></H3>
<P><!--SEC END --><FONT SIZE=5>On trouvera deux appels syst&egrave;mes
correspondant&nbsp;: </FONT><TT><FONT SIZE=5><BR>#include
&lt;sys/acl.h&gt;<BR><BR>int setacl(<BR>const char *path,<BR>size_t
nentries,<BR>const struct acl_entry *acl<BR>);<BR><BR>int
fsetacl(<BR>int fildes,<BR>size_t nentries,<BR>const struct acl_entry
*acl<BR>);<BR></FONT></TT><BR><BR><FONT SIZE=5>Un bon exercice &nbsp;:
r&eacute;crire </FONT><TT><FONT SIZE=5>lsacl</FONT></TT><FONT SIZE=5>
de fa&ccedil;on qu'il fonctionne d'une mani&egrave;re similaire &agrave;
</FONT><TT><FONT SIZE=5>/bin/ls</FONT></TT><FONT SIZE=5>.<BR><BR>Utilisation
de la commande script pour montrer le comportement des acl. </FONT>
</P>
<PRE>
<FONT SIZE=5>Script started on Fri May  5 10:33:20 1995</FONT>
<FONT SIZE=5>$ lsacl *</FONT>
<FONT SIZE=5>(dr.%,rw-)(%.staff,---)(%.%,---) fich</FONT>
<FONT SIZE=5>(dr.%,rw-)(%.staff,---)(%.%,---) file</FONT>
<FONT SIZE=5>(dr.%,rwx)(%.staff,---)(%.%,---) projet</FONT>
<FONT SIZE=5>$ chacl  '(prof.%,rwx)' fich</FONT>
<FONT SIZE=5>$ lsacl *</FONT>
<FONT SIZE=5>(prof.%,rwx)(dr.%,rw-)(%.staff,---)(%.%,---) fich</FONT>
<FONT SIZE=5>(dr.%,rw-)(%.staff,---)(%.%,---) file</FONT>
<FONT SIZE=5>(dr.%,rwx)(%.staff,---)(%.%,---) projet</FONT>
<FONT SIZE=5>$ chacl '(%.staff,rx)' fich</FONT>
<FONT SIZE=5>$ lsacl *</FONT>
<FONT SIZE=5>(prof.%,rwx)(dr.%,rw-)(%.staff,r-x)(%.%,---) fich</FONT>
<FONT SIZE=5>(dr.%,rw-)(%.staff,---)(%.%,---) file</FONT>
<FONT SIZE=5>(dr.%,rwx)(%.staff,---)(%.%,---) projet</FONT>
<FONT SIZE=5>$ chacl '(illouz.staff=' fich</FONT>
<FONT SIZE=5>$ lsacl fich</FONT>
<FONT SIZE=5>(illouz.staff,---)(prof.%,rwx)(dr.%,rw-)(%.staff,r-x)(%.%,---) fich</FONT>
<FONT SIZE=5>$ chacl '(prof.%,rx)' . ..</FONT>
<FONT SIZE=5>$ su prof</FONT>
<FONT SIZE=5>Password:</FONT>
<FONT SIZE=5>$ cat fich</FONT>
<FONT SIZE=5>$ touch fich</FONT>
<FONT SIZE=5>$ chacl '(dr.staff,x)' fich</FONT>
<FONT SIZE=5>chacl: file &quot;fich&quot;: Not owner (errno = 1)</FONT>
<FONT SIZE=5>$ lsacl *</FONT>
<FONT SIZE=5>(illouz.staff,---)(prof.%,rwx)(dr.%,rw-)(%.staff,r-x)(%.%,---) fich</FONT>
<FONT SIZE=5>(dr.%,rw-)(%.staff,---)(%.%,---) file</FONT>
<FONT SIZE=5>(dr.%,rwx)(%.staff,---)(%.%,---) projet</FONT>
<FONT SIZE=5>$ exit # du su</FONT>
<FONT SIZE=5>$ exit # du script</FONT>

<FONT SIZE=5>script done on Fri May  5 10:37:18 1995</FONT></PRE><H1>
<FONT SIZE=5><!--TOC chapter <FONT SIZE=5>Multiplexer des entrées-sorties</FONT>-->Chapitre&nbsp;18&nbsp;&nbsp;
Multiplexer des entr&eacute;es-sorties</FONT></H1>
<P><!--SEC END --><FONT SIZE=5>Dans ce chapitre, nous voulons
pr&eacute;senter le probl&egrave;me des attentes actives sur
plusieurs descripteurs. Prenons par exemple un cas pratique assez
fr&eacute;quent d'un processus qui doit r&eacute;aliser une
communication entre deux autres, typiquement un gestionnaire de modem
qui doit d'une part recevoir des informations d'un processus
utilisateur, d'autre part recevoir des informations venant du
modem.<BR><BR>Ce qui nous donne la figure </FONT><A HREF="#modem"><FONT SIZE=5>18.1</FONT></A><FONT SIZE=5>.
</FONT>
</P>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML071.gif" NAME="Image73" ALIGN=BOTTOM WIDTH=559 HEIGHT=72 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
18.1&nbsp;: Un gestionaire de modem</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="modem"></A><BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<P><FONT SIZE=5>Mais ce processus doit donc passer son temps &agrave;
scruter les deux descripteurs &nbsp;: celui qui lui permet de savoir
ce que l'utilisateur tape et celui qui lui permet de lire les
informations venant de la ligne.<BR><BR><!--TOC subsection <FONT SIZE=5>Résolution avec deux processus</FONT>--></FONT><BR><BR>
</P>
<H3><FONT SIZE=5>18.0.2&nbsp;&nbsp; R&eacute;solution avec deux
processus</FONT></H3>
<P><!--SEC END --><FONT SIZE=5>Une fa&ccedil;on de r&eacute;soudre le
probl&egrave;me est de cr&eacute;er deux processus &nbsp;: un pour
chaque direction de la communication (figure </FONT><A HREF="#modem2"><FONT SIZE=5>18.2</FONT></A><FONT SIZE=5>).</FONT></P>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML072.gif" NAME="Image74" ALIGN=BOTTOM WIDTH=559 HEIGHT=158 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
18.2&nbsp;: Un gestionaire de modem avec deux processus</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="modem2"></A><BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<P><FONT SIZE=5>Mais dans ce cas, nous devons g&eacute;rer des
probl&egrave;mes de terminaison de processus. Quand le p&egrave;re
est tu&eacute; avant le fils, nous devons alors utiliser un signal
pour que le p&egrave;re dise au fils de se terminer, etc, et ceci
sans r&eacute;aliser une solution r&eacute;ellement propre.<!--TOC subsection <FONT SIZE=5>Solution avec le mode non bloquant</FONT>--></FONT></P>
<H3><FONT SIZE=5>18.0.3&nbsp;&nbsp; Solution avec le mode non
bloquant</FONT></H3>
<P><!--SEC END --><FONT SIZE=5>On peut aussi utiliser des
entr&eacute;e-sorties non bloquantes. Auquel cas notre processus de
gestion modem va r&eacute;aliser sans interruption des appels </FONT><TT><FONT SIZE=5>read</FONT></TT><FONT SIZE=5>
sur nos deux descripteurs. Le co&ucirc;t en ressources de cette
attente active est extr&ecirc;mement cher, et doit &ecirc;tre &eacute;vit&eacute;
dans le cas d'une machine en temps partag&eacute;.<!--TOC subsection <FONT SIZE=5>Utiliser les mécanismes asynchrones</FONT>--></FONT></P>
<H3><FONT SIZE=5>18.0.4&nbsp;&nbsp; Utiliser les m&eacute;canismes
asynchrones</FONT></H3>
<P><!--SEC END --><FONT SIZE=5>On peut utiliser des entr&eacute;es-sorties
asynchrones et demander au noyau de nous pr&eacute;venir par un
signal qui informe de l'arriv&eacute;e de donn&eacute;es sur un
descripteur. Ce signal est soit </FONT><TT><FONT SIZE=5>SIGPOLL</FONT></TT><FONT SIZE=5>,
soit </FONT><TT><FONT SIZE=5>SIGIO</FONT></TT><FONT SIZE=5>, mais ce
n'est valable que sur les descripteurs qui sont des p&eacute;riph&eacute;riques.
De plus ce m&eacute;canisme ne d&eacute;signe pas le descripteur sur
lequel s'est faite l'arriv&eacute;e de caract&egrave;res, d'o&ugrave;
de nouvelles pertes de temps d&ucirc;es aux appels r&eacute;alis&eacute;s
inutilement en mode non bloquant.<!--TOC section <FONT SIZE=5>Les outils de sélection</FONT>--></FONT></P>
<H2><FONT SIZE=5>18.1&nbsp;&nbsp; Les outils de s&eacute;lection</FONT></H2>
<P><!--SEC END --><FONT SIZE=5>La solution vient d'un syst&egrave;me
de s&eacute;lection qui prend un param&egrave;tre un ensemble de
descripteur, et peut tester si l'un de ses descripteurs est pr&egrave;s
&agrave; satisfaire un appel de </FONT><TT><FONT SIZE=5>read</FONT></TT><FONT SIZE=5>.
Cet appel est bloquant jusqu'&agrave; l'arriv&eacute;e de caract&egrave;res
sur un des descripteurs de l'ensemble.<!--TOC subsection <FONT SIZE=5>La primitive </FONT><FONT SIZE=5><TT>select</TT></FONT>--></FONT></P>
<H3><FONT SIZE=5>18.1.1&nbsp;&nbsp; La primitive </FONT><TT><FONT SIZE=5>select</FONT></TT></H3>
<P><!--SEC END --><FONT SIZE=5>Nous fournissont &agrave; la primitive
</FONT><TT><FONT SIZE=5>select</FONT></TT><FONT SIZE=5>&nbsp;: </FONT>
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Les descripteurs que
	nous voulons scruter. </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Les conditions de
	r&eacute;veil sur chaque descripteur (en attente de lecture,
	&eacute;criture, &eacute;v&egrave;nement ?) </FONT>
	</P>
	<LI><P><FONT SIZE=5>Combien de temps nous voulons attendre. </FONT>
	</P>
</UL>
<P><FONT SIZE=5>La fonction retourne pour chaque descripteur s'il est
pr&ecirc;t en lecture, &eacute;criture, ou si l'&eacute;v&egrave;nement
a eu lieu, et aussi le nombre de descripteur pr&ecirc;ts. Cette
information nous permet ensuite d'appeler </FONT><TT><FONT SIZE=5>read</FONT></TT><FONT SIZE=5>
ou </FONT><TT><FONT SIZE=5>write</FONT></TT><FONT SIZE=5> sur le(s)
bon(s) descripteur(s). </FONT>
</P>
<PRE>
<FONT SIZE=5>#include  &lt;sys/types.h&gt;</FONT>
<FONT SIZE=5>#include  &lt;sys/time.h&gt;</FONT>
<FONT SIZE=5>#include  &lt;unistd.h&gt;</FONT>

<FONT SIZE=5>int select(int maxfd,</FONT>
<FONT SIZE=5>           fd_set *readfds,</FONT>
<FONT SIZE=5>           fd_set *writefds,</FONT>
<FONT SIZE=5>           fd_set *exceptfds</FONT>
<FONT SIZE=5>           struct timeval *delai);</FONT></PRE><P>
<FONT SIZE=5>Retourne le nombre de descripteurs pr&ecirc;ts, 0 en cas
d'expiration du d&eacute;lai.<BR><BR><BR>Param&eacute;trage du
d&eacute;lai&nbsp;: </FONT>
</P>
<PRE>
<FONT SIZE=5>struct timeval {</FONT>
<FONT SIZE=5>    long tv_sec;</FONT>
<FONT SIZE=5>    long tv_usec;</FONT>
<FONT SIZE=5>};</FONT><DL>
	</PRE><DT>
	<TT><FONT SIZE=5>delai == NULL</FONT></TT></DT><DD>
	<FONT SIZE=5>Bloquant, attente infinie </FONT>
	</DD><DT>
	<TT><FONT SIZE=5>delai-&gt;tv_sec == 0 &amp;&amp; delai-&gt;tv_usec
	== 0 </FONT></TT>
	</DT><DD>
	<FONT SIZE=5>Non bloquant, retour imm&eacute;diat. </FONT>
	</DD><DT>
	<TT><FONT SIZE=5>delai-&gt;tv_sec &gt; 0 &amp;&amp; delai-&gt;tv_usec
	&gt;0 </FONT></TT>
	</DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>Semi bloquant, attente jusqu'&agrave; ce qu'un
	descripteur soit pr&ecirc;t ou que le d&eacute;lai en secondes plus
	microsecondes soit &eacute;coul&eacute;.</FONT></DD></DL>
<P>
<FONT SIZE=5>Les trois pointeurs (</FONT><TT><FONT SIZE=5>readfds</FONT></TT><FONT SIZE=5>,
</FONT><TT><FONT SIZE=5>writefds</FONT></TT><FONT SIZE=5>, et
</FONT><TT><FONT SIZE=5>exceptfds</FONT></TT><FONT SIZE=5>) sur des
ensembles de descripteurs sont utilis&eacute;s pour indiquer en
entr&eacute;e les situations qui nous int&eacute;ressent. C'est &agrave;
priori (cela peut varier avec l'impl&eacute;mentation) des tableaux
de bits avec un bit pour chaque descripteur du tableau de
descripteurs du processus. L'entier </FONT><TT><FONT SIZE=5>maxfd</FONT></TT><FONT SIZE=5>
est la position du dernier bit significatif de ce tableau de
bits.<BR><BR>Les seules fa&ccedil;ons de manipuler ces ensembles de
descripteurs sont&nbsp;: </FONT>
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Cr&eacute;ation </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Affectation </FONT>
	</P>
	<LI><P><FONT SIZE=5>Utilisation d'une des quatre macros suivantes&nbsp;:
	</FONT>
	</P>
</UL>
<DL>
	<DL>
		<DT STYLE="margin-right: 1cm; margin-bottom: 0.5cm"><TT><FONT SIZE=5>FD_ZERO(fd_set
		fdset)</FONT></TT></DT><DD STYLE="margin-right: 1cm; margin-bottom: 0.5cm">
		<FONT SIZE=5>RAZ de l'ensemble. </FONT>
		</DD><DT STYLE="margin-right: 1cm; margin-bottom: 0.5cm">
		<TT><FONT SIZE=5>FD_SET(int fd, fd_set *fdset)</FONT></TT></DT><DD STYLE="margin-right: 1cm; margin-bottom: 0.5cm">
		<FONT SIZE=5>Positionne le bit fd a 1. </FONT>
		</DD><DT STYLE="margin-right: 1cm; margin-bottom: 0.5cm">
		<TT><FONT SIZE=5>FD_CLR(int fd, fd_set *fdset)</FONT></TT></DT><DD STYLE="margin-right: 1cm; margin-bottom: 0.5cm">
		<FONT SIZE=5>Positionne le bit fd &agrave; 0 </FONT>
		</DD><DT STYLE="margin-right: 1cm; margin-bottom: 0.5cm">
		<TT><FONT SIZE=5>FD_ISSET(int fd, fd_set *fdset)</FONT></TT></DT><DD STYLE="margin-right: 1cm; margin-bottom: 0.5cm">
		<FONT SIZE=5>vrai si le bit fd est &agrave; 1 dans l'ensemble. </FONT>
		</DD></DL>
</DL>
<P>
<FONT SIZE=5>Un descripteur est consid&eacute;r&eacute; comme pr&ecirc;t
en lecture si un appel </FONT><TT><FONT SIZE=5>read</FONT></TT><FONT SIZE=5>
dessus ne sera pas bloquant. De m&ecirc;me, un descripteur est
consid&eacute;r&eacute; comme pr&ecirc;t en &eacute;criture si un
appel </FONT><TT><FONT SIZE=5>write</FONT></TT><FONT SIZE=5> ne sera
pas bloquant. Les exceptions / &eacute;v&egrave;nements sont d&eacute;finis
pour les lignes de communication qui acceptent les <I>messages hors
bande</I> comme les </FONT><TT><FONT SIZE=5>sockets</FONT></TT><FONT SIZE=5>
en mode datagramme.<!--TOC subsection <FONT SIZE=5>La primitive </FONT><FONT SIZE=5><TT>poll</TT></FONT>--></FONT></P>
<H3><FONT SIZE=5>18.1.2&nbsp;&nbsp; La primitive </FONT><TT><FONT SIZE=5>poll</FONT></TT></H3>
<P><!--SEC END --><FONT SIZE=5>La primitive </FONT><TT><FONT SIZE=5>poll</FONT></TT><FONT SIZE=5>
fournit un service proche de </FONT><TT><FONT SIZE=5>select</FONT></TT><FONT SIZE=5>
avec une autre forme d'interface.</FONT></P>
<PRE>
<FONT SIZE=5>#include &lt;stropts.h&gt;</FONT>
<FONT SIZE=5>#include &lt;poll.h&gt;</FONT>
<FONT SIZE=5>int poll(struct pollfd fdarray[],</FONT>
<FONT SIZE=5>         unsigned long nfds,</FONT>
<FONT SIZE=5>         int           timeout</FONT>
<FONT SIZE=5>  );</FONT>

<FONT SIZE=5>struct pollfd {</FONT>
<FONT SIZE=5>        int   fd;</FONT>
<FONT SIZE=5>        short events;</FONT>
<FONT SIZE=5>        short revents;</FONT>
<FONT SIZE=5>};</FONT></PRE><P>
<FONT SIZE=5>Ici on sp&eacute;cifie la liste de descripteurs et ce
que l'on veut sur chacun d'eux.<BR><BR>La valeur de retour est -1 en
cas d'erreur, 0 si le temps d'attente </FONT><TT><FONT SIZE=5>timeout
</FONT></TT><FONT SIZE=5>est &eacute;coul&eacute;, ou un entier
positif indiquant le nombre de descripteurs pour lesquels </FONT><TT><FONT SIZE=5>poll</FONT></TT><FONT SIZE=5>
a chang&eacute; la valeur du champ </FONT><TT><FONT SIZE=5>revents</FONT></TT><FONT SIZE=5>.<BR><BR><BR><BR>Les
&eacute;v&egrave;nements sont ici&nbsp;:<BR>Pour les &eacute;v&egrave;nements
de </FONT><TT><FONT SIZE=5>events</FONT></TT><FONT SIZE=5>&nbsp;: </FONT>
</P>
<DL>
	<DT><FONT SIZE=5>POLLIN</FONT></DT><DD>
	<FONT SIZE=5>Donn&eacute;es non prioritaire peuvent &ecirc;tre lues.
	</FONT>
	</DD><DT>
	<FONT SIZE=5>POLLRDNORM</FONT></DT><DD>
	<FONT SIZE=5>idem. </FONT>
	</DD><DT>
	<FONT SIZE=5>POLLRDBAND</FONT></DT><DD>
	<FONT SIZE=5>Donn&eacute;es non prioritaire non normales peuvent
	&ecirc;tre lues. </FONT>
	</DD><DT>
	<FONT SIZE=5>POLLPRI</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>Donn&eacute;es prioritaire peuvent &ecirc;tre lues.</FONT></DD><DT>
	<FONT SIZE=5>POLLOUT</FONT></DT><DD>
	<FONT SIZE=5>Donn&eacute;es non prioritaire peuvent &ecirc;tre
	&eacute;crites, les messages de haute priorit&eacute; peuvent
	toujours &ecirc;tres &eacute;crits. </FONT>
	</DD><DT>
	<FONT SIZE=5>POLLWRNORM</FONT></DT><DD>
	<FONT SIZE=5>idem </FONT>
	</DD><DT>
	<FONT SIZE=5>POLLWRBAND</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>Donn&eacute;es non prioritaire non normales peuvent
	&ecirc;tre &eacute;crites sans bloquer. </FONT>
	</DD></DL>
<P>
<FONT SIZE=5>Pour les </FONT><TT><FONT SIZE=5>revents</FONT></TT><FONT SIZE=5>
(valeurs de retour de la primitive </FONT><TT><FONT SIZE=5>poll</FONT></TT><FONT SIZE=5>)&nbsp;:</FONT></P>
<DL>
	<DT><FONT SIZE=5>POLLIN,POLLRDNORM,POLLRDBAND,POLLPRI</FONT></DT><DD>
	<FONT SIZE=5>les donn&eacute;es sont l&agrave;. </FONT>
	</DD><DT>
	<FONT SIZE=5>POLLOUT,POLLWRNORM, POLLWRBAND</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>l'&eacute;criture est possible</FONT></DD><DT>
	<FONT SIZE=5>POLLERR</FONT></DT><DD>
	<FONT SIZE=5>Une erreur a eu lieu. </FONT>
	</DD><DT>
	<FONT SIZE=5>POLLHUP</FONT></DT><DD>
	<FONT SIZE=5>La ligne a &eacute;t&eacute; coup&eacute;e. </FONT>
	</DD><DT>
	<FONT SIZE=5>POLLNVAL</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>Descripteur invalide.</FONT></DD></DL>
<P>
<FONT SIZE=5>Le mode de blocage de la primitive </FONT><TT><FONT SIZE=5>poll</FONT></TT><FONT SIZE=5>
d&eacute;pend du param&egrave;tre </FONT><TT><FONT SIZE=5>timeout</FONT></TT><FONT SIZE=5>
</FONT>
</P>
<DL>
	<DT><FONT SIZE=5>timeout == INFTIM</FONT></DT><DD>
	<FONT SIZE=5>Bloquant, INFTIM est d&eacute;fini dans </FONT><TT><CODE><FONT SIZE=5>stropts.h</FONT></CODE></TT><FONT SIZE=5>.
	</FONT>
	</DD><DT>
	<FONT SIZE=5>timeout == 0</FONT></DT><DD>
	<FONT SIZE=5>Non bloquant. </FONT>
	</DD><DT>
	<FONT SIZE=5>timeout &gt; 0</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>Semi bloquant, attente de </FONT><TT><FONT SIZE=5>timeout</FONT></TT><FONT SIZE=5>
	micro secondes. </FONT>
	</DD></DL>
<P>
<FONT SIZE=5><B>Un Exemple </B>Attente de donn&eacute;es sur ifd1 et
ifd2, de place pour &eacute;crire sur ofd, avec un d&eacute;lai
maximum de 10 seconds&nbsp;:<BR></FONT><TT><FONT SIZE=5>#include
&lt;poll.h&gt;<BR>struct pollfd fds[3];<BR>int ifd1, ifd2, ofd,
count;<BR><BR>fds[0].fd = ifd1;<BR>fds[0].events =
POLLNORM;<BR>fds[1].fd = ifd2;<BR>fds[1].events = POLLNORM;<BR>fds[2].fd
= ofd;<BR>fds[2].events = POLLOUT;<BR>count = poll(fds, 3, 10000);<BR>if
(count == -1) {<BR>perror(&quot;poll failed&quot;);<BR>exit(1);<BR>}<BR>if
(count==0)<BR>printf(&quot;Rien \n&quot;);<BR>if (fds[0].revents &amp;
POLLNORM)<BR>printf(&quot;Donn&eacute;es a lire sur ifd%d\n&quot;,
fds[0].fd);<BR>if (fds[1].revents &amp; POLLNORM)<BR>printf(&quot;Donn&eacute;es
a lire sur ifd%d\n&quot;, fds[1].fd);<BR>if (fds[2].revents &amp;
POLLOUT)<BR>printf(&quot;De la place sur fd%d\n&quot;, fds[2].fd);<!--TOC subsection <FONT SIZE=5>Les extensions de </FONT><FONT SIZE=5><TT>read</TT></FONT><FONT SIZE=5> et </FONT><FONT SIZE=5><TT>write</TT></FONT>-->
</FONT></TT>
</P>
<H3><FONT SIZE=5>18.1.3&nbsp;&nbsp; Les extensions de </FONT><TT><FONT SIZE=5>read</FONT></TT><FONT SIZE=5>
et </FONT><TT><FONT SIZE=5>write</FONT></TT></H3>
<P><!--SEC END --><FONT SIZE=5>Une extension </FONT><TT><FONT SIZE=5>readv,
writev</FONT></TT><FONT SIZE=5> de </FONT><TT><FONT SIZE=5>read</FONT></TT><FONT SIZE=5>
et </FONT><TT><FONT SIZE=5>write</FONT></TT><FONT SIZE=5> permet en
un seul appel syst&egrave;me de r&eacute;aliser l'&eacute;criture de
plusieurs zones m&eacute;moire non contigu&euml;s, ce qui permet
d'acc&eacute;lerer certaines entr&eacute;es-sorties structur&eacute;es.
Mais aussi de mieux organiser les appels syst&egrave;me dans notre
cas. </FONT>
</P>
<PRE>
<FONT SIZE=5>#include &lt;sys/types.h&gt;</FONT>
<FONT SIZE=5>#include &lt;sys/uio.h&gt;</FONT>

<FONT SIZE=5>ssize_t readv(int fd, const struct iovec iov[], int iovl);</FONT>
<FONT SIZE=5>ssize_t writev(int fd, const struct iovec iov[], int iovl);</FONT>

<FONT SIZE=5>struct iovec {</FONT>
<FONT SIZE=5>    void *iov_base ;</FONT>
<FONT SIZE=5>    int   iov_len;</FONT>
<FONT SIZE=5>};</FONT></PRE><H2>
<FONT SIZE=5><!--TOC section <FONT SIZE=5>une solution multi-activités</FONT>-->18.2&nbsp;&nbsp;
une solution multi-activit&eacute;s</FONT></H2>
<P><!--SEC END --><FONT SIZE=5>L'utilisation de plusieurs activit&eacute;s
(threads, voir chapitre </FONT><A HREF="#threads"><FONT SIZE=5>19</FONT></A><FONT SIZE=5>)
permet de r&eacute;aliser plusieurs appels de </FONT><TT><FONT SIZE=5>read</FONT></TT><FONT SIZE=5>
en simultan&eacute;, le premier </FONT><TT><FONT SIZE=5>read</FONT></TT><FONT SIZE=5>
qui se d&eacute;bloque entraine l'ex&eacute;cution de l'activit&eacute;
le r&eacute;alisant, ainsi le co&ucirc;t est minimal. Le seul
probl&egrave;me est d'avoir a g&eacute;rer cette multiplicit&eacute;
d'activit&eacute;s, ce qui est dans le cas de notre modem assez
facile car les deux activit&eacute;s sont ind&eacute;pendantes
(communication Full Duplex).<BR><BR>Pour une situation plus complexe
comme un serveur de partage de donn&eacute;es, des m&eacute;canismes
d'exclusion mutuelle entre activit&eacute;s devront &ecirc;tre mis en
oeuvre.<!--TOC chapter <FONT SIZE=5>Les micro-noyaux</FONT>--> </FONT>
</P>
<H1><FONT SIZE=5>Chapitre&nbsp;19&nbsp;&nbsp; Les micro-noyaux</FONT></H1>
<P><A NAME="threads"></A><FONT SIZE=5><!--SEC END -->Le principe des
micro-noyaux, fortement inspir&eacute; de l'approche objet, consiste
&agrave; d&eacute;couper le bloc monolithique qu'est le syst&egrave;me
d'exploitation, en un ensemble coh&eacute;rent de modules, qui
constituent autant de services sp&eacute;cialis&eacute;s sur lesquels
il suffira de &quot;brancher&quot; des interfaces. Ces micro-noyaux
sont en g&eacute;n&eacute;ral interfac&eacute;s avec un ensemble
d'appels syst&egrave;me de type unix ce qui permet de r&eacute;utiliser
des applications comme par exemple les shells.<BR><BR>Ce qui
distingue les syst&egrave;mes &agrave; micro-noyaux des syst&egrave;mes
classiques est la structure en modules logiciels ind&eacute;pendants,
appel&eacute;s modules syst&egrave;mes. Chacun d'eux est sp&eacute;cialiste
d'un fonctionnement de base du syst&egrave;me d'exploitation&nbsp;: </FONT>
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>gestion des processus
	(ex&eacute;cution, scheduling) </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>gestion de la m&eacute;moire
	(m&eacute;moire virtuelle) </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>gestion des
	entr&eacute;es/sorties </FONT>
	</P>
	<LI><P><FONT SIZE=5>gestion des messages (IPC) </FONT>
	</P>
</UL>
<P><FONT SIZE=5>Au-dessus de ces modules se trouve l'interface de
programmation qui est elle aussi ind&eacute;pendante et donc
th&eacute;oriquement interchangeable (en g&eacute;n&eacute;ral une
interface unix-posix).<BR><BR>Sous ces modules, on trouve le
micro-noyau qui en g&eacute;n&eacute;ral se limite &agrave; la
gestion des IPC entre modules comme par exemple MACH.<BR><BR>Quelques
syst&egrave;mes &agrave; micro-noyau&nbsp;:<B> MACH, CHORUS<!--TOC subsection <FONT SIZE=5>Les atouts des micro-noyaux</FONT>--></B></FONT></P>
<H3><FONT SIZE=5>19.0.1&nbsp;&nbsp; Les atouts des micro-noyaux</FONT></H3>
<P><FONT SIZE=5><!--SEC END -->Les diff&eacute;rents modules du
syst&egrave;me &eacute;tant d&eacute;finis au niveau &quot;utilisateur&quot;
et pas dans le noyau, il est donc plus facile de les &quot;debugger&quot;,
de les am&eacute;liorer etc ... (ceci n'est pas toujours vrai en
pratique). Seul le micro-noyau lui-m&ecirc;me n&eacute;cessite des
debuggeurs sp&eacute;ciaux.<BR><BR>La configuration du syst&egrave;me
se trouve simplifi&eacute;e car elle ne demande plus de recompiler le
noyau, &agrave; chaque ajout ou retrait de fonctionnalit&eacute;s
dans le syst&egrave;me : Oracle, modem, type disques diff&eacute;rents
etc.<BR><BR>C'est l'avenir.<BR><BR>C'est mieux adapt&eacute; aux
machines multi-processeurs, aux r&eacute;seaux.<!--TOC subsection <FONT SIZE=5>Quelques problèmes</FONT>--></FONT></P>
<H3><FONT SIZE=5>19.0.2&nbsp;&nbsp; Quelques probl&egrave;mes</FONT></H3>
<P><FONT SIZE=5><!--SEC END -->Un syst&egrave;me plus lent, qui
utilise en proportion beaucoup plus de m&eacute;moire pour lui mais
aussi pour tous les services qu'il rend. </FONT>
</P>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML073.gif" NAME="Image75" ALIGN=BOTTOM WIDTH=318 HEIGHT=366 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
19.1&nbsp;: Plusieurs modules syst&egrave;me qui utilisent un noyau
r&eacute;duit</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="micro-noyaux"></A><BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<H2><FONT SIZE=5><!--TOC section <FONT SIZE=5>Le système MACH (Carnegie Mellon University CMU)</FONT>-->19.1&nbsp;&nbsp;
Le syst&egrave;me MACH (Carnegie Mellon University CMU)</FONT></H2>
<P><FONT SIZE=5><!--SEC END -->Le syst&egrave;me Mach est donc un
syst&egrave;me avec un micro-noyau orient&eacute; communication.<BR><BR>Le
syst&egrave;me fournit les services suivants : </FONT>
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>T&acirc;ches
	multiples </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Threads multiples
	dans chaque t&acirc;che (avec scheduling). </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Partage flexible de
	m&eacute;moire entre t&acirc;ches </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Un syst&egrave;me de
	communication inter-processus par files de messages efficace et
	s&eacute;curis&eacute; </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>La projection de
	fichiers en m&eacute;moire </FONT>
	</P>
	<LI><P><FONT SIZE=5>Le noyau lui-m&ecirc;me ne fournit que les
	&eacute;l&eacute;ments les plus essentiels, c'est-&agrave;-dire
	scheduling IPC gestion de la m&eacute;moire virtuelle </FONT>
	</P>
</UL>
<P><FONT SIZE=5>Tous ces services et les autres sont fournis &agrave;
travers l'utilisation d'un seul type d'IPC (les messages).<!--TOC section <FONT SIZE=5>Le noyau MACH</FONT>-->
</FONT>
</P>
<H2><FONT SIZE=5>19.2&nbsp;&nbsp; Le noyau MACH</FONT></H2>
<P><FONT SIZE=5><!--SEC END -->En pratique, le noyau ne fournit que
les services n&eacute;cessaires &agrave; l'impl&eacute;mentation d'un
syst&egrave;me de communication entre diff&eacute;rents processus
utilisateurs (les modules syst&egrave;me par exemple).<BR><BR>Pour
cela, le noyau fournit un certain nombre d'abstractions utilisables
par le niveau module ou utilisateur. En particulier </FONT>
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Tasks (t&acirc;ches) </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Threads </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>Ports </FONT>
	</P>
	<LI><P><FONT SIZE=5>Messages </FONT>
	</P>
</UL>
<P><FONT SIZE=5>Les fonctions du noyaux sont donc </FONT>
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>cr&eacute;ation et
	gestion des t&acirc;ches et threads </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>gestion des ports </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>manipulations de base
	des messages </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>gestion de la m&eacute;moire
	virtuelle </FONT>
	</P>
	<LI><P><FONT SIZE=5>scheduling </FONT>
	</P>
</UL>
<H3><FONT SIZE=5><!--TOC subsection <FONT SIZE=5>Les Tâches et les Threads </FONT>-->19.2.1&nbsp;&nbsp;
Les T&acirc;ches et les Threads </FONT>
</H3>
<P><FONT SIZE=5><!--SEC END -->Dans les syst&egrave;mes UNIX
classiques, une abstraction fondamentale a &eacute;t&eacute; d&eacute;finie
&nbsp;: le processus. Cette abstraction recouvre &agrave; la fois un
ensemble de ressources (essentiellement de l'espace d'adressage, mais
aussi fichiers ouverts et autres) et une unit&eacute; d'ex&eacute;cution
unique, une seule activit&eacute;.<BR><BR>On trouve dans les
processus d'une part un programme que le processus ex&eacute;cute et
un ensemble de donn&eacute;es que le programme manipule (d&eacute;compos&eacute;
en donn&eacute;es et pile). Historiquement, la notion de r&eacute;entrance
a apport&eacute; la possibilit&eacute; de faire partager la zone
programme &agrave; plusieurs processus, chacun ayant une zone de
donn&eacute;es diff&eacute;rente. <BR><BR>Cette abstraction montre
ses limites avec l'arriv&eacute;e des machines multi-processus et
l'architecture logicielle clients/serveurs dans laquelle un serveur
se d&eacute;multiplie pour servir les diff&eacute;rents
clients.<BR><BR>Pour r&eacute;pondre &agrave; cette demande, une
premi&egrave;re approche a &eacute;t&eacute; de s&eacute;parer les
deux composantes essentielles du processus, c'est-&agrave;-dire d'une
part les ressources physiques, d'autre part les activit&eacute;s
(unit&eacute;s d'ex&eacute;cution) sur ces ressources (light process
de SUN). Cette id&eacute;e a fait son chemin et l'on parle
d'environnement d'ex&eacute;cution pour les ressources partag&eacute;es
--- ce sont les t&acirc;ches (tasks MACH) --- et l'on parle
d'activit&eacute;s (threads of control).<BR><BR>Sous MACH </FONT>
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>une t&acirc;che est
	un environnement d'ex&eacute;cution, c'est l'unit&eacute; de base de
	protection pour l'allocation des ressources (c'est la t&acirc;che
	qui est propri&eacute;taire des ressources). Elle comporte un espace
	d'adressage (4 Go) et des droits d'acc&egrave;s prot&eacute;g&eacute;s
	&agrave; certains ports. </FONT>
	</P>
	<LI><P><FONT SIZE=5>Une thread est l'unit&eacute; d'ex&eacute;cution
	de base. C'est un processus (une activit&eacute;) qui s'ex&eacute;cute
	dans la t&acirc;che (et uniquement dans la t&acirc;che). Elle est
	constitu&eacute;e essentiellement d'un sous-ensemble du P.C.B.
	(Processus Control Block d'UNIX) : les registres, une position dans
	la pile, un segment de pile propre, un pointeur dans le programme. </FONT>
	</P>
</UL>
<P><FONT SIZE=5>Une thread donn&eacute;e ne s'ex&eacute;cute que dans
une t&acirc;che donn&eacute;e, mais une t&acirc;che peut avoir
plusieurs threads. Toutes les threads partagent les ressources de la
t&acirc;che. Comme la t&acirc;che est l'unit&eacute; de protection,
les threads ne sont pas prot&eacute;g&eacute;es les unes des autres
!!<BR><BR>Les t&acirc;ches sont schedul&eacute;es comme les processus
UNIX.<BR><BR>A l'int&eacute;rieur d'une t&acirc;che, les diff&eacute;rentes
threads sont par d&eacute;faut schedul&eacute;es al&eacute;atoirement
(m&ecirc;me priorit&eacute;). Une thread ne s'ex&eacute;cute que si
elle et sa t&acirc;che sont ex&eacute;cutables.<!--TOC subsection <FONT SIZE=5>Ports &amp; Messages</FONT>--></FONT></P>
<H3><FONT SIZE=5>19.2.2&nbsp;&nbsp; Ports &amp; Messages</FONT></H3>
<P><FONT SIZE=5><!--SEC END -->Toutes les communications entre les
diff&eacute;rents modules (et objets) du syst&egrave;me sont
r&eacute;alis&eacute;es par des messages !<BR><BR>Trois abstractions
sont utilis&eacute;es pour impl&eacute;menter et manipuler le syst&egrave;me
de messages: </FONT>
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>ports </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>ports set (ensembles
	de ports) </FONT>
	</P>
	<LI><P><FONT SIZE=5>messages </FONT>
	</P>
</UL>
<P><FONT SIZE=5>Un port est un canal de communication prot&eacute;g&eacute;
(impl&eacute;ment&eacute; par une file de messages finie), sur lequel
des messages peuvent &ecirc;tre envoy&eacute;s et qui sont plac&eacute;s
dans la file &agrave; la r&eacute;ception. C'est aussi sous MACH
l'unit&eacute; de r&eacute;f&eacute;rence des objets : tout objet
n'est connu que par son port. Toute op&eacute;ration du syst&egrave;me
consiste &agrave; envoyer des messages vers le port d'un objet. Ainsi
quand une t&acirc;che est cr&eacute;e, le port associ&eacute; est
cr&eacute;e simultan&eacute;ment, quand une t&acirc;che est d&eacute;truite
son port est aussi d&eacute;truit.<BR><BR>Un port set (ensemble de
ports) est une file contenant les diff&eacute;rentes files des ports
de l'ensemble. Une thread peut gr&acirc;ce &agrave; ces ensembles de
ports attendre un message sur diff&eacute;rents ports en m&ecirc;me
temps.<BR><BR>Un message est une unit&eacute; de communication entre
objets &nbsp;: un message est envoy&eacute; au port qui repr&eacute;sente
l'objet. Un message est une unit&eacute; de donn&eacute;es constitu&eacute;e
de deux parties &nbsp;: un header de taille fixe et le corps des
donn&eacute;es compos&eacute; de z&eacute;ro ou plusieurs objets
typ&eacute;s (donn&eacute;es typ&eacute;es).<BR><BR>Le header d&eacute;crit
la taille, le type et la destination du message. Le corps contient le
contenu ou un pointeur sur le contenu du message.<BR><BR>Il n'y a pas
de limite ni sur la taille ni sur le contenu des messages.<BR><BR>A
l'inverse des files de message des IPC standard d'UNIX, il est
possible d'&eacute;changer des pointeurs entre t&acirc;ches. Les
conversions d'adressages entre les m&eacute;moires virtuelles des
diff&eacute;rentes t&acirc;ches &eacute;tant r&eacute;alis&eacute;es
automatiquement dans presque tous les cas &nbsp;: c'est un avantage
ind&eacute;niable, qui permet par exemple de r&eacute;aliser un </FONT><TT><FONT SIZE=5>fork</FONT></TT><FONT SIZE=5>
par un simple message contenant tout l'espace d'adressage de la t&acirc;che
r&eacute;alisant le </FONT><TT><FONT SIZE=5>fork</FONT></TT><FONT SIZE=5>
!<BR><BR>Le noyau ne manipule que des messages. Les seules
interruptions bas niveau sont celles aff&eacute;rentes a la gestion
des messages. Les autres sont r&eacute;alis&eacute;es par des envois
de messages par le port de la t&acirc;che.<BR><BR>Les threads peuvent
utiliser les ports pour communiquer entre elles dans une m&ecirc;me
t&acirc;che, ou avec une autre t&acirc;che, et de plus, comme les
ports sont &quot;visibles&quot; au niveau du r&eacute;seau, on peut
communiquer avec un objet sur une autre machine !<!--TOC subsection <FONT SIZE=5>Task Threads &amp; Ports</FONT>--></FONT></P>
<H3><FONT SIZE=5>19.2.3&nbsp;&nbsp; Task Threads &amp; Ports</FONT></H3>
<P><!--SEC END --><FONT SIZE=5>Les t&acirc;ches et les Threads sont
repr&eacute;sent&eacute;es par des ports (les ports sont des files de
message identifi&eacute;es).<BR><BR>Le port de la t&acirc;che ou de
la thread permet au syst&egrave;me d'identifier quelle t&acirc;che ou
thread doit &ecirc;tre affect&eacute;e par un appel syst&egrave;me
donn&eacute;.<BR><BR>[Sous UNIX, ce r&ocirc;le d'identification est
r&eacute;alis&eacute; par la table des processus et le pid du
processus.]<BR><BR></FONT><TT><CODE><FONT SIZE=5>task_self()</FONT></CODE></TT><FONT SIZE=5>
et </FONT><TT><CODE><FONT SIZE=5>thread_self()</FONT></CODE></TT><FONT SIZE=5>
retourne le port associ&eacute; &agrave; la t&acirc;che, ou la thread
qui ex&eacute;cute la primitive.<BR><BR>Une t&acirc;che ou Thread
peut avoir acc&egrave;s au port d'une autre (t&acirc;che ou thread)
et peut r&eacute;aliser des appels syst&egrave;me pour ou avec cette
autre t&acirc;che/thread.<!--TOC section <FONT SIZE=5>Les threads POSIX </FONT>--></FONT></P>
<H2><FONT SIZE=5>19.3&nbsp;&nbsp; Les threads POSIX </FONT>
</H2>
<P><!--SEC END --><FONT SIZE=5>Organisation en m&eacute;moire pour un
processus UNIX avec plusieurs threads &nbsp;: voir figure </FONT><A HREF="#micro-noyaux-pile"><FONT SIZE=5>19.2</FONT></A><FONT SIZE=5>.
</FONT>
</P>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML074.gif" NAME="Image76" ALIGN=BOTTOM WIDTH=317 HEIGHT=446 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
19.2&nbsp;: Organisation m&eacute;moire, partage des fonctions entre
le processus et les activit&eacute;s</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="micro-noyaux-pile"></A>
<BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<H3><!--TOC subsection <FONT SIZE=5><TT>fork</TT></FONT><FONT SIZE=5> et </FONT><FONT SIZE=5><TT>exec</TT></FONT>--><FONT SIZE=5>19.3.1&nbsp;&nbsp;
</FONT><TT><FONT SIZE=5>fork</FONT></TT><FONT SIZE=5> et </FONT><TT><FONT SIZE=5>exec</FONT></TT></H3>
<P><!--SEC END --><FONT SIZE=5>Apr&egrave;s un </FONT><TT><FONT SIZE=5>fork</FONT></TT><FONT SIZE=5>,
le fils ne contient qu'une seule activit&eacute; (celle qui a ex&eacute;cut&eacute;
le </FONT><TT><FONT SIZE=5>fork</FONT></TT><FONT SIZE=5>). Attention
aux variables d'exclusion mutuelle (qui font partie de l'espace
d'adressage partag&eacute;) qui sont conserv&eacute;es apr&egrave;s
le </FONT><TT><FONT SIZE=5>fork()</FONT></TT><FONT SIZE=5> et dont le
contenu ne varie pas. Ainsi si une activit&eacute; a pris le
s&eacute;maphore avant le </FONT><TT><FONT SIZE=5>fork()</FONT></TT><FONT SIZE=5>,
si l'activit&eacute; principale cherche &agrave; prendre ce s&eacute;maphore
apr&egrave;s le </FONT><TT><FONT SIZE=5>fork()</FONT></TT><FONT SIZE=5>
elle sera ind&eacute;finiment bloqu&eacute;e.<BR><BR>Apr&egrave;s un
</FONT><TT><FONT SIZE=5>exec</FONT></TT><FONT SIZE=5>, le processus
ne contient plus que la thread qui a ex&eacute;cut&eacute; l'une des
six commandes </FONT><TT><FONT SIZE=5>exec</FONT></TT><FONT SIZE=5>.
Pas de probl&egrave;me avec les s&eacute;maphores comme l'espace
d'adressage a chang&eacute;.<!--TOC subsection <FONT SIZE=5>Les noms de fonctions</FONT>--></FONT></P>
<H3><FONT SIZE=5>19.3.2&nbsp;&nbsp; Les noms de fonctions</FONT></H3>
<PRE><!--SEC END -->
<FONT SIZE=5>pthread[_objet]_operation[_np]</FONT></PRE><P>
<FONT SIZE=5>o&ugrave; </FONT>
</P>
<DL>
	<DT><FONT SIZE=5>objet</FONT></DT><DD>
	<FONT SIZE=5>d&eacute;signe si il est pr&eacute;sent le type de
	l'objet auquel la fonction s'applique. Les valeurs possibles de
	objet peuvent &ecirc;tre </FONT><TT><FONT SIZE=5>cond</FONT></TT><FONT SIZE=5>
	pour une variable de condition </FONT><TT><FONT SIZE=5>mutex</FONT></TT><FONT SIZE=5>
	pour un s&eacute;maphore d'exclusion mutuelle </FONT>
	</DD><DT>
	<FONT SIZE=5>op&eacute;ration</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>d&eacute;signe l'op&eacute;ration a r&eacute;aliser,
	par exemple </FONT><TT><FONT SIZE=5>create</FONT></TT><FONT SIZE=5>,
	</FONT><TT><FONT SIZE=5>exit</FONT></TT><FONT SIZE=5> ou </FONT><TT><FONT SIZE=5>init</FONT></TT><FONT SIZE=5>
	</FONT>
	</DD></DL>
<P>
<FONT SIZE=5>le suffixe </FONT><TT><FONT SIZE=5>np</FONT></TT><FONT SIZE=5>
indique, si il est pr&eacute;sent, qu'il s'agit d'une fontion non
portable, c'est-&agrave;-dire Hors Norme.<!--TOC subsection <FONT SIZE=5>les noms de types</FONT>--></FONT></P>
<H3><FONT SIZE=5>19.3.3&nbsp;&nbsp; les noms de types</FONT></H3>
<PRE><!--SEC END -->
<FONT SIZE=5>pthread[_objet]_t</FONT></PRE><P>
<FONT SIZE=5>avec </FONT><TT><FONT SIZE=5>objet</FONT></TT><FONT SIZE=5>
prenant comme valeur </FONT><TT><FONT SIZE=5>cond</FONT></TT><FONT SIZE=5>,
</FONT><TT><FONT SIZE=5>mutex</FONT></TT><FONT SIZE=5> ou rien pour
une thread.<!--TOC subsection <FONT SIZE=5>Attributs d'une activité</FONT>--></FONT></P>
<H3><FONT SIZE=5>19.3.4&nbsp;&nbsp; Attributs d'une activit&eacute;</FONT></H3>
<P><FONT SIZE=5><!--SEC END -->Identification d'une pthread &nbsp;:
le TID de type pthread_t obtenu par un appel &agrave; la primitive&nbsp;:
</FONT>
</P>
<PRE>
<FONT SIZE=5>pthread_t pthread_self(void);</FONT></PRE><P>
<FONT SIZE=5>pour le processus propri&eacute;taire </FONT>
</P>
<PRE>
<FONT SIZE=5>pid_t getpid(void);</FONT></PRE><P>
<FONT SIZE=5>Les diff&eacute;rentes activit&eacute;s d'un processus
sont num&eacute;rot&eacute;es &agrave; partir de 1. Un processus UNIX
standard a une seule activit&eacute; de num&eacute;ro 1.<BR><BR>Pour
tuer une activit&eacute; donn&eacute;e dans un processus donn&eacute;,
on utilisera la commande shell </FONT><TT><FONT SIZE=5>kill</FONT></TT><FONT SIZE=5>
avec comme param&egrave;tre </FONT><TT><FONT SIZE=5>pid.tid</FONT></TT><FONT SIZE=5>.<BR>Exemple:<BR>kill
-9 12345.3<BR><BR>En POSIX, le fait de tuer la thread de num&eacute;ro
1 a pour effet de tuer le processus ainsi que toutes les autres
threads &eacute;ventuelles du processus.<BR><BR>Pour tester l'&eacute;galit&eacute;
de deux pthreads on utilise </FONT>
</P>
<PRE>
<FONT SIZE=5>int pthread_equal(pthread_t tid1, pthread_t tid2);</FONT></PRE><H3>
<FONT SIZE=5><!--TOC subsection <FONT SIZE=5>Création et terminaison des activités</FONT>-->19.3.5&nbsp;&nbsp;
Cr&eacute;ation et terminaison des activit&eacute;s</FONT></H3>
<H4><FONT SIZE=5><!--SEC END --><!--TOC subsubsection <FONT SIZE=5>Création</FONT>-->Cr&eacute;ation</FONT></H4>
<PRE><!--SEC END -->
<FONT SIZE=5>int pthread_create (pthread_t      *p_tid,</FONT>
<FONT SIZE=5>                    pthread_attr_t attr,</FONT>
<FONT SIZE=5>                    void           *(*fonction) (void *arg),</FONT>
<FONT SIZE=5>                    void           *arg</FONT>
<FONT SIZE=5>                   );</FONT></PRE><P>
<FONT SIZE=5>La cr&eacute;ation et l'activation d'une activit&eacute;
retourne -1 en cas d'echec, 0 sinon. </FONT>
</P>
<UL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>le tid de la nouvelle
	thread est plac&eacute; &agrave; l'adresse </FONT><TT><CODE><FONT SIZE=5>p_tid</FONT></CODE></TT><FONT SIZE=5>
	</FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><TT><FONT SIZE=5>attr</FONT></TT><FONT SIZE=5>
	attribut de l'activit&eacute; (ordonnancement), utiliser
	</FONT><TT><FONT SIZE=5>pthread_attr_default</FONT></TT><FONT SIZE=5>
	</FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>la param&egrave;tre
	</FONT><TT><FONT SIZE=5>fonction</FONT></TT><FONT SIZE=5> correspond
	&agrave; la fonction ex&eacute;cut&eacute;e par l'activit&eacute;
	apr&egrave;s sa cr&eacute;ation : il s'agit donc de son point
	d'entr&eacute;e (comme la fonction </FONT><TT><FONT SIZE=5>main</FONT></TT><FONT SIZE=5>
	pour les processus). Un retour de cette fonction correspondra &agrave;
	la terminaison de cette activit&eacute;. </FONT>
	</P>
	<LI><P><FONT SIZE=5>le param&egrave;tre </FONT><TT><FONT SIZE=5>arg</FONT></TT><FONT SIZE=5>
	est transmis &agrave; la fonction au lancement de l'activit&eacute;.
	</FONT>
	</P>
</UL>
<H4><FONT SIZE=5><!--TOC subsubsection <FONT SIZE=5>Terminaison</FONT>-->Terminaison</FONT></H4>
<P><!--SEC END --><FONT SIZE=5>a) les appels UNIX </FONT><TT><FONT SIZE=5>exit</FONT></TT><FONT SIZE=5>
et </FONT><TT><FONT SIZE=5>_exit</FONT></TT><FONT SIZE=5> terminent
toutes les threads du processus. <BR><BR>b) Terminaison d'une thread</FONT></P>
<PRE>
<FONT SIZE=5> int pthread_exit (int *p_status);</FONT></PRE><P>
<TT><FONT SIZE=5>p_status</FONT></TT><FONT SIZE=5> code retour de la
thread, comme dans les processus UNIX la thread est zombifi&eacute;e
pour attendre la lecture du code de retour par une autre thread. A
l'inverse des processus, comme il peut y avoir plusieurs threads qui
attendent, la thread zombie n'est pas lib&eacute;r&eacute;e par la
lecture du p_status, il faut pour cela utiliser une commande sp&eacute;ciale
qui permettra de lib&eacute;rer effectivement l'espace m&eacute;moire
utilis&eacute; par la thread.<BR><BR>Cette destruction est
explicitement demand&eacute;e par la commande </FONT>
</P>
<PRE>
<FONT SIZE=5>int pthread_detach (pthread_t *p_tid);</FONT></PRE><P>
<FONT SIZE=5>Si un tel appel a lieu alors que l'activit&eacute; est
en cours d'ex&eacute;cution, cela indique seulement qu'&agrave;
l'ex&eacute;cution de </FONT><TT><CODE><FONT SIZE=5>pthread_exit</FONT></CODE></TT><FONT SIZE=5>
les ressources seront restitu&eacute;es.<!--TOC section <FONT SIZE=5>Synchronisation</FONT>--></FONT></P>
<H2><FONT SIZE=5>19.4&nbsp;&nbsp; Synchronisation</FONT></H2>
<P><FONT SIZE=5><!--SEC END -->Trois m&eacute;canismes de
synchronisation inter-activit&eacute;s : </FONT>
</P>
<UL>
	<LI><P><FONT SIZE=5>la primitive </FONT><TT><FONT SIZE=5>join</FONT></TT></P>
	<LI><P><FONT SIZE=5>les s&eacute;maphores d'exclusion mutuelle </FONT>
	</P>
	<LI><P><FONT SIZE=5>les conditions (&eacute;v&egrave;nements) </FONT>
	</P>
</UL>
<H3><FONT SIZE=5><!--TOC subsection <FONT SIZE=5>Le modèle fork/join (Paterson)</FONT>-->19.4.1&nbsp;&nbsp;
Le mod&egrave;le fork/join (Paterson)</FONT></H3>
<P><FONT SIZE=5><!--SEC END -->Les rendez-vous : join <BR><BR>La
primitive </FONT>
</P>
<PRE>
<FONT SIZE=5>int pthread_join (pthread_t tid, int **status);</FONT></PRE><P>
<FONT SIZE=5>permet de suspendre l'ex&eacute;cution de l'activit&eacute;
courante jusqu'&agrave; ce que l'activit&eacute; </FONT><TT><FONT SIZE=5>tid</FONT></TT><FONT SIZE=5>
ex&eacute;cute un appel (implicite ou explicite) &agrave;
</FONT><TT><FONT SIZE=5>pthread_exit</FONT></TT><FONT SIZE=5>. Si
l'activit&eacute; </FONT><TT><FONT SIZE=5>tid</FONT></TT><FONT SIZE=5>
est d&eacute;j&agrave; termin&eacute;e, le retour est imm&eacute;diat,
et le code de retour de l'activit&eacute; vis&eacute;e est &eacute;gal
&agrave; **status (double indirection).<BR><BR>La primitive retourne
&nbsp;:<BR>0 en cas de succ&egrave;s<BR>-1 en cas d'erreur</FONT></P>
<DL>
	<DT><FONT SIZE=5>EINVAL</FONT></DT><DD>
	<FONT SIZE=5>si le </FONT><TT><FONT SIZE=5>tid</FONT></TT><FONT SIZE=5>
	est incorrect </FONT>
	</DD><DT>
	<FONT SIZE=5>ESRCH</FONT></DT><DD>
	<FONT SIZE=5>activit&eacute; inexistante </FONT>
	</DD><DT>
	<FONT SIZE=5>EDEADLOCK</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>l'attente de l'activit&eacute; sp&eacute;cifi&eacute;e
	conduit &agrave; un interblocage. </FONT>
	</DD></DL>
<H3>
<FONT SIZE=5><!--TOC subsection <FONT SIZE=5>Le problème de l'exclusion mutuelle sur les variables gérées par le noyau</FONT>-->19.4.2&nbsp;&nbsp;
Le probl&egrave;me de l'exclusion mutuelle sur les variables g&eacute;r&eacute;es
par le noyau</FONT></H3>
<P><!--SEC END --><FONT SIZE=5>Il est n&eacute;cessaire d'avoir
plusieurs variables </FONT><TT><FONT SIZE=5>errno</FONT></TT><FONT SIZE=5>,
une par activit&eacute;. En effet cette variable globale pourrait
&ecirc;tre chang&eacute;e par une autre activit&eacute;. Voir plus
loin comment d&eacute;finir des variables globales locales &agrave;
chaque activit&eacute;.</FONT></P>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML075.gif" NAME="Image77" ALIGN=BOTTOM WIDTH=318 HEIGHT=270 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
19.3&nbsp;: Changement de la valeur </FONT><TT><FONT SIZE=5>errno</FONT></TT><FONT SIZE=5>
par une autre thread</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="threaderrno"></A><BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<H3><FONT SIZE=5><!--TOC subsection <FONT SIZE=5>Les sémaphores d'exclusion mutuelle</FONT>-->19.4.3&nbsp;&nbsp;
Les s&eacute;maphores d'exclusion mutuelle</FONT></H3>
<P><FONT SIZE=5><!--SEC END -->Ces s&eacute;maphores binaires
permettent d'assurer l'exclusion mutuelle. </FONT>
</P>
<UL>
	<LI><P><FONT SIZE=5>Il faut d&eacute;finir un objet de type
	</FONT><TT><FONT SIZE=5>pthread_mutex_t</FONT></TT><FONT SIZE=5> qui
	correspond &agrave; un ensemble d'attributs de type
	</FONT><TT><FONT SIZE=5>pthread_mutexattr_t</FONT></TT><FONT SIZE=5><BR>(on
	utilisera en g&eacute;n&eacute;ral la constante
	</FONT><TT><FONT SIZE=5>pthread_mutexattr_default</FONT></TT><FONT SIZE=5>
	).</FONT></P>
	<LI><P><FONT SIZE=5>Initialiser la variable par un appel &agrave; la
	fonction </FONT>
	</P>
	<PRE>
<FONT SIZE=5>int pthread_mutex_init(pthread_mutex_t     *p_mutex,</FONT>
<FONT SIZE=5>                       pthread_mutexattr_t attr);</FONT></PRE>
	<LI><P><FONT SIZE=5>On pourra d&eacute;truire le s&eacute;maphore
	par un appel &agrave; la fonction </FONT>
	</P>
	<PRE>
<FONT SIZE=5>int pthread_mutex_destroy(pthread_mutex_t *p_mutex);</FONT></PRE>
</UL>
<H3><FONT SIZE=5><!--TOC subsection <FONT SIZE=5>Utilisation des sémaphores</FONT>-->19.4.4&nbsp;&nbsp;
Utilisation des s&eacute;maphores</FONT></H3>
<P><FONT SIZE=5><!--SEC END -->Op&eacute;ration P &nbsp;:<BR>Un appel
&agrave; la fonction </FONT>
</P>
<PRE>
<FONT SIZE=5>pthread_mutex_lock (pthread_mutex_t *pmutex);</FONT></PRE><P>
<FONT SIZE=5>permet &agrave; une activit&eacute; de r&eacute;aliser
une op&eacute;ration P sur le s&eacute;maphore. Si le s&eacute;maphore
est d&eacute;j&agrave; utilis&eacute;, l'activit&eacute; est bloqu&eacute;e
jusqu'&agrave; la r&eacute;alisation de l'op&eacute;ration V (par une
autre activit&eacute;) qui lib&egrave;rera le s&eacute;maphore.<BR><BR>Op&eacute;ration
P non bloquante &nbsp;: </FONT>
</P>
<PRE>
<FONT SIZE=5>pthread_mutex_trylock (pthread_mutex_t *pmutex);</FONT></PRE><P>
<FONT SIZE=5>renvoie 1 si le s&eacute;maphore est libre <BR>0 si le
s&eacute;maphore est occup&eacute; par une autre activit&eacute;<BR>-1
en cas d'erreur.<BR>Op&eacute;ration V &nbsp;:<BR>Un appel &agrave;
la fonction </FONT>
</P>
<PRE>
<FONT SIZE=5>pthread_mutex_unlock(pthread_mutex_t *pmutex);</FONT></PRE><P>
<FONT SIZE=5>r&eacute;alise la lib&eacute;ration du s&eacute;maphore
d&eacute;sign&eacute;.<!--TOC subsection <FONT SIZE=5>Les conditions (évènements)</FONT>--></FONT></P>
<H3><FONT SIZE=5>19.4.5&nbsp;&nbsp; Les conditions (&eacute;v&egrave;nements)</FONT></H3>
<P><!--SEC END --><FONT SIZE=5>Les conditions permettent de bloquer
une activit&eacute; sur une attente d'&eacute;v&egrave;nement. Pour
cela l'activit&eacute; doit poss&eacute;der un s&eacute;maphore,
l'activit&eacute; peut alors lib&eacute;rer le s&eacute;maphore sur
l'&eacute;v&egrave;nement, c'est-&agrave;-dire : elle lib&egrave;re
le s&eacute;maphore, se bloque en attente de l'&eacute;v&egrave;nement,
&agrave; la r&eacute;ception de l'&eacute;v&egrave;nement elle
reprend le s&eacute;maphore.<BR><BR><B>Initialisation</B> d'une
variable de type </FONT><CODE><TT><FONT SIZE=5>pthread_cond_t</FONT></TT></CODE><FONT SIZE=5>
</FONT>
</P>
<PRE>
<FONT SIZE=5>int pthread_cond_init (pthread_cond_t *p_cond, pthread_condattr_t attr);</FONT></PRE><P>
<FONT SIZE=5>L'attente sur une condition </FONT>
</P>
<PRE>
<FONT SIZE=5>int pthread_cond_wait (pthread_cond_t *p_cond, pthread_mutex_t *p_mutex);</FONT></PRE><P>
<FONT SIZE=5>Trois &eacute;tapes </FONT>
</P>
<OL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>lib&eacute;ration sur
	s&eacute;maphore *p_mutex </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>activit&eacute; mise
	en sommeil sur l'&eacute;v&egrave;nement </FONT>
	</P>
	<LI><P><FONT SIZE=5>r&eacute;ception de l'&eacute;v&egrave;nement,
	r&eacute;cup&eacute;ration du s&eacute;maphore </FONT>
	</P>
</OL>
<P><FONT SIZE=5>La condition est ind&eacute;pendante de l'&eacute;v&eacute;nement
et n'est pas n&eacute;cessairement valide &agrave; la r&eacute;ception
(cf. exemple).<BR><BR>Exemple, le programme suivant: </FONT>
</P>
<PRE>
<FONT SIZE=5>pthread_mutex_t m;</FONT>
<FONT SIZE=5>pthread_cond_t  cond;</FONT>
<FONT SIZE=5>int             condition = 0;</FONT>

<FONT SIZE=5>void *ecoute(void *beurk)</FONT>
<FONT SIZE=5>{</FONT>
<FONT SIZE=5>    pthread_mutex_lock(m);</FONT>
<FONT SIZE=5>    sleep(5);</FONT>
<FONT SIZE=5>    while (!condition)</FONT>
<FONT SIZE=5>        pthread_cond_wait(cond, m);</FONT>
<FONT SIZE=5>    pthread_mutex_unlock(m);</FONT>

<FONT SIZE=5>    pthread_mutex_lock(print);</FONT>
<FONT SIZE=5>    printf(&quot; Condition realisee\n&quot;);</FONT>
<FONT SIZE=5>    pthread_mutex_unlock(print);</FONT>
<FONT SIZE=5>}</FONT>

<FONT SIZE=5>main()</FONT>
<FONT SIZE=5>{</FONT>
<FONT SIZE=5>    pthread_t lathread;</FONT>

<FONT SIZE=5>    pthread_create(lathread, pthread_attr_default, ecoute, NULL);</FONT>
<FONT SIZE=5>    sleep(1);</FONT>
<FONT SIZE=5>    pthread_mutex_lock(m);</FONT>
<FONT SIZE=5>    condition = 1;</FONT>
<FONT SIZE=5>    pthread_mutex_unlock(m);</FONT>
<FONT SIZE=5>    pthread_cond_signal(cond);</FONT>
<FONT SIZE=5>}</FONT>
</PRE><P>
<FONT SIZE=5>Un autre exemple d'utilisation de condition avec deux
threads qui utilisent deux tampons pour r&eacute;aliser la commande
cp, avec une activit&eacute; responsable de la lecture et l'autre de
l'&eacute;criture. Les conditions permettent de synchroniser les deux
threads. Ici nous utilisons la syntaxe NeXT/MACH. </FONT>
</P>
<PRE>
<FONT SIZE=5>#include &lt;sdtio.h&gt; </FONT>
<FONT SIZE=5>#include &lt;fcntl.h&gt;</FONT>
<FONT SIZE=5>#import  &lt;mach/cthreads.h&gt;</FONT>

<FONT SIZE=5>enum { BUFFER_A_LIRE = 1, BUFFER_A_ECRIRE = -1 };</FONT>

<FONT SIZE=5>mutex_t     lock1;  /* variables de protection et d'exclusion */</FONT>
<FONT SIZE=5>condition_t cond1;</FONT>

<FONT SIZE=5>char buff1[BUFSIZ];</FONT>
<FONT SIZE=5>int  nb_lu1;</FONT>
<FONT SIZE=5>int  etat1 = BUFFER_A_LIRE;</FONT>
<FONT SIZE=5>int  ds, dd;        /* descripteurs source et destination */</FONT>

<FONT SIZE=5>lire()         /* activite lecture */</FONT>
<FONT SIZE=5>{</FONT>
<FONT SIZE=5>    for(;;)  { /* lecture dans le buffer 1 */</FONT>
<FONT SIZE=5>        mutex_lock(lock1);</FONT>
<FONT SIZE=5>        while (etat1 == BUFFER_A_ECRIRE)</FONT>
<FONT SIZE=5>            condition_wait(cond1, lock1);</FONT>
<FONT SIZE=5>        nb_lu1 = read(ds, buff1, BUFSIZ);</FONT>
<FONT SIZE=5>        if (nb_lu1 == 0)</FONT>
<FONT SIZE=5>        {</FONT>
<FONT SIZE=5>            etat1 = BUFFER_A_ECRIRE;</FONT>
<FONT SIZE=5>            condition_signal(cond1);</FONT>
<FONT SIZE=5>            mutex_unlock(lock1);</FONT>
<FONT SIZE=5>            break;</FONT>
<FONT SIZE=5>        }</FONT>
<FONT SIZE=5>        etat1 = BUFFER_A_ECRIRE;</FONT>
<FONT SIZE=5>        condition_signal(cond1);</FONT>
<FONT SIZE=5>        mutex_unlock(lock1);</FONT>
<FONT SIZE=5>    }</FONT>
<FONT SIZE=5>}</FONT>

<FONT SIZE=5>ecrire()</FONT>
<FONT SIZE=5>{</FONT>
<FONT SIZE=5>    for(;;)</FONT>
<FONT SIZE=5>    { /* ecriture du buffer 1 */        </FONT>
<FONT SIZE=5>        mutex_lock(lock1);</FONT>
<FONT SIZE=5>        while (etat1 == BUFFER_A_LIRE)</FONT>
<FONT SIZE=5>            condition_wait(cond1, lock1);</FONT>
<FONT SIZE=5>        if (nb_lu1 == 0)</FONT>
<FONT SIZE=5>        {</FONT>
<FONT SIZE=5>            mutex_unlock(lock1);</FONT>
<FONT SIZE=5>            exit(0);</FONT>
<FONT SIZE=5>        }</FONT>
<FONT SIZE=5>        write(dd, buff1, nb_lu1);</FONT>
<FONT SIZE=5>        mutex_unlock(lock1);</FONT>
<FONT SIZE=5>        etat1 = BUFFER_A_LIRE;</FONT>
<FONT SIZE=5>        condition_signal(cond1);</FONT>
<FONT SIZE=5>    }</FONT>
<FONT SIZE=5>}</FONT>

<FONT SIZE=5>main()</FONT>
<FONT SIZE=5>{</FONT>
<FONT SIZE=5>    ds    = open(argv[1], O_RDONLY);</FONT>
<FONT SIZE=5>    dd    = open(argv[2], O_WRONLY|O_TRUNC|O_CREAT, 0666);</FONT>
<FONT SIZE=5>    lock1 = mutex_alloc();</FONT>
<FONT SIZE=5>    cond1 = condition_alloc();</FONT>

<FONT SIZE=5>    cthread_fork((cthread_fn_t)lire, (any_t)0);</FONT>
<FONT SIZE=5>    ecrire(); /* la thread principale realise les ecritures */</FONT>
<FONT SIZE=5>}</FONT></PRE><H2>
<FONT SIZE=5><!--TOC section <FONT SIZE=5>Ordonnancement des activités</FONT>-->19.5&nbsp;&nbsp;
Ordonnancement des activit&eacute;s</FONT></H2>
<H3><FONT SIZE=5><!--SEC END --><!--TOC subsection <FONT SIZE=5>L'ordonnancement POSIX des activités</FONT>-->19.5.1&nbsp;&nbsp;
L'ordonnancement POSIX des activit&eacute;s</FONT></H3>
<P><!--SEC END --><FONT SIZE=5>L'ordonnancement des activit&eacute;s
DCE bas&eacute; sur POSIX est tr&egrave;s similaire &agrave;
l'ordonnancement des activit&eacute;s sous MACH. Deux valeurs
permettent de d&eacute;finir le mode d'ordonnancement d'une activit&eacute;
&nbsp;:<BR>la politique et la priorit&eacute;.<BR>Pour manipuler ces
deux valeurs, il vous faut cr&eacute;er un objet attribut d'activit&eacute;
(</FONT><TT><CODE><FONT SIZE=5>pthread_attr</FONT></CODE></TT><FONT SIZE=5>)
en appelant </FONT><TT><CODE><FONT SIZE=5>pthread_attr_create()</FONT></CODE></TT><FONT SIZE=5>,
puis changer les valeurs par d&eacute;faut avec les fonctions
d&eacute;crites plus loin et cr&eacute;er la pthread avec cet objet
</FONT><TT><CODE><FONT SIZE=5>pthread_attr</FONT></CODE></TT><FONT SIZE=5>.
Ou bien la pthread peut elle-m&ecirc;me changer ses deux valeurs,
priorit&eacute; et politique.<BR><BR>Les fonctions sont : </FONT>
</P>
<PRE>
<FONT SIZE=5>#include &lt;pthread.h&gt;</FONT>
<FONT SIZE=5>pthread_attr_setsched(pthread_attr_t *attr, int politique);</FONT></PRE><P>
<FONT SIZE=5>Les diff&eacute;rentes politiques possibles sont&nbsp;: </FONT>
</P>
<DL>
	<DT><FONT SIZE=5>SCHED_FIFO</FONT></DT><DD>
	<FONT SIZE=5>La thread la plus prioritaire s'ex&eacute;cute jusqu'&agrave;
	ce qu'elle bloque. Si il y a plus d'une pthread de priorit&eacute;
	maximum, la premi&egrave;re qui obtient le cpu s'ex&eacute;cute
	jusqu'&agrave; ce qu'elle bloque. </FONT>
	</DD><DT>
	<FONT SIZE=5>SCHED_RR</FONT></DT><DD>
	<FONT SIZE=5>Round Robin. La thread la plus prioritaire s'ex&eacute;cute
	jusqu'&agrave; ce qu'elle bloque. Les threads de m&ecirc;me priorit&eacute;
	maximum sont organis&eacute;es avec le principe du tourniquet,
	c'est-&agrave;-dire qu'il existe un quantum de temps au bout duquel
	le cpu est pr&eacute;empt&eacute; pour une autre thread (voire
	Chapitre </FONT><A HREF="#cha:processus"><FONT SIZE=5>7</FONT></A><FONT SIZE=5>
	sur les Processus). </FONT>
	</DD><DT>
	<FONT SIZE=5>SCHED_OTHER</FONT></DT><DD>
	<FONT SIZE=5>Comportement par d&eacute;faut. Tous les threads sont
	dans le m&ecirc;me touniquet, il n'y a pas de niveau de priorit&eacute;,
	ceci permet l'absence de famine. Mais les threads avec une politique
	</FONT><TT><FONT SIZE=5>SCHED_FIFO</FONT></TT><FONT SIZE=5> ou
	</FONT><TT><FONT SIZE=5>SCHED_RR</FONT></TT><FONT SIZE=5> peuvent
	placer les threads </FONT><TT><FONT SIZE=5>SCHED_OTHER</FONT></TT><FONT SIZE=5>
	en situation de famine. </FONT>
	</DD><DT>
	<FONT SIZE=5>SCHED_FG_NP</FONT></DT><DD>
	<FONT SIZE=5>(option DCE non portable) M&ecirc;me politique que
	</FONT><TT><FONT SIZE=5>SCHED_OTHER</FONT></TT><FONT SIZE=5> mais
	l'ordonnanceur peut faire &eacute;voluer les priorit&eacute;s des
	threads pour assurer l'&eacute;quit&eacute;. </FONT>
	</DD><DT>
	<FONT SIZE=5>SCHED_BG_NP</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>(option DCE non portable) M&ecirc;me politique que
	</FONT><TT><FONT SIZE=5>SCHED_FG_NP</FONT></TT><FONT SIZE=5>, mais
	les threads avec une politique </FONT><TT><FONT SIZE=5>SCHED_FIFO</FONT></TT><FONT SIZE=5>
	ou </FONT><TT><FONT SIZE=5>SCHED_RR</FONT></TT><FONT SIZE=5> peuvent
	placer les threads </FONT><TT><FONT SIZE=5>SCHED_BG_NP</FONT></TT><FONT SIZE=5>
	en situation de famine. </FONT>
	</DD></DL>
<PRE>
<FONT SIZE=5>pthread_attr_setprio(pthread_attr_t *attr, int prio);</FONT></PRE><P>
<FONT SIZE=5>La priorit&eacute; varie dans un intervalle d&eacute;fini
par la politique:<BR>PRI_OTHER_MIN &lt;= prio &lt;=
PRI_OTHER_MAX<BR>PRI_FIFO_MIN &lt;= prio &lt;=
PRI_FIFO_MAX<BR>PRI_RR_MIN &lt;= prio &lt;= PRI_RR_MAX<BR>PRI_FG_MIN_NP
&lt;= prio &lt;= PRI_FG_MAX_NP<BR>PRI_BG_MIN_NP &lt;= prio &lt;=
PRI_BG_MAX_NP<BR>Ces deux fonctions retournent 0 en cas de succ&egrave;s
et -1 sinon. La valeur de <B>errno</B> indiquant si l'erreur est une
question de param&egrave;tres ou de permission.<BR><BR>Les deux
fonctions que l'on peut appeler sur une pthread pour changer sa
priorit&eacute; ou sa politique sont&nbsp;: </FONT>
</P>
<PRE>
<FONT SIZE=5>pthread_setprio(pthread_t *unepthread, int prio);</FONT>
<FONT SIZE=5>pthread_setsched(pthread_t *unepthread, int politique, int prio);</FONT></PRE><P>
<FONT SIZE=5>Il est possible de conna&icirc;tre la priorit&eacute; ou
la politique d'une pthread ou d'un objet pthread_attr avec&nbsp;: </FONT>
</P>
<PRE>
<FONT SIZE=5>pthread_attr_getprio(pthread_attr_t *attr,int prio);</FONT>
<FONT SIZE=5>pthread_attr_getsched(pthread_attr_t *attr,int politique);</FONT>
<FONT SIZE=5>pthread_getprio(pthread_t *unepthread, int prio);</FONT>
<FONT SIZE=5>pthread_getsched(pthread_t *unepthread, int politique);</FONT></PRE><H2>
<FONT SIZE=5><!--TOC section <FONT SIZE=5>Les variables spécifiques à une thread</FONT>-->19.6&nbsp;&nbsp;
Les variables sp&eacute;cifiques &agrave; une thread</FONT></H2>
<P><!--SEC END --><FONT SIZE=5>Avec un processus multi-threads, nous
sommes dans une situation de partage de donn&eacute;es. Toutes les
donn&eacute;es du processus sont &agrave; priori manipulables par
toutes les threads. Or certaines donn&eacute;es sont critiques et
difficilement partageables. Premi&egrave;rement ce sont les donn&eacute;es
de la biblioth&egrave;que standard. Pour les fonctions de la
biblioth&egrave;que standard, on peut r&eacute;soudre le probl&egrave;me
en utilisant un s&eacute;maphore d'exclusion mutuelle </FONT><TT><CODE><FONT SIZE=5>pthread_mutex_t</FONT></CODE></TT><FONT SIZE=5>
pour POSIX.<BR><BR>Mais certaines variables ne peuvent &ecirc;tre
prot&eacute;g&eacute;es. C'est le cas de la variables </FONT><TT><FONT SIZE=5>errno</FONT></TT><FONT SIZE=5>,
comme nous l'avons vu pr&eacute;c&eacute;demment. Pour cette
variable, la solution est d'avoir une variable par thread. Ainsi le
fichier </FONT><CODE><TT><FONT SIZE=5>&lt;errno.h&gt;</FONT></TT></CODE><FONT SIZE=5>
est modifi&eacute; et contient&nbsp;:</FONT></P>
<PRE>
<FONT SIZE=5>extern int *_errno();</FONT>
<FONT SIZE=5>#define errno (*_errno())</FONT></PRE><P>
<FONT SIZE=5>La valeur </FONT><TT><FONT SIZE=5>errno</FONT></TT><FONT SIZE=5>
est obtenue par une fonction qui retourne la valeur de </FONT><TT><FONT SIZE=5>errno</FONT></TT><FONT SIZE=5>
associ&eacute;e &agrave; la thread qui fait l'appel &agrave; </FONT><TT><FONT SIZE=5>_errno</FONT></TT><FONT SIZE=5>
.<!--TOC subsection <FONT SIZE=5>Principe général des données spécifiques, POSIX</FONT>--></FONT></P>
<H3><FONT SIZE=5>19.6.1&nbsp;&nbsp; Principe g&eacute;n&eacute;ral
des donn&eacute;es sp&eacute;cifiques, POSIX</FONT></H3>
<P><!--SEC END --><FONT SIZE=5>L'id&eacute;e des donn&eacute;es
sp&eacute;cifique est de cr&eacute;er un vecteur pour chaque donn&eacute;e
sp&eacute;cifique. Ainsi pour des donn&eacute;es sp&eacute;cifique
statiques, chaque thread poss&egrave;de son propre exemplaire. Les
donn&eacute;es sp&eacute;cifiques sont identifi&eacute;es par des
cl&eacute;s de type </FONT><TT><CODE><FONT SIZE=5>pthread_key_t</FONT></CODE></TT><FONT SIZE=5>.<!--TOC subsection <FONT SIZE=5>Création de clés</FONT>--></FONT></P>
<H3><FONT SIZE=5>19.6.2&nbsp;&nbsp; Cr&eacute;ation de cl&eacute;s</FONT></H3>
<P><FONT SIZE=5><!--SEC END -->La cr&eacute;ation d'une cl&eacute;
est li&eacute;e &agrave; la cr&eacute;ation d'un tableau statique
(variable globale), initialis&eacute; &agrave; NULL &agrave; la
cr&eacute;ation. La fonction </FONT>
</P>
<PRE>
<FONT SIZE=5>#include &lt;pthread.h&gt;</FONT>
<FONT SIZE=5>int pthread_keycreate (pthread_key_t *p_cle, </FONT>
<FONT SIZE=5>                       void          (*destructeur)(void *valeur));</FONT></PRE><P>
<FONT SIZE=5>permet la cr&eacute;ation du tableau, 0 succ&egrave;s et
-1 echec. La structure point&eacute;e par </FONT><CODE><TT><FONT SIZE=5>p_cle</FONT></TT></CODE><FONT SIZE=5>
nous permettra d'acc&egrave;der aux valeurs stock&eacute;es, la cl&eacute;
est &eacute;videmment la m&ecirc;me pour toutes les threads. Le
param&egrave;tre </FONT><TT><FONT SIZE=5>destructeur</FONT></TT><FONT SIZE=5>
de type pointeur sur fonction prenant un pointeur sur void en
param&egrave;tre et renvoyant void, donne l'adresse d'une fonction
qui est ex&eacute;cut&eacute;e &agrave; la terminaison de la thread
(ce qui permet de faire le m&eacute;nage). Si ce pointeur est nul,
l'information n'est pas d&eacute;truite &agrave; la terminaison de
l'activit&eacute;.<!--TOC subsection <FONT SIZE=5>Lecture/écriture d'une variable spécifique</FONT>--></FONT></P>
<H3><FONT SIZE=5>19.6.3&nbsp;&nbsp; Lecture/&eacute;criture d'une
variable sp&eacute;cifique</FONT></H3>
<P><FONT SIZE=5><!--SEC END -->La fonction </FONT>
</P>
<PRE>
<FONT SIZE=5>#include &lt;pthread.h&gt;</FONT>
<FONT SIZE=5>int pthread_getspecific (pthread_key_t *p_cl&eacute;, void **pvaleur);</FONT></PRE><P>
<FONT SIZE=5>permet la lecture de la valeur qui est copi&eacute; &agrave;
l'adresse </FONT><TT><FONT SIZE=5>pvaleur</FONT></TT><FONT SIZE=5>
retourne 0 ou -1 selon que l'appel &agrave; r&eacute;ussi ou non. La
fonction </FONT>
</P>
<PRE>
<FONT SIZE=5>#include &lt;pthread.h&gt;</FONT>
<FONT SIZE=5>int pthread_setspecific (pthread_key_t *p_cl&eacute;, void *valeur);</FONT></PRE><P>
<FONT SIZE=5>permet l'&eacute;criture &agrave; l'emplacement sp&eacute;cifi&eacute;
de </FONT><TT><FONT SIZE=5>valeur</FONT></TT><FONT SIZE=5> retourne 0
ou -1 selon que l'appel a r&eacute;ussit ou non. <!--TOC section <FONT SIZE=5>Les fonctions standardes utilisant des zones statiques</FONT>--></FONT></P>
<H2><FONT SIZE=5>19.7&nbsp;&nbsp; Les fonctions standardes utilisant
des zones statiques</FONT></H2>
<P><!--SEC END --><FONT SIZE=5>Certaines fonctions standardes comme
</FONT><TT><FONT SIZE=5>ttyname()</FONT></TT><FONT SIZE=5> ou
</FONT><TT><FONT SIZE=5>readdir()</FONT></TT><FONT SIZE=5> retourne
l'adresse d'une zone statique. Plusieurs threads en concurrence
peuvent donc nous amener &agrave; des situations incoh&eacute;rentes.
La solution des s&eacute;maphores d'exclusion &eacute;tant co&ucirc;teuse,
ces fonctions sont r&eacute;&eacute;crites pour la biblioth&egrave;que
de thread de fa&ccedil;on &agrave; &ecirc;tre r&eacute;entrantes.<BR><BR>Attention
les probl&egrave;mes de r&eacute;entrance peuvent avoir lieu en
utilisant des appels syst&egrave;mes non r&eacute;entrant dans les
handlers de signaux &nbsp;! Ceci sans utiliser de threads &nbsp;!<!--TOC chapter <FONT SIZE=5>Entrées-sorties avancées</FONT>--></FONT></P>
<H1><FONT SIZE=5>Chapitre&nbsp;20&nbsp;&nbsp; Entr&eacute;es-sorties
avanc&eacute;es</FONT></H1>
<P><!--SEC END --><FONT SIZE=5>Les entr&eacute;es-sorties avanc&eacute;es
sont des entr&eacute;es-sorties qui permettent de faire abstraction
du r&eacute;seau ou d'utiliser le protocole UDP avec des commandes
d'envoi et de r&eacute;ception de messages. Les deux grandes familles
de syst&egrave;mes UNIX ont propos&eacute; chacune leur m&eacute;thode.
D'une part les </FONT><TT><FONT SIZE=5>streams</FONT></TT><FONT SIZE=5>
de SYS V, et d'autre part les </FONT><TT><FONT SIZE=5>sockets</FONT></TT><FONT SIZE=5>
de BSD. Dans les deux cas, le principe de conservation de l'interface
</FONT><TT><FONT SIZE=5>read</FONT></TT><FONT SIZE=5> et </FONT><TT><FONT SIZE=5>write
</FONT></TT><FONT SIZE=5>a &eacute;t&eacute; conserv&eacute; au
maximum. Le choix <B>POSIX</B> est l'utilisation de </FONT><TT><FONT SIZE=5>sockets</FONT></TT><FONT SIZE=5>.<!--TOC section <FONT SIZE=5>Les streams</FONT>--></FONT></P>
<H2><FONT SIZE=5>20.1&nbsp;&nbsp; Les streams</FONT></H2>
<P><!--SEC END --><FONT SIZE=5>Les entr&eacute;es-sorties avanc&eacute;es
d&eacute;crites ici sont sp&eacute;cifiques au syst&egrave;me V.4
d'ATT, les outils correspondant sous BSD sont les sockets, qui gr&acirc;ce
&agrave; leurs possibilit&eacute;s r&eacute;seaux, ont &eacute;te
choisies dans la norme POSIX. <BR><BR>On trouve dans les
impl&eacute;mentations Syst&egrave;me V.4 un m&eacute;canisme
d'interfa&ccedil;age des drivers de p&eacute;riph&eacute;riques
appel&eacute; </FONT><TT><FONT SIZE=5>streams</FONT></TT><FONT SIZE=5>.
(Attention ce ne sont pas les canaux de la biblioth&egrave;ques
standard). Les streams am&eacute;liorent le pr&eacute;c&eacute;dent
m&eacute;canisme de </FONT><TT><FONT SIZE=5>clist</FONT></TT><FONT SIZE=5>
utilis&eacute; pour bufferiser les entr&eacute;es-sorties. </FONT>
</P>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML076.gif" NAME="Image78" ALIGN=BOTTOM WIDTH=197 HEIGHT=247 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
20.1&nbsp;: Un stream</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="streams"></A><BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<P><FONT SIZE=5>Le stream fournit un canal bidirectionnel entre le
processus et le driver de terminal (ou de pseudo-terminal) (voir
figure </FONT><A HREF="#streams"><FONT SIZE=5>20.1</FONT></A><FONT SIZE=5>).
Un apport des </FONT><TT><FONT SIZE=5>streams</FONT></TT><FONT SIZE=5>
est de pouvoir ins&eacute;rer un module de traitement entre la t&ecirc;te
du stream et le driver de terminal comme le montre la figure </FONT><A HREF="#streams2"><FONT SIZE=5>20.2</FONT></A><FONT SIZE=5>.</FONT></P>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><IMG SRC="http://www-igm.univ-mlv.fr/~dr/HEVEA/CHTML077.gif" NAME="Image79" ALIGN=BOTTOM WIDTH=317 HEIGHT=377 BORDER=0><FONT SIZE=5>
</FONT>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><BR>
</BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm; text-align: center"><FONT SIZE=5>Figure
20.2&nbsp;: Ajout d'un module de traitement</FONT></BLOCKQUOTE>
<BLOCKQUOTE STYLE="margin-bottom: 0cm"><A NAME="streams2"></A><BR>
</BLOCKQUOTE>
<HR WIDTH=661 ALIGN=CENTER SIZE=2>
<P><FONT SIZE=5>Le module de traitement doit &ecirc;tre link&eacute;
au noyau pour fonctionner, ce qui limite la port&eacute;e de cet
ajout.<BR><BR>Les streams offrent des fonctionnalit&eacute;s plus
larges que les deux appels classiques </FONT><TT><FONT SIZE=5>read</FONT></TT><FONT SIZE=5>
et </FONT><TT><FONT SIZE=5>write</FONT></TT><FONT SIZE=5>. Il est
possible sur les </FONT><TT><FONT SIZE=5>streams</FONT></TT><FONT SIZE=5>
d'utiliser deux appels </FONT><TT><FONT SIZE=5>putmsg</FONT></TT><FONT SIZE=5>
et </FONT><TT><FONT SIZE=5>putpmsg</FONT></TT><FONT SIZE=5> qui
permettent d'envoyer des informations &quot;express&quot; ou des
informations de contr&ocirc;le (des signaux par exemple). Ceci permet
en particulier de r&eacute;aliser un module de traitement R&eacute;seau,
qui va permettre d'utiliser un fichier &agrave; distance comme un
fichier local, tout en permettant gr&acirc;ce &agrave; </FONT><TT><FONT SIZE=5>putmsg
et getmsg</FONT></TT><FONT SIZE=5> de pouvoir envoyer des commandes
au module de traitement ou d'envoyer des messages hord bande. On ne
trouvera des impl&eacute;mentations des streams que dans les
impl&eacute;mentations de Systeme V.4. Ce qui n'est pas le cas des HP
avec le syst&egrave;me 9.<!--TOC section <FONT SIZE=5>Les sockets</FONT>--></FONT></P>
<H2><FONT SIZE=5>20.2&nbsp;&nbsp; Les sockets</FONT></H2>
<P><FONT SIZE=5><!--SEC END -->Les sockets ont &eacute;t&eacute;
cr&eacute;es dans l'impl&eacute;mentation BSD. Ils permettent de
r&eacute;aliser des &eacute;changes interprocessus sans liens
d'h&eacute;ritage, et m&ecirc;me ce qui est le point fort, entre
processus s'ex&eacute;cutant sur des machines diff&eacute;rentes. La
communication se faisant alors gr&acirc;ce &agrave; un r&eacute;seau
de fa&ccedil;on transparente pour l'utilisateur.<BR><BR>Les sockets
sont des liens bidirectionnels de communication, ils ont &eacute;t&eacute;
mis au point pour pouvoir manipuler de fa&ccedil;on homog&egrave;ne
les communications entre machines.<BR><BR>Les sockets ont &eacute;t&eacute;
d&eacute;finis de fa&ccedil;on &agrave; pouvoir unifier tous les
syst&egrave;mes de communication inter processus (IPC) &agrave; un
tr&egrave;s haut niveau, en permettant &agrave; la fois: </FONT>
</P>
<UL>
	<LI><P><FONT SIZE=5>de garder une compatibilit&eacute; ascendante
	avec le principe fondamental des filtres UNIX et des redirections
	avec l'utilisation des descripteurs. </FONT>
	</P>
	<LI><P><FONT SIZE=5>d'utiliser des protocoles divers, en particulier
	d'envoyer des messages &quot;Hors-Bande&quot; qui peuvent doubler
	les autres informations sur la ligne. </FONT>
	</P>
</UL>
<P><FONT SIZE=5>C'est un objet abstrait qui peut &ecirc;tre manipul&eacute;
comme un descripteur de fichier.<BR><BR>Les sockets sont pour un
processus utilisables comme des fichiers, les appels syst&egrave;mes
</FONT><TT><FONT SIZE=5>read</FONT></TT><FONT SIZE=5> et </FONT><TT><FONT SIZE=5>write</FONT></TT><FONT SIZE=5>
fonctionnent normalement sur des sockets ouverts en mode stream. La
primitve </FONT><TT><FONT SIZE=5>socket </FONT></TT><FONT SIZE=5>de
cr&eacute;ation de socket retourne un entier indiquant une entr&eacute;e
de la table des descripteur.<BR><BR>La structure &eacute;quivalente &agrave;
l'inode des fichiers est une structure </FONT><TT><FONT SIZE=5>struct
socket</FONT></TT><FONT SIZE=5> d&eacute;finie dans le fichier
</FONT><TT><CODE><FONT SIZE=5>&lt;sys/socket.h&gt;</FONT></CODE></TT><FONT SIZE=5>.<BR><BR>A
l'inverse des fichiers, les sockets n'ont d'existence que lorsqu'ils
sont r&eacute;f&eacute;renc&eacute;s par un processus.<!--TOC section <FONT SIZE=5>Création d'un socket</FONT>--></FONT></P>
<H2><FONT SIZE=5>20.3&nbsp;&nbsp; Cr&eacute;ation d'un socket</FONT></H2>
<P><FONT SIZE=5><!--SEC END -->La cr&eacute;ation d'un socket se fait
gr&acirc;ce &agrave; l'appel </FONT>
</P>
<PRE>
<FONT SIZE=5>int s_desc = socket (int domain, int type, int protocol);</FONT></PRE><P>
<FONT SIZE=5>Le </FONT><EM><FONT SIZE=5>Domaine</FONT></EM><FONT SIZE=5>
est un terme r&eacute;seau qui d&eacute;signe un ensemble de
protocoles de communication entre machines. Le domaine permet de
d&eacute;finir correctement l'adresse pour le r&eacute;seau du
socket.<BR><BR>En effet comme nous l'avons vu dans le cas de tubes,
quand deux processus n'ont pas de lien d'h&eacute;ritage, il faut
utiliser des tubes nomm&eacute;s pour pouvoir les faire communiquer
par tubes. Ici pour que deux processus puisse communiquer par socket,
il faut qu'un processus cr&eacute;e un socket puis lui d&eacute;finisse
une adresse dans le domaine, le deuxi&egrave;me processus pourra
ensuite se connecter au socket ainsi nomm&eacute;.<BR><BR>On trouvera
dans </FONT><CODE><TT><FONT SIZE=5>&lt;sys/socket.h&gt;</FONT></TT></CODE><FONT SIZE=5>
les diff&eacute;rents domaines support&eacute;s par exemple
:<BR><BR>AF_UNIX (pour tous les protocoles internes)<BR>AF_INET (pour
les protocoles ARPA internet)<BR>AF_CCITT (X25)<BR>AF_NS ( chez Xerox
)<BR>AF_APPLETALK <BR>etc<BR><BR>Le domaine d&eacute;finit aussi la
liste des protocoles utilisables. Les diff&eacute;rents protocoles ne
sont pas utilisables dans tous les domaines.<!--TOC section <FONT SIZE=5>Les différentes formes de communication par socket</FONT>--></FONT></P>
<H2><FONT SIZE=5>20.4&nbsp;&nbsp; Les diff&eacute;rentes formes de
communication par socket</FONT></H2>
<P><FONT SIZE=5><!--SEC END -->Le type permet de d&eacute;finir le
type de communication voulue.<BR>Parmi les propri&eacute;t&eacute;s
d'une transmission, on trouve&nbsp;: </FONT>
</P>
<OL>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>les donn&eacute;es
	sont livr&eacute;es dans l'ordre </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>sans duplication </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>sans perte </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>en pr&eacute;servant
	les bornes des messages </FONT>
	</P>
	<LI><P STYLE="margin-bottom: 0cm"><FONT SIZE=5>avec des messages
	&quot;express&quot; hors-bande. </FONT>
	</P>
	<LI><P><FONT SIZE=5>communication orient&eacute;e-connexion = &quot;mode
	connect&eacute;&quot;. </FONT>
	</P>
</OL>
<P><FONT SIZE=5>Les tubes, par exemple, ont les trois premi&egrave;res
propri&eacute;t&eacute;s, mais pas la quatri&egrave;me.<BR>La sixi&egrave;me
propri&eacute;t&eacute; est un mode de communication o&ugrave; l'on
d&eacute;finit sur le r&eacute;seau un canal de transmission, ce qui
permet d'&eacute;viter d'envoyer avec chaque message l'adresse du
socket d'envoi. A la place, un &eacute;change d'identit&eacute; est
r&eacute;alis&eacute; avant le d&eacute;but de la communication
proprement dite. Il est entendu qu'il ne sera pas possible de se
connecter &agrave; partir d'un troisi&egrave;me socket.<BR><BR>On
peut par exemple si l'on utilise une ligne &quot;&agrave; la&quot;
TRANSPAC vouloir utiliser un syst&egrave;me o&ugrave; les messages ne
sont pas d&eacute;coup&eacute;s (propri&eacute;t&eacute; 4), et o&ugrave;
les messages peuvent &eacute;ventuellement &ecirc;tre perdus (ligne
modem) ou dupliqu&eacute;s, en effet TRANSPAC utilise un algorithme
de transmission qui peut avoir pour cons&eacute;quence la duplication
de paquets d'informations. <BR><BR>Les types les plus utilis&eacute;s
sont&nbsp;: </FONT>
</P>
<DL>
	<DT><FONT SIZE=5>SOCK_STREAM</FONT></DT><DD>
	<FONT SIZE=5>connexion &agrave; double sens avec les propri&eacute;t&eacute;s
	1,2,3 et &eacute;ventuellement la propri&eacute;t&eacute; 5. </FONT>
	</DD><DT>
	<FONT SIZE=5>SOCK_DGRAM</FONT></DT><DD>
	<FONT SIZE=5>datagrammes, propri&eacute;t&eacute; 4 uniquement. </FONT>
	</DD><DT>
	<FONT SIZE=5>SOCK_RAW</FONT></DT><DD>
	<FONT SIZE=5>(cru) aucun protocole, uniquement par le super
	utilisateur, permet de manipuler directement l'interface de
	communication bas niveau. </FONT>
	</DD><DT>
	<FONT SIZE=5>SOCK_SEQPACKET</FONT></DT><DD STYLE="margin-bottom: 0.5cm">
	<FONT SIZE=5>1,2,3. Le lecteur doit y lire un paquet &agrave; chaque
	lecture. D&eacute;fini uniquement dans le domaine AF_NS (Xerox) </FONT>
	</DD></DL>
<P>
<FONT SIZE=5>Les protocoles sont en g&eacute;neral sp&eacute;cifiques
au domaine, l'utilisation de la valeur z&eacute;ro pour le protocole
laisse au syst&egrave;me le soin de s&eacute;lectionner lui-m&ecirc;me
le bon protocole dans le domaine. <!--TOC section <FONT SIZE=5>Définition de l'adresse d'un socket</FONT>--></FONT></P>
<H2><FONT SIZE=5>20.5&nbsp;&nbsp; D&eacute;finition de l'adresse d'un
socket</FONT></H2>
<P><FONT SIZE=5><!--SEC END -->Dans le cas de deux processus qui
n'ont pas d'anc&ecirc;tres communs, il faut donner au socket une
adresse (un nom) qui va permettre &agrave; diff&eacute;rents
processus de se brancher sur la bonne ligne. Comme nous l'avons
indiqu&eacute; plus haut, le type de l'adresse d&eacute;pend du
domaine. Mais une seule primitive r&eacute;alise l'association d'une
adresse &agrave; une socket, c'est la primitive&nbsp;: </FONT>
</P>
<PRE>
<FONT SIZE=5>int bind(int descripteur, struct sockaddr *adresse, int longeur_adresse);</FONT></PRE><P>
<FONT SIZE=5>Un appel &agrave; cette fonction r&eacute;alise un
attachement (bind) du socket de descripteur donn&eacute; &agrave;
l'adresse point&eacute;e par </FONT><TT><FONT SIZE=5>adresse</FONT></TT><FONT SIZE=5>
qui est suppos&eacute;e &ecirc;tre de taille </FONT><TT><FONT SIZE=5>longeur_adresse</FONT></TT><FONT SIZE=5>.
Retourne -1 en cas d'echec.<BR><BR>La taille des adresses de socket
varie en fonction du domaine de communication utilis&eacute;, les
adresses sont donc structur&eacute;es comme des chaines du Pascal :
la longueur en premier sur deux octets suivie de l'adresse r&eacute;elle
(en g&eacute;n&eacute;ral, une zone de 14 octets est r&eacute;serv&eacute;e
pour l'adresse r&eacute;elle).<BR><BR>Une seule adresse est associ&eacute;e
&agrave; un socket donn&eacute; sur une machine, par contre le
domaine de communication peut permettre l'utilisation r&eacute;p&eacute;t&eacute;e
d'une m&ecirc;me adresse, le courrier &eacute;lectronique par
exemple.<!--TOC section <FONT SIZE=5>Utilisation des sockets</FONT>--></FONT></P>
<H2><FONT SIZE=5>20.6&nbsp;&nbsp; Utilisation des sockets</FONT></H2>
<P><FONT SIZE=5><!--SEC END -->Les sockets sont donc un regroupement
sous un m&ecirc;me formalisme d'un ensemble de protocoles de
communication. Nous regardons ici quelques cas d'utilisations.<!--TOC subsection <FONT SIZE=5>Utilisation local AF_UNIX</FONT>--></FONT></P>
<H3><FONT SIZE=5>20.6.1&nbsp;&nbsp; Utilisation local AF_UNIX</FONT></H3>
<P><!--SEC END --><FONT SIZE=5>Il est possible d'utiliser les sockets
comme des tubes, et une fonction sp&eacute;cifique existe qui cr&eacute;e
deux sockets dont le comportement est identique &agrave; celui que
l'on obtient avec l'appel </FONT><TT><FONT SIZE=5>pipe</FONT></TT><FONT SIZE=5>,
c'est la primitive&nbsp;: </FONT>
</P>
<PRE>
<FONT SIZE=5>void socketpair (int domain, int type, int protocol, int sv[]).</FONT></PRE><P>
<FONT SIZE=5>que l'on appellera avec les param&egrave;tres suivant
pour cr&eacute;er un tube&nbsp;: </FONT>
</P>
<PRE>
<FONT SIZE=5>socketpair(AF_UNIX, SOCK_STREAM, 0, tube);</FONT></PRE><P>
<FONT SIZE=5>les deux sockets cr&eacute;es sont imm&eacute;diatement
utilisables exactement comme un tube, et comme les tubes, ces deux
sockets n'ont pas de nom. Remarquer que ces deux sockets restent
utilisables dans les deux sens. Pour avoir un comportment similaire &agrave;
cette paire de sockets, nous devrions avec des tubes cr&eacute;er
deux tubes dirig&eacute;s chacun dans un sens.<BR><BR>La structure
d'adresse pour le domaine AF_UNIX est comme pour les tubes une
r&eacute;f&eacute;rence de l'arborescence. Elle est de type </FONT><TT><FONT SIZE=5>struct
sockaddr_un</FONT></TT><FONT SIZE=5> d&eacute;fini dans le fichier
</FONT><CODE><TT><FONT SIZE=5>&lt;sys/un.h&gt;</FONT></TT></CODE><FONT SIZE=5>
&nbsp;: </FONT>
</P>
<PRE>
<FONT SIZE=5>struct sockaddr_un {</FONT>
<FONT SIZE=5>        short   sun_family;    /* AF_UNIX */</FONT>
<FONT SIZE=5>        char    sun_path[108]; /* reference */</FONT>
<FONT SIZE=5>};</FONT></PRE><P>
<FONT SIZE=5>La primitive </FONT><TT><FONT SIZE=5>bind</FONT></TT><FONT SIZE=5>
ne fonctione que si la r&eacute;f&eacute;rence n'existe pas.<!--TOC subsection <FONT SIZE=5>Utilisation avec le concept INTERNET</FONT>--></FONT></P>
<H3><FONT SIZE=5>20.6.2&nbsp;&nbsp; Utilisation avec le concept
INTERNET</FONT></H3>
<P><!--SEC END --><FONT SIZE=5>Internet est une norme de
communication r&eacute;seau largement utilis&eacute;e par &quot;the
net&quot; qui est souvent r&eacute;f&eacute;renc&eacute; par TCP/IP,
qui sont les deux protocoles principaux. Cette norme permet
l'interconnection de tous les r&eacute;seaux quelle que soit leur
technologie.<BR><BR>Les sockets AF_INET utiliserons les supports
TCP/IP de votre machine.<BR><BR>Les adresses sont de la forme </FONT><TT><FONT SIZE=5>struct
sockaddr_in</FONT></TT><FONT SIZE=5> d&eacute;finie dans le fichier
</FONT><CODE><TT><FONT SIZE=5>&lt;netinet/in.h&gt;</FONT></TT></CODE><FONT SIZE=5>&nbsp;:
</FONT>
</P>
<PRE>
<FONT SIZE=5>struct in_addr {  /* adrsse internet 192.103.134.86 -&gt; fillmore */</FONT>
<FONT SIZE=5>        u_long s_addr;</FONT>
<FONT SIZE=5>};</FONT>

<FONT SIZE=5>struct sockaddr_in {</FONT>
<FONT SIZE=5>        short   sin_family; /* AF_INET */</FONT>
<FONT SIZE=5>        u_short sin_port;   /* numero de port */</FONT>
<FONT SIZE=5>        struct  in_addr sin_addr; </FONT>
<FONT SIZE=5>        char    sin_zero[8];/* Huit z&eacute;ros utilis&eacute;s comme masque ailleurs */</FONT>
<FONT SIZE=5>};</FONT></PRE><P>
<FONT SIZE=5>Ainsi l'attachement va se faire sur une machine, et sur
cette machine le socket sera attach&eacute; &agrave; un certain port
(entier) qui permet de diff&eacute;rencier les diff&eacute;rents
sockets utilisables de l'ext&eacute;rieur.<BR><BR>Les serveurs
doivent donc rendre public leur num&eacute;ro de port, pour que les
clients puissent se connecter.<BR><BR>Le syst&egrave;me a un certain
nombre de ports r&eacute;serv&eacute;s (IPPORT_RESERVED).<BR><BR>Les
clients n'ont pas d'int&eacute;r&ecirc;t &agrave; avoir un port
pr&eacute;d&eacute;fini, en sp&eacute;cifiant INADDR_ANY le syst&egrave;me
choisit un port libre, ce qui &eacute;vite les conflits (le bind est
implicite lors du premier envoi).<BR><BR>Attention : l'acc&egrave;s
partag&eacute; aux ports impose les m&ecirc;mes contraintes que toute
autre ressource du syst&egrave;me. <!--TOC section <FONT SIZE=5>Le mode connecté</FONT>--></FONT></P>
<H2><FONT SIZE=5>20.7&nbsp;&nbsp; Le mode connect&eacute;</FONT></H2>
<P><FONT SIZE=5><!--SEC END -->Dans une liaison en mode connect&eacute;
(propri&eacute;t&eacute; 6), il faut initialiser la communication
entre les deux processus. Pour cela on utilisera un appel &agrave; la
primitive&nbsp;: </FONT>
</P>
<PRE>
<FONT SIZE=5>int connect (int socket, struct sockaddr *server, int serveraddrlen);</FONT></PRE><P>
<FONT SIZE=5>dans le processus client.<BR><BR>Le processus serveur
doit en premier lieu indiquer gr&acirc;ce &agrave; la primitive </FONT>
</P>
<PRE>
<FONT SIZE=5>int listen (int socket, int nombre);</FONT></PRE><P>
<FONT SIZE=5>le nombre de connexions qui peuvent &ecirc;tre
bufferis&eacute;es (mise en attente d'un accept).<BR><BR>Les
connexions sont ensuite re&ccedil;ues l'une apr&egrave;s l'autre dans
le processus serveur avec la primitive : </FONT>
</P>
<PRE>
<FONT SIZE=5>int nsock = accept (int s, struct sockaddr *client, int *clientaddr);</FONT></PRE><P>
<FONT SIZE=5>Attention : </FONT><TT><FONT SIZE=5>accept</FONT></TT><FONT SIZE=5>
renvoie un nouveau descripteur de socket, c'est sur ce nouveau socket
que sera r&eacute;alis&eacute; la connexion entre client et serveur.
Le socket d'origine ne sert que de file d'attente des demandes de
connexion par </FONT><TT><FONT SIZE=5>connect</FONT></TT><FONT SIZE=5>.<!--TOC section <FONT SIZE=5>La communication par messages avec les sockets</FONT>--></FONT></P>
<H2><FONT SIZE=5>20.8&nbsp;&nbsp; La communication par messages avec
les sockets</FONT></H2>
<P><FONT SIZE=5><!--SEC END -->les primitives d'envoi de messages&nbsp;:</FONT></P>
<PRE>
<FONT SIZE=5>#include &lt;sys/types.h&gt;</FONT>
<FONT SIZE=5>#include &lt;sys/socket.h&gt;</FONT>

<FONT SIZE=5>int send(int s, char * msg, int len, int flags); /* mode connect&eacute; seulement */</FONT>

<FONT SIZE=5>int sendto(int s, char * msg, int len, int flags,</FONT>
<FONT SIZE=5>           struct sockaddr *to, int tolen);</FONT>

<FONT SIZE=5>int sendmsg(int s, struct msghdr msg[], int flags);</FONT>

<FONT SIZE=5>flags: </FONT>
<FONT SIZE=5> MSG_OOB          /* process out-of-band data */</FONT>
<FONT SIZE=5> MSG_DONTROUTE    /* bypass routing, use direct interface */</FONT></PRE><P>
<FONT SIZE=5>la valeur de retour -1 n'indique pas que le message n'a
pas &eacute;t&eacute; d&eacute;livr&eacute;, mais uniquement une
erreur locale. Si errno == EMSGSIZE, le message est trop long et n'a
pas &eacute;t&eacute; envoy&eacute;.<BR><BR>R&eacute;ception de
messages: </FONT>
</P>
<PRE>
<FONT SIZE=5>int cc = recv (int s, char *buf, int len, int flags);</FONT>

<FONT SIZE=5>int cc = recvfrom (int s, char *buf, int len, int flags,</FONT>
<FONT SIZE=5>                   struct sockaddr *from, int *fromlen);</FONT>

<FONT SIZE=5>int cc = recvmsg (int s, struct msghdr msg[], int flags);</FONT>


<FONT SIZE=5>flags:</FONT>
<FONT SIZE=5>     MSG_PEEK    /* peek at incoming message */ </FONT>
<FONT SIZE=5>       </FONT>
<FONT SIZE=5>messages:</FONT>
<FONT SIZE=5>struct msghdr {</FONT>
<FONT SIZE=5>    caddr_t      msg_name;          /* optional address */</FONT>
<FONT SIZE=5>    int          msg_namelen;       /* size of address */</FONT>
<FONT SIZE=5>    struct iovec *msg_iov;          /* scatter/gather array */</FONT>
<FONT SIZE=5>    int          msg_iovlen;        /* # elements in msg_iov */</FONT>
<FONT SIZE=5>    caddr_t      msg_accrights;     /* access rights sent/received */</FONT>
<FONT SIZE=5>    int          msg_accrightslen;</FONT>
<FONT SIZE=5>};</FONT></PRE><P>
<FONT SIZE=5>On utilisera la primitive </FONT><TT><FONT SIZE=5>ioctl</FONT></TT><FONT SIZE=5>
pour manipuler les propri&eacute;t&eacute;s du socket comme par
exemple le mode non bloquant en lecture.<BR><BR>Quelques primitives
annexes:<BR><BR>Pour conna&icirc;tre l'adresse du socket associ&eacute;
(en mode connect&eacute;) : </FONT>
</P>
<PRE>
<FONT SIZE=5>    getpeername(int s, struct sockaddr *name, int *namelen);</FONT></PRE><P>
<FONT SIZE=5>Donne le nom du socket s : </FONT>
</P>
<PRE>
<FONT SIZE=5>     getsockname(int s, struct sockaddr *name, int *namelen);</FONT></PRE><P>
<FONT SIZE=5>Enfin les primitives suivantes permettent de manipuler
certaines options : </FONT>
</P>
<PRE>
<FONT SIZE=5>    getsockopt(int s, int level, int optname, char *optval, int *optlen);</FONT>

<FONT SIZE=5>    setsockopt(int s, int level, int optname, char *optval, int optlen);</FONT></PRE><H2>
<FONT SIZE=5><!--TOC section <FONT SIZE=5>Accès réseau sous Unix</FONT>-->20.9&nbsp;&nbsp;
Acc&egrave;s r&eacute;seau sous Unix</FONT></H2>
<P><FONT SIZE=5><!--SEC END -->Fichiers de configuration (/etc/...)</FONT></P>
<PRE>
<FONT SIZE=5># Network services, Internet style</FONT>
<FONT SIZE=5>#</FONT>
<FONT SIZE=5>systat          11/tcp          users</FONT>
<FONT SIZE=5>ftp             21/tcp</FONT>
<FONT SIZE=5>telnet          23/tcp</FONT>
<FONT SIZE=5>smtp            25/tcp          mail</FONT>

<FONT SIZE=5># &lt;internet address&gt;    &lt;official hostname&gt; &lt;aliases&gt;</FONT>
<FONT SIZE=5>#</FONT>
<FONT SIZE=5>192.134.103.86  rome # Serveur -HP 9000s755</FONT>

<FONT SIZE=5># Internet server configuration database</FONT>
<FONT SIZE=5>#</FONT>
<FONT SIZE=5>systat  stream  tcp     nowait  /etc/miscd      systatd</FONT>
<FONT SIZE=5>#systat dgram   udp     wait    /etc/miscd      systatd</FONT>
<FONT SIZE=5>daytime stream  tcp     nowait  /etc/miscd      daytimed</FONT>
</PRE><P>
<FONT SIZE=5>Une biblioth&egrave;que de fonctions permet la
manipulation de la base de donn&eacute;es INTERNET: </FONT><TT><FONT SIZE=5>gethostid(),
gethostbyname() ,gethostbyaddr() </FONT></TT><FONT SIZE=5>(pas de
distinction majuscule/minuscule)<BR><BR>Un standard de repr&eacute;sentation
des nombres permet le d&eacute;codage par des machines
d'architectures diff&eacute;rentes, ex: htonl() = host to network
long. <!--HTMLFOOT--><!--ENDHTML--><!--FOOTER--></FONT></P>
<HR SIZE=2>
<BLOCKQUOTE><FONT SIZE=5><EM>Ce document a &eacute;t&eacute; traduit
de L<SUP>A</SUP>T<SUB>E</SUB>X par </EM><A HREF="http://pauillac.inria.fr/~maranget/hevea/index.html"><EM>H</EM></A></FONT><A HREF="http://pauillac.inria.fr/~maranget/hevea/index.html"><EM><FONT SIZE=4><SUP>E</SUP></FONT><FONT SIZE=5>V</FONT><FONT SIZE=4><SUP>E</SUP></FONT><FONT SIZE=5>A</FONT></EM></A><EM><FONT SIZE=5>.
</FONT></EM>
</BLOCKQUOTE>
</BODY>
</HTML>