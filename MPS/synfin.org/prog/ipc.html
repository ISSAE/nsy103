<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
<TITLE>Labo-Unix Communication Inter-Processus</TITLE>
<META NAME="description" CONTENT="Labo-Unix Communication Inter-Processus">
<META NAME="keywords" CONTENT="ipc">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
<META NAME="Generator" CONTENT="LaTeX2HTML v2K.1beta">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="ipc.css">

</HEAD>

<BODY >

<P>

<P>

<P>

<P>
<H1 ALIGN="CENTER">Labo-Unix
<BR>
Communication Inter-Processus</H1>
<DIV ALIGN="CENTER">
<IMG
 BORDER="0"
 SRC="/images/logo_labo.jpg"
 ALT="Laboratoire Unix - Supinfo Paris"> </DIV>
<P ALIGN="CENTER">
<STRONG>Julien GATEAUD - Labo Unix -<A HREF="http://www.labo-unix.net"> http://www.labo-unix.net</A><BR>
2001-2002</STRONG></P>
<BR>
<BR>

<P>
<DIV ALIGN="CENTER"></DIV>
<BR>
<BR>

<P>

<P>
<BR>

<H2><A NAME="SECTION00010000000000000000">
Contents</A>
</H2>
<!--Table of Contents-->

<UL>
<LI><A NAME="tex2html11"
  HREF="ipc.html">Introduction</A>
<LI><A NAME="tex2html12"
  HREF="#SECTION00030000000000000000">1 Manipulation de processus</A>
<LI><A NAME="tex2html13"
  HREF="#SECTION00040000000000000000">2 Les pipes</A>
<LI><A NAME="tex2html14"
  HREF="#SECTION00050000000000000000">3 Les signaux</A>
<LI><A NAME="tex2html15"
  HREF="#SECTION00060000000000000000">4 Les files de messages</A>
<LI><A NAME="tex2html16"
  HREF="#SECTION00070000000000000000">5 Sémaphores selon System V</A>
<LI><A NAME="tex2html17"
  HREF="#SECTION00080000000000000000">6 Mémoire partagée selon System V</A>
<LI><A NAME="tex2html18"
  HREF="#SECTION00090000000000000000">7 Projection en mémoire façon BSD</A>

<!--End of Table of Contents-->

<P>

<P>

<H1><A NAME="SECTION00020000000000000000">
Introduction</A>
</H1>

<P>
Un processus est un programme en cours d'exécution. Sous Unix, chaque
processus possède un identifiant unique, le processus ID(<I>PID</I>)
dit &#34;pid&#34; à la française, &#34;pi aie di&#34;
pour les gens 'aware'. Vous pouvez obtenir la liste des processus
tournants et leur pid correspondant à un instant t grâce à la commande
'ps ax'. On aperçoit que la génération du pid d'un processus est simple
: elle est incrémentielle. Le premier programme lancé une fois le
noyau chargé (le programme 'init' normalement) aura le chiffre 1 pour
pid, le second 2 etc ... Les processus appartiennent généralement
a l'utilisateur qui les a lancés et héritent donc de ses droits sauf
si le fichier exécutable possède l'attribut SUID(SaveUID); dans ce
cas, le processus récupère les droits du propriétaire du fichier.
Nous allons voir dans ce cours comment, à partir d'un seul programme,
on peut créer une application dite 'multitache'.

<P>

<H1><A NAME="SECTION00030000000000000000">
1 Manipulation de processus</A>
</H1>

<P>
Il existe plusieurs fonctions qui permettent de lancer des commandes
à partir d'un programme C :

<P>

<DL COMPACT>
<DT>
<DD>-&nbsp;int&nbsp;system(char&nbsp;*string)&nbsp;
</DD>
</DL>La chaine prise en argument est le nom d'un programme, d'un script
shell exécutable ou d'une commande que l'on souhaite lancer.

<P>
La valeur de retour est le statu de sortie du shell ayant lancé cette
commande. D'une manière générale, un chiffre différent de 0 signifie
qu'une erreur s'est produite.

<P>
<I>system</I>() est composé de trois appels systèmes que nous allons
décrire : <I>execl</I>(), <I>wait</I>() et <I>fork</I>()

<P>

<DL COMPACT>
<DT>
<DD>-&nbsp;execl(char&nbsp;*path,&nbsp;char&nbsp;*arg0,&nbsp;...,&nbsp;char&nbsp;*argn,&nbsp;0)&nbsp;
</DD>
</DL>execl() veut dire &#34;EXECute and Leave&#34;. Cette fonction
va donc créer un nouveau processus qui va remplacer le processus courant
en mémoire.

<P>
Le dernier paramètre doit toujours être 0.

<P>
<I>path</I> est le chemin complet du fichier exécutable qu'on souhaite
lancer.

<P>
<I>arg0</I> est le nom de la commande (donc le nom du fichier) et
<I>arg1</I> à <I>argn</I> sont les arguments pour la commande.

<P>

<DL COMPACT>
<DT>
<DD>-&nbsp;int&nbsp;fork()
</DD>
</DL>C'est une fonction très utile qui permet, à partir d'un processus
(père), de créer un deuxième processus identique (fils).

<P>
En cas de succès, <I>fork</I>() va renvoyer 0 au processus fils et
le pid du processus fils au père.

<P>
En cas d'erreur, aucun fils n'est créé et <I>fork</I>() renvoie -1.

<P>
Cette fonction va donc permettre de créer des programmes multitaches
simples.

<P>

<DL COMPACT>
<DT>
<DD>Exemple&nbsp;:

<P>
#include&nbsp;&lt;stdio.h&gt;

<P>
#include&nbsp;&lt;unistd.h&gt;

<P>
int&nbsp;main(void){&nbsp;

<P>
&nbsp;&nbsp;int&nbsp;pid;

<P>
&nbsp;&nbsp;printf(&#34;Création&nbsp;d'un&nbsp;processus&nbsp;fils&#92;n&#34;);

<P>
&nbsp;&nbsp;pid&nbsp;=&nbsp;fork();&nbsp;//&nbsp;Création&nbsp;de&nbsp;la&nbsp;copie&nbsp;du&nbsp;&nbsp;processus&nbsp;courant&nbsp;(fils)

<P>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(pid&nbsp;&lt;&nbsp;0)&nbsp;{&nbsp;//&nbsp;Si&nbsp;fork()&nbsp;a&nbsp;échoué&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

<P>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&#34;Erreur&nbsp;:&nbsp;fork()&nbsp;!&#92;n&#34;);&nbsp;

<P>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;-1;&nbsp;

<P>
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;

<P>
&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;(pid&nbsp;==&nbsp;0)&nbsp;{&nbsp;//&nbsp;Si&nbsp;on&nbsp;est&nbsp;dans&nbsp;le&nbsp;processus&nbsp;fils&nbsp;...&nbsp;

<P>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&#34;Je&nbsp;suis&nbsp;le&nbsp;fils&#92;n&#34;);

<P>
&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;

<P>
&nbsp;&nbsp;&nbsp;&nbsp;else{&nbsp;//&nbsp;Si&nbsp;on&nbsp;est&nbsp;dans&nbsp;le&nbsp;père

<P>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;printf(&#34;Je&nbsp;suis&nbsp;le&nbsp;père&#92;n&#34;);&nbsp;

<P>
&nbsp;&nbsp;&nbsp;&nbsp;}

<P>
&nbsp;&nbsp;return&nbsp;0;&nbsp;

<P>
}
</DD>
</DL>Lorsqu'on exécute plusieurs fois ce programme, on s'aperçmêmeoit que
l'ordre d'affichage des deux phrases peut changer. Ceci est du au
fait que les deux processus fonctionnent en même temps sur le système.
C'est le système (le noyau) qui ordonnance les différents processus
et leur attribue du temps CPU. Cet ordonnancement dépend de nombreux
paramètres (notamment de l'utilisation par d'autres processus du CPU)
qui font qu'il est difficile de prévoir quel processus obtiendra du
temps CPU avant l'autre. Un autre problème est l'absence de données
communes aux deux processus car l'ensemble des variables est recopié
en mémoire; lorsqu'un processus modifie une variable, cette même variable
reste intacte dans l'autre processus (seul le nom des variables reste
le même, physiquement, elles existent à deux emplacements mémoire
différents). Nous verrons plus tard quels sont les moyens qui permettent
de contourner ces problèmes.

<P>

<DL COMPACT>
<DT>
<DD>-&nbsp;int&nbsp;wait(int&nbsp;*status_location)
</DD>
</DL>Cette fonction force un processus parent à attendre la fin d'un processus
enfant ou l'envoi d'un signal à intercepter.

<P>
La valeur de retour est le pid du fils et la variable <I>status_location</I>
est remplie avec le status de sortie de celui-ci.

<P>

<DL COMPACT>
<DT>
<DD>-&nbsp;unsigned&nbsp;int&nbsp;sleep(unsigned&nbsp;int&nbsp;nb_sec)&nbsp;
</DD>
</DL>Permet d'endormir un processus pour une durée de <I>nb_sec</I> secondes.

<P>
La valeur renvoyée est 0 si le temps s'est écoulé ou le nombre de
secondes restantes si un signal a réveillé le processus.

<P>

<DL COMPACT>
<DT>
<DD>-&nbsp;exit(int&nbsp;status)
</DD>
</DL>Termine le processus appelant cette fonction qui retourne aussi son
status de sortie. Cette valeur peut êrécupéréetre récupérée par d'autres
processus ou bien par le shell dans la variable &#34;$?&#34;.

<P>
Les fichiers entêtes permettant d'accéder à ces fonctions sont <I>unistd.h
et stdlib.h</I> (<I>sys/types.h</I> et <I>sys/wait.h</I> pour la fonction
<I>wait</I>() ) . 

<P>
Nous avons donc vu comment on crée plusieurs processus à partir d'un
programme. Maintenant, nous allons étudier différentes façons de les
faire communiquer entre eux. Ces moyens de communication permettront
d'échanger des informations entre les processus mais surtout, il permettront
de les contrôleur plus finement. Nous avons à disposition plusieurs
méthodes pour accomplir ceci:

<P>
<DL>
<DT><STRONG>-</STRONG></DT>
<DD>les pipes 
</DD>
<DT><STRONG>-</STRONG></DT>
<DD>les signaux 
</DD>
<DT><STRONG>-</STRONG></DT>
<DD>les files de messages 
</DD>
<DT><STRONG>-</STRONG></DT>
<DD>les sémaphores 
</DD>
<DT><STRONG>-</STRONG></DT>
<DD>la mémoire partagée 
</DD>
<DT><STRONG>-</STRONG></DT>
<DD>les sockets (non présentés dans ce cours)
</DD>
</DL>

<P>

<H1><A NAME="SECTION00040000000000000000">
2 Les pipes</A>
</H1>

<P>
Le pipe est un mécanisme qui prend la sortie d'un processus comme
entrée d'un autre et inversement. 
<BR>
Il existe deux façon d'ouvrir un pipe. L'une est une ouverture formatée,
l'autre une ouverture bas niveau.

<P>
- ouverture formatée :

<P>

<DL COMPACT>
<DT>
<DD>FILE&nbsp;*popen(char&nbsp;*command,&nbsp;char&nbsp;*type)&nbsp;
</DD>
</DL>ouvre un pipe dans lequel 'command' sera un programme connecté au
processus appelant.

<P>
Le type est soit <I>r</I> pour la lecture, soit <I>w</I> pour l'écriture.

<P>
La valeur de retour est un pointeur sur un flux ou <I>NULL</I> en
cas d'echec.

<P>
On utilise ensuite <I>fprintf</I>() et <I>fscanf</I>() pour communiquer
avec le programme à travers ce tuyau.
<BR>
<P>
exercice 1: Ecrire un programme utilisant <I>popen</I>() et le programme
mail pour envoyer un email à votre compte sur votre poste.
<BR>
<P>
- ouverture bas niveau :

<P>

<DL COMPACT>
<DT>
<DD>int&nbsp;pipe(int&nbsp;fd[2])
</DD>
</DL>Cette fonction crée un pipe et renvoie deux descripteurs de fichiers.
<I>fd</I>[0] est ouvert en mode lecture et <I>fd</I>[1] est
ouvert en mode écriture.

<P>
La valeur de retour est 0 en cas de réussite, -1 en cas d'echec et
la variable errno est mise à jour.

<P>
Un pipe de ce type va permettre à deux processus crées avec un <I>fork</I>()
de communiquer en utilisant <I>read</I>() et <I>write</I>().
<BR>
<P>
Les pipes sont bien pratiques mais une fois de plus, les deux processus
ne sont pas forcement parfaitement synchronisés ce qui implique l'utilisation
de <I>wait</I>() afin que le père attende son fils; sans cela, on
risque l'embrouille familial ... En effet, si le père est en avance
sur le fils, il va lire son propre message dans le pipe car il aura
appelé <I>read</I>() avant son fils.
<BR>
<P>
exercice 2: Ecrire un programme qui crée deux processus avec <I>fork</I>()
et dont chaque processus affiche une phrase envoyée par l'autre.

<P>

<H1><A NAME="SECTION00050000000000000000">
3 Les signaux</A>
</H1>

<P>
Les signaux sont une autre forme de communication entre processus.
Il sont utilisés pour rendre compte à un processus d'un événement
ou d'une erreur. Il peuvent être générés à la suite d'un événement
software (CTRL-C,violation de segment) ou hardware (erreur de bus,périphérique
non prêt). Il existe différents signaux pré-définis par le système
lui-même qui provoquent la terminaison du processus si celui-ci ne
prends fait rien à la réception d'un tel signal. Les comportements
par défaut des signaux sont les suivants: 

<P>
<DL>
<DT><STRONG>-</STRONG></DT>
<DD>Le signal est ignoré après avoir été reçu. 
</DD>
<DT><STRONG>-</STRONG></DT>
<DD>Le processus est terminé après la réception. 
</DD>
<DT><STRONG>-</STRONG></DT>
<DD>Un fichier core sera écrit puis le processus se terminera. 
</DD>
<DT><STRONG>-</STRONG></DT>
<DD>Le processus se paralyse à la réception du signal. 
</DD>
</DL>
La création d'un fichier <I>core</I> donnera toutes les informations
nécessaires pour permettre d'étudier avec <I>gdb</I> le moment précis
ou le processus à recu ce signal. Il y a 32 signaux définis, certains
peuvent êtres interceptés et pris en charge par le processus d'autres
ne peuvent être intercepté ni ignorés. L'ensemble des signaux définis
par le système linux se trouvent dans <I>/usr/include/bits/signum.h</I>.

<P>
La fonction qui permet d'envoyer un signal à un processus est <I>kill</I>()
est l'équivalent de la commande kill sous Unix :

<P>

<DL COMPACT>
<DT>
<DD>int&nbsp;kill(pid_t&nbsp;pid,&nbsp;int&nbsp;sig)
</DD>
</DL>Si <I>pid</I> est positif, <I>sig</I> est envoyé au processus <I>pid</I>.

<P>
Si <I>pid</I> est nul, <I>sig</I> est envoyé à tous les processus
appartenant au même groupe que le processus appelant.

<P>
Si <I>pid</I> vaut -1 le signal est envoyé à tous les processus sauf
le premier (<I>init</I>).

<P>
Si <I>pid</I> est inférieur à -1 le signal est envoyé à tous les processus
du groupe -<I>pid</I>.

<P>
La fonction renvoie 0 en cas de réussite, -1 en cas d'echec et la
variable 'errno' est mise à jour avec le code d'erreur.

<P>
Pour pouvoir gérer un certain signal, il faut lui créer un <I>signal
handler</I> qui va l'intercepter et appeler une fonction préalablement
définie.

<P>

<DL COMPACT>
<DT>
<DD>int&nbsp;(*signal(int&nbsp;sig,&nbsp;void&nbsp;(*func)()))()
</DD>
</DL>Prend en paramètre le signal <I>sig</I> et appelle la fonction pointée
par <I>func</I>.

<P>
La valeur de retour est un pointeur sur <I>func</I> en cas de réussite
ou -1 si une erreur est survenue.

<P>
<I>func</I> peut être un pointeur vers une fonction par défaut (<I>SIG_DFL</I>())
qui va terminer le processus ou un pointeur sur une fonction qui ignore
le signal (<I>SIG_IGN</I>()) sauf si le signal est <I>SIGKILL</I>
ou enfin un pointer sur une fonction définie par l'utilisateur.

<P>
Le fichier entêtes permettant d'accéder à ces fonctions est <I>signal.h</I>
<BR>
<P>
exercice 3: Créez un programme qui crée un processus fils entrant
dans une boucle infinie et qui tue ce processus lorsqu'on tape <I>&#34;kill&#34;</I>.
<BR>
<P>
exercice 4: Créez un programme qui, lorsque l'utilisateur effectue
un <I>CTRL-C</I>, affiche une phrase de mise en garde lui demandant
de presser <I>'Entrée'</I> pour continuer ou à nouveau <I>CTRL-C</I>
pour quitter.

<P>

<H1><A NAME="SECTION00060000000000000000">
4 Les files de messages</A>
</H1>

<P>
C'est un autre mécanisme qui permet l'échange de messages entre processus.
Le fonctionnement est différent de celui des pipes car nous n'avons
plus affaire à un flux mais à des messages de taille fixe. Les files
sont en outre plus souples que les pipes, notamment pour la transmission
sélective des messages (c.a.d. pour choisir quel processus doit recevoir
un message).

<P>
Un message est composé d'un tableau de caractères et d'un entier long. 

<P>
L'entier long est le type du message. Il servira à déterminer de quel
type d'information le corps du message se compose; il servira aussi
à déterminer si un processus doit ou non le récupérer. 

<P>
Le tableau de caractère représente le corps du message.

<P>
Les files de messages peuvent être de deux types : bloquantes ou non
bloquantes.

<P>
Une file de messages est définie par une structure <I>msqid_ds</I>
qui est allouée et initialisée lors de sa création.

<P>
Certains champs peuvent êtres modifiés en appelant <I>msgctl</I>.(
Voir <I>info ipc</I> pour la définition de la structure).

<P>
La fonction permettant de créer une file de messages est <I>msgget</I>()
:

<P>

<DL COMPACT>
<DT>
<DD>-&nbsp;int&nbsp;msgget(key_t&nbsp;key,&nbsp;int&nbsp;msgflg)&nbsp;
</DD>
</DL>la valeur de retour est un identifiant (<I>msqid</I>) créé à partir
de <I>key</I>; c'est cet identifiant qui va permettre à différents
processus de partager une même file.
<BR>
msgflg est un entier représentant les différentes options (combinées
grâce à un ou logique |). 
<BR><I>man</I> <I>msgget</I> pour le detail des options.

<P>
La fonction permettant de modifier les attribut d'une file est <I>msgctl</I>():

<P>

<DL COMPACT>
<DT>
<DD>-&nbsp;int&nbsp;msgctl(int&nbsp;msqid,&nbsp;int&nbsp;cmd,&nbsp;struct&nbsp;msqid_ds&nbsp;*buf)
</DD>
</DL>Cette fonction permet, entre autres, de modifier les permissions d'une
file.

<P>
<DL>
<DT><STRONG><I>msqid</I></STRONG></DT>
<DD>est l'identifiant d'une file existante.
</DD>
<DT><STRONG><I>cmd</I></STRONG></DT>
<DD>est l'un de ces flags:
</DD>
<DT><STRONG>IPC_STAT</STRONG></DT>
<DD>- Remplis la structure pointée par <I>buf</I> avec les
informations de status de la file. Le processus doit avoir le droit
de lecture sur la file.
</DD>
<DT><STRONG>IPC_SET</STRONG></DT>
<DD>- Règle le <I>GID</I> et l' <I>UID</I> du propriétaire,
les permissions et la taille de la file. Le processus doit avoir l'<I>EUID</I>
du propriétaire ou du root.
</DD>
<DT><STRONG>IPC_RMID</STRONG></DT>
<DD>- supprime la file. Encore une fois, un <I>man msgctl</I>
vous donnera les détails de la fonction, notamment ses valeurs de
retour.
</DD>
</DL>
Pour envoyer et recevoir des messages, il faut créer créer la structure
contenant l'entier long et un tableau de caractères de taille fixe
comme ceci :

<P>

<DL COMPACT>
<DT>
<DD>struct&nbsp;msgbuf&nbsp;{&nbsp;long&nbsp;int&nbsp;mtype;&nbsp;char&nbsp;mtext[TAILLE_MAX_DES_MESSAGES];&nbsp;};
</DD>
</DL>Ensuite on utilise les fonctions msgsnd() et msgrcv().

<P>

<DL COMPACT>
<DT>
<DD>-&nbsp;int&nbsp;msgsnd(int&nbsp;msqid,&nbsp;const&nbsp;void&nbsp;*msgp,&nbsp;size_t&nbsp;msgsz,&nbsp;int&nbsp;msgflg);

<P>
-&nbsp;int&nbsp;msgrcv(int&nbsp;msqid,&nbsp;void&nbsp;*msgp,&nbsp;size_t&nbsp;msgsz,&nbsp;long&nbsp;msgtyp,&nbsp;int&nbsp;msgflg);
</DD>
</DL>Ces fonctions servent respectivement à envoyer et recevoir des messages
dans la file.

<P>
<DL>
<DT><STRONG><I>msqid</I></STRONG></DT>
<DD>est l'identifiant d'une fie existante.
</DD>
<DT><STRONG><I>msgp</I></STRONG></DT>
<DD>est un pointeur vers une structure contenant le type
de message et son contenu.
</DD>
<DT><STRONG><I>msgz</I></STRONG></DT>
<DD>est la longueur en octets du message.
</DD>
<DT><STRONG><I>msgtyp</I></STRONG></DT>
<DD>est le type de message reçu, spécifié dans le champ
<I>mtype</I> du processus émetteur.
</DD>
<DT><STRONG><I>msgflg</I></STRONG></DT>
<DD>spécifie l'action à entreprendre dans l'un de ces deux
cas:
</DD>
<DT><STRONG>-</STRONG></DT>
<DD>Le nombre d'octets dans la file est déjà égal à <I>msg_qbytes</I>.
</DD>
<DT><STRONG>-</STRONG></DT>
<DD>Le nombre total de messages sur toutes les files du système est
égal aux limites de celui-ci.
</DD>
</DL>
L'action à prendre est spécifié avec le flag <I>NOWAIT</I> qu'on applique
à <I>msgflg</I> avec un <I>ou</I> binaire :

<P>
- Si le flag est appliqué, le message ne sera pas envoyé et la fonction
reviendra immédiatement avec le code d'erreur <I>EAGAIN</I>.

<P>
- Si le flag n'est pas appliqué, le processus ayant appelé cette fonction
sera bloqué jusqu'à ce que l'un de ces cas arrive :

<P>
- La cause du blocage n'existe plus, et dans ce cas le message est
envoyé.

<P>
- La file à été supprimée, dans ce cas la fonction revoie -1.

<P>
- Le processus ayant appelé la fonction reçoit un signal à gérer,
dans ce cas le message n'est pas envoyé et la fonction se termine
en revoyant le code d'erreur <I>EINTR</I>.
<BR>
<P>
Exercice 5: Créez deux programmes. Le premier doit déterminer la valeur
du plus grand entier inférieur à 10000 et envoyer son résultat au
second par l'intermédiaire d'une file. Le second doit lancer le premier
et afficher le temps qui passe, seconde par seconde en attendant que
le résultat arrive.

<P>

<H1><A NAME="SECTION00070000000000000000">
5 Sémaphores selon System V</A>
</H1>

<P>
D'une manière générale, les sémaphores permettent d'obtenir un accès
en exclusion mutuelle à une ressource. Ça c'est la description typique
et pas forcement très claire. En fait ça veut simplement dire qu'on
va pouvoir, grâce aux sémaphores, empêcher plusieurs processus d'accéder
en même temps à une ressource (une zone de mémoire partagée par exemple).
Les sémaphores system V sont très gourmands en ressources et sont
bien moins efficaces que les sémaphores de la norme POSIX. Nous n'allons
donc pas nous attarder trop longtemps mais il est néanmoins intéressant
d'y jeter un oeil car il y a encore peu longtemps (pour les dynausores),
<I>Linux</I> n'implementait pas la norme POSIX (pour la programmation
multitâche). De nombreux programmes utilisent donc encore ces mécanismes.
Voici donc une brève description des fonctions utiles:

<P>

<DL COMPACT>
<DT>
<DD>int&nbsp;semget(key_t&nbsp;key,&nbsp;int&nbsp;nsems,&nbsp;int&nbsp;semflg);
</DD>
</DL>La valeur de retour de cette fonction est un identifiant de jeu de
sémaphores (<I>semid)</I>.

<P>
<DL>
<DT><STRONG><I>key</I></STRONG></DT>
<DD>est un identifiant accès. C'est le même principe que la
clef des files de messages.
</DD>
<DT><STRONG><I>nsems</I></STRONG></DT>
<DD>spécifie le nombre d'éléments dont sera composé le tableau
de sémaphores.
</DD>
<DT><STRONG><I>semflg</I></STRONG></DT>
<DD>représente les option de création et l'accès au jeu
de sémaphores.
</DD>
</DL>

<DL COMPACT>
<DT>
<DD>int&nbsp;semctl(int&nbsp;semid,&nbsp;int&nbsp;semnum,&nbsp;int&nbsp;cmd,&nbsp;union&nbsp;semun&nbsp;arg);
</DD>
</DL>Permet de controler les caractéristiques d'un jeu de sémaphores.

<P>

<DL COMPACT>
<DT>
<DD>int&nbsp;semop(int&nbsp;semid,&nbsp;struct&nbsp;sembuf&nbsp;*sops,&nbsp;unsigned&nbsp;nsops);
</DD>

<DT><STRONG><I>semid</I></STRONG></DT>
<DD>est l'identifiant de je de sémaphores retourné par <I>semget</I>()
.
</DD>
<DT><STRONG><I>sops</I></STRONG></DT>
<DD>est un pointeur sur un tableau de structures. Chaque
structure contient un numéro de sémaphore, l'action à effectuer, des
flags de contrôle.
</DD>
<DT><STRONG>l'action</STRONG></DT>
<DD>à effectuer est soit :
</DD>
<DT><STRONG>-</STRONG></DT>
<DD>incrémenter le sémaphore d'une valeur si on spécifie une valeur
positive.
</DD>
<DT><STRONG>-</STRONG></DT>
<DD>décrémenter le sémaphore d'une valeur si on spécifie une valeur
négative. Si on essaye de décrémenter le sémaphore en dessous de zéro,
la fonction échoue ou se bloque selon qu'on a spécifié ou non le flag
<I>IPC_NOWAIT</I> dans les options de contrôle <I>.</I>
</DD>
<DT><STRONG>-</STRONG></DT>
<DD>attendre que le sémaphore atteigne la valeur 0 si on a spécifié
0.
<BR>
Voici un bon exemple de d'utilisation de sémaphores pêché dans une
documentation sur System V:
</DD>
</DL>

<DL COMPACT>
<DT>
<DD><P>
</DD>
</DL>
<BR>
<PRE>#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/ipc.h&gt;
#include &lt;sys/sem.h&gt;  
union semun {
   int val;
   struct semid_ds *buf;
   ushort *array;
}; 
main()
{ 
   int i,j;
   int pid;
   int semid; /* semid of semaphore set */
   key_t key = 1234; /* key to pass to semget() */
   int semflg = IPC_CREAT | 0666; /* semflg to pass to semget() */
   int nsems = 1; /* nsems to pass to semget() */
   int nsops; /* number of operations to do */
   struct sembuf *sops = (struct sembuf *) malloc(2*sizeof(struct sembuf)); /* ptr to operations to perform */
   /* set up semaphore */
   
   (void) fprintf(stderr, "\nsemget: Setting up seamaphore: semget(%#lx, %\
%#o)\n",key, nsems, semflg);
   if ((semid = semget(key, nsems, semflg)) == -1) {
      perror("semget: semget failed");
      exit(1);
   } else
     (void) fprintf(stderr, "semget: semget succeeded: semid =\
%d\n", semid);   /* get child process */
   
   if ((pid = fork()) &lt; 0) {
      perror("fork");
      exit(1);
   }
   
   if (pid == 0)
     { /* child */
	i = 0;
	
	
	while (i &lt; 3) {/* allow for 3 semaphore sets */
	   
	   nsops = 2;
	   
	   /* wait for semaphore to reach zero */
	   
	   sops[0].sem_num = 0; /* We only use one
				 track */
	   sops[0].sem_op = 0; /* wait for semaphore flag to become zero */
	   sops[0].sem_flg = SEM_UNDO; /* take off semaphore asynchronous  */
	   
	   
	   sops[1].sem_num = 0;
	   sops[1].sem_op = 1; /* increment semaphore -- take control of track */
	   sops[1].sem_flg = SEM_UNDO | IPC_NOWAIT; /* take off semaphore */
	   
	   /* Recap the call to be made. */
	   
	   (void) fprintf(stderr,"\nsemop:Child  Calling
				   semop(%d, &amp;sops, %d) with:", semid, nsops);
	   for (j = 0; j &lt; nsops; j++)
	     {
		(void) fprintf(stderr, "\n\tsops[%d].sem_num = %d, ", j,
			       sops[j].sem_num);
		(void) fprintf(stderr, "sem_op = %d, ", sops[j].sem_op);
		(void) fprintf(stderr, "sem_flg = %#o\n", sops[j].sem_flg);
	     }
	   
           /* Make the semop() call and report the results. */
	   if ((j = semop(semid, sops, nsops)) == -1) {
	      perror("semop: semop failed");
	   }
	   else
	     {
		(void) fprintf(stderr, "\tsemop: semop returned
					 %d\n", j);
		
		(void) fprintf(stderr, "\n\nChild Process Taking Control of Track: %d/3
					 times\n", i+1);
		sleep(5); /* DO Nothing for 5 seconds */        
		nsops = 1;
		
		/* wait for semaphore to reach zero */
		sops[0].sem_num = 0;
		sops[0].sem_op = -1; /* Give UP COntrol of
				      track */
		sops[0].sem_flg = SEM_UNDO | IPC_NOWAIT; /* take off semaphore,
							  asynchronous  */
		
		
		if ((j = semop(semid, sops, nsops)) == -1) {
		   perror("semop: semop failed");
		}
		else
		  (void) fprintf(stderr, "Child Process
					   Giving up Control of Track: %d/3 times\n", i+1);
		sleep(5); /* halt process to allow parent to catch semaphor
			   change first */
             }
	   ++i;
	}
	
     }
   else /* parent */
     {  /* pid hold id of child */
	
	i = 0;
	
	
	
	while (i  &lt; 3) { /* allow for 3 semaphore sets */
	   
	   nsops = 2;
	   
	   /* wait for semaphore to reach zero */
	   sops[0].sem_num = 0;
	   sops[0].sem_op = 0; /* wait for
				semaphore flag to become zero */
	   sops[0].sem_flg = SEM_UNDO; /* take off semaphore asynchronous  */
	   
	   
	   sops[1].sem_num = 0;
	   sops[1].sem_op = 1; /* increment semaphore --
				take control of track */
	   sops[1].sem_flg = SEM_UNDO | IPC_NOWAIT; /* take off semaphore */
	   
	   /* Recap the call to be made. */
	   
	   (void) fprintf(stderr,"\nsemop:Parent Calling
				   semop(%d, &amp;sops, %d) with:", semid, nsops);
	   for (j = 0; j &lt; nsops; j++)
	     {
		(void) fprintf(stderr, "\n\tsops[%d].sem_num = %d, ", j,
			       sops[j].sem_num);
		(void) fprintf(stderr, "sem_op = %d, ", sops[j].sem_op);
		(void) fprintf(stderr, "sem_flg = %#o\n", sops[j].sem_flg);
	     }
	   
           /* Make the semop() call and report the results. */
	   if ((j = semop(semid, sops, nsops)) == -1) {
	      perror("semop: semop failed");
	   }
	   else
	     {
		(void) fprintf(stderr, "semop: semop returned %d\n", j);
		
		(void) fprintf(stderr, "Parent Process Taking
					 Control of Track: %d/3 times\n", i+1);
		sleep(5); /* Do nothing for 5 seconds */
		nsops = 1;
		
		/* wait for semaphore to reach zero */
		sops[0].sem_num = 0;
		sops[0].sem_op = -1; /* Give UP COntrol of
				      track */
		sops[0].sem_flg = SEM_UNDO | IPC_NOWAIT; /* take off semaphore,
							  asynchronous  */
		
		if ((j = semop(semid, sops, nsops)) == -1) {
		   perror("semop: semop failed");
		}
	        else
		  (void) fprintf(stderr, "Parent Process Giving up Control
					   of Track: %d/3 times\n", i+1);
		sleep(5); /* halt process to allow child to catch semaphor change
			   first */
             }
	   ++i;
	   
	}
	
     }
}
</PRE>
<P>

<DL COMPACT>
<DT>
<DD><P>
</DD>
</DL>
<P>

<H1><A NAME="SECTION00080000000000000000">
6 Mémoire partagée selon System V</A>
</H1>

<P>
On à vu qu'avec l'appel <I>fork</I>(), les variables n'étaient pas
partagées entre les processus mais que chacun travaillait sur sa propre
copie de celles-ci. Le seul moyen pour partager des données jusqu'ici
était d'utiliser des <I>pipes</I> ou des <I>files</I> pour échanger
des valeurs de variables. Tout ceci n'est bien évidement pas la solution
la plus optimale car il y a là redondance des données. Heureusement,
la norme System V définit des fonctions qui permettent de partager
un espace mémoire (donc des données) entre plusieurs processus. Leur
fonctionnement est des plus simple à l'instar des files de messages
mais encore une fois, la version System V de la mémoire partagée n'est
pas la plus efficace, l'implementation (POSIX) présente sur Solaris
fonctionne mieux mais n'est malheureusement pas disponible sur Linux
et *BSD. 

<P>
La gestion de la mémoire partagée nécessite quelques fonctions que
nous allons définir de suite.

<P>
La définition des structures et les prototypes des fonctions que nous
allons utiliser se trouve dans les fichiers d'en-tête suivants : <I>sys/types.
h</I>sys<I>/ipc.h</I> sys<I>/shm.</I>h

<P>

<DL COMPACT>
<DT>
<DD>int&nbsp;shmget(key_t&nbsp;key,&nbsp;size_t&nbsp;size,&nbsp;int&nbsp;shmflg);
</DD>
</DL>On utilise cette fonction pour obtenir l'accès à un segment de mémoire
partagée.

<P>
<DL>
<DT><STRONG><I>key</I></STRONG></DT>
<DD>, tout comme pour les files de messages est un identifiant
permettant à différents processus d'accéder à la même zone de mémoire
partagée.
</DD>
<DT><STRONG><I>size</I></STRONG></DT>
<DD>est l'espace en octets alloué pour cette zone.
</DD>
<DT><STRONG><I>shmflg</I></STRONG></DT>
<DD>représente les <I>flags</I> de création et d'accès
du segment. Le fonctionnement de ces flags est le même que celui des
files.
</DD>
</DL>
La valeur de retour de cette fonction est un identifiant de segment
de mémoire partagée. Si le a déjà été crée, la fonction renvoie jute
l'identifiant.

<P>

<DL COMPACT>
<DT>
<DD>int&nbsp;shmctl(int&nbsp;shmid,&nbsp;int&nbsp;cmd,&nbsp;struct&nbsp;shmid_ds&nbsp;*buf);
</DD>
</DL>Est utilisée pour changer les permissions du segment de mémoire partagée
et d'autres options en fournissant les flags suivants dans l'argument
<I>cmd</I> :

<P>
<DL>
<DT><STRONG><I>SHM_LOCK</I></STRONG></DT>
<DD>- Bloque le segment de mémoire. Le processus doit
avoir EUID root pour effectuer cette action.
</DD>
<DT><STRONG><I>SHM_UNLOCK</I></STRONG></DT>
<DD>- Idem mais débloque le segment.
</DD>
<DT><STRONG><I>IPC_STAT</I></STRONG></DT>
<DD><I>-</I> Retourne les informations de status contenues
dans la structure de controle et les place dans le buffer pointé par
<I>buf</I>.
</DD>
<DT><STRONG><I>IPC_SET</I></STRONG></DT>
<DD><I>-</I> Change les permissions ainsi de l'EUID et
le EGID. Le processus doit avoir l'EUID du propriétaire, du créateur
ou du root pour utiliser cette commande.
</DD>
<DT><STRONG><I>IPC_RMID</I></STRONG></DT>
<DD><I>-</I> Supprime le segment de mémoire partagée.
</DD>
</DL>

<DL COMPACT>
<DT>
<DD>void&nbsp;*shmat(int&nbsp;shmid,&nbsp;const&nbsp;void&nbsp;*shmaddr,&nbsp;int&nbsp;shmflg);
</DD>
</DL>Permet d'attacher un segment de mémoire partagée précédemment crée
avec <I>shmeget</I>() à un pointeur.

<P>
<DL>
<DT><STRONG><I>shmid</I></STRONG></DT>
<DD>est l'identifiant retourné par <I>shmget</I>().
</DD>
<DT><STRONG><I>shmaddr</I></STRONG></DT>
<DD>est l'adresse d'attachement.
</DD>
<DT><STRONG><I>shmflg</I></STRONG></DT>
<DD>représente les flags d'options pour l'attachement.
</DD>
</DL>
Si <I>shmaddr</I> vaut 0, le système va essayer de prendre lui même
une zone mémoire libre dans l'intervalle 1-1.5G0.

<P>
Si <I>shmaddr</I> n'est pas nul et si <I>SHM_RND</I> est fournit
dans <I>shmflg</I>, l'attachement l'attachement se fait l'adresse
<I>shmaddr</I> arrondie au multiple inférieur de <I>SHMLBA.</I> Si
<I>SHM_RND</I> n'est pas spécifié, <I>shmaddr</I> doit être aligné
sur une frontière de page mémoire et l'attachement se fait à cet endroit.

<P>
Si <I>SHM_RDONLY</I> est spécifié, le segment est attaché en lecture
seule. Sinon, le segment est attaché en lecture/écriture.

<P>

<DL COMPACT>
<DT>
<DD>int&nbsp;shmdt(&nbsp;void&nbsp;*shmaddr);
</DD>
</DL>Détache le segment de mémoire partagé à l'adresse indiquée par par
<I>shmaddr</I>.

<P>
Voici un exemple d'utilisation de cette implémentation :

<P>
Nous allons créer 2 programmes tout simples qui traitent une même
chaîne (en mémoire partagée biensur). Le premier propose à l'utilisateur
d'entrer une chaîne de caractères puis la place en mémoire partagée.
Le seconde prend cette chaîne et la 'crypte'.

<P>
Premier programme :

<P>
<BR>
<PRE>#include &lt;sys/types.h&gt;
#include &lt;sys/ipc.h&gt;
#include &lt;sys/shm.h&gt;
#include &lt;stdio.h&gt; 

#define TAILLE_MEMOIRE     64 

int main(void)
{
   char c;
   int shmid;
   key_t key;
   char *shm, *s;     
   key = 4242;
   
   if ((shmid = shmget(key, TAILLE_MEMOIRE, IPC_CREAT | 0666)) &lt; 0) {
      perror("shmget");
      exit(-1);
   }    
   
   if ((shm = shmat(shmid, NULL, 0)) == (char *) -1) {
      perror("shmat");
      exit(-1);
   }
   s = shm;
   printf("Entrez une phrase : ");
   fgets(s, TAILLE_MEMOIRE, stdin);
   c = shm[0];
   
   while (*shm == c)
     sleep(1);     
   
   printf("\nVoici la chaine cryptée : %s\n",shm);
   
   if ((shmctl(shmid,IPC_RMID,(struct shmid_ds *) NULL))&lt;0) {
      perror("shmctl");
      exit(-1);
   }
   
   return 0;
}
</PRE>
<P>
Second programme :

<P>
<BR>
<PRE>#include &lt;sys/types.h&gt;
#include &lt;sys/ipc.h&gt;
#include &lt;sys/shm.h&gt;
#include &lt;stdio.h&gt; 

#define TAILLE_MEMOIRE     64 

int main(void)
{
   int shmid;
   key_t key;
   char *shm;
   key = 4242;
   if ((shmid = shmget(key, TAILLE_MEMOIRE, 0666)) &lt; 0) {
      perror("shmget");
      exit(-1);
   }
   if ((shm = shmat(shmid, NULL, 0)) == (char *) -1) {
      perror("shmat");
      exit(-1);
   }
   printf("Chaine trouvée : %s\n",shm);
   while (*shm != '\0') {
     *shm += 1;
      shm++;
   }
   printf("Chaine crypté.\n");
   return 0;
}
</PRE>
<P>
Dans ce cas (simple), seul un processus modifie la donnée partagée.
Mais dans d'autres situations, il sera nécessaire d'établir des règles
pour accéder à celle-ci dans un ordre précis. Les sémaphores ou les
threads peuvent être bien utiles dans ce cas ... 

<P>

<H1><A NAME="SECTION00090000000000000000">
7 Projection en mémoire façon BSD</A>
</H1>

<P>
La projection en mémoire est un moyen d'accéder à un fichier ou un
périphérique de façon très efficace. C'est monstrueusement pratique
! Pour un fichier 'mappé' (projetté) en mémoire, la lecture et l'écriture
des données se fait dans la RAM et non sur le disque, ce qui rend
ces opérations beaucoup, beaucoup plus rapides . On peu aussi utiliser
ce type de partage sur des périphériques tels qu'une carte son, une
carte video, même une carte télé ... Grâce à cela, on va pouvoir accéder
à la mémoire du périphérique lui-même. Pour réaliser cela nous avons
besoin de ces fonctions :

<P>

<DL COMPACT>
<DT>
<DD>void&nbsp;*mmap(void&nbsp;*start,&nbsp;size_t&nbsp;length,&nbsp;int&nbsp;prot,&nbsp;int&nbsp;flags,&nbsp;int&nbsp;fd,&nbsp;off_t&nbsp;offset);
</DD>
</DL>Va allouer une zone de mémoire dans laquelle pourra être éventuellement
projeté un fichier ou un périphérique.

<P>
<DL>
<DT><STRONG><I>start</I></STRONG></DT>
<DD>est l'emplacement mémoire ou l'on souhaite voir crée
cette zone. Mais attention, ce n'est pas toujours cette adresse qui
est prise !
</DD>
<DT><STRONG><I>lenght</I></STRONG></DT>
<DD>est le nombre d'octets qu'on va allouer.
</DD>
<DT><STRONG><I>prot</I></STRONG></DT>
<DD>indique les attributs de la zone de projection qu'on
va utiliser. Ces options sont :
</DD>
<DT><STRONG><I>PROT_EXEC</I></STRONG></DT>
<DD>- On peut exécuter du code dans cette zone mémoire.
</DD>
<DT><STRONG><I>PROT_READ</I></STRONG></DT>
<DD><I>-</I> On peut lire le contenu de cette zone.
</DD>
<DT><STRONG><I>PROT_WRITE</I></STRONG></DT>
<DD>- On peut écrire dans cette zone.
</DD>
<DT><STRONG><I>PROT_NONE</I></STRONG></DT>
<DD>- Le contenu de la zone est inaccessible. (-??-)
</DD>
<DT><STRONG><I>flags</I></STRONG></DT>
<DD>indique le type de projection souhaité. Ce peut être
:
</DD>
<DT><STRONG><I>MAP_FIXED</I></STRONG></DT>
<DD>- On n'utilise que l'adresse indiqué dans <I>start</I>.
Si l'emplacement n'est pas disponible, la fonction échoue.
</DD>
<DT><STRONG><I>MAP_SHARED</I></STRONG></DT>
<DD>- La projection peut être partagée avec d'autres
processus.
</DD>
<DT><STRONG><I>MAP_PRIVATE</I></STRONG></DT>
<DD>- La projection est privée, seul un processus
père et ses fils peuvent y accéder. Les modifications n'affectent
pas le fichier (ou périphérique) projeté.
</DD>
<DT><STRONG><I>MAP_ANONYMOUS</I></STRONG></DT>
<DD>- N'utilise pas de fichier en projection (Non
POSIX).
</DD>
<DT><STRONG><I>fd</I></STRONG></DT>
<DD>est le déscripteur de fichier ou de périphérique à 'mapper'
précédemment ouvert.
</DD>
<DT><STRONG><I>offset</I></STRONG></DT>
<DD>est un décalage par rapport au début du fichier ou
du périphérique à partir duquel va commencer la projection.
<BR>
Cette fonction renvoie un pointeur sur la zone mémoire si elle réussit,
-1 avec <I>errno</I> mis à jour dans le cas contraire.
</DD>
</DL>

<DL COMPACT>
<DT>
<DD>int&nbsp;munmap(void&nbsp;*start,&nbsp;size_t&nbsp;length);
</DD>
</DL>Détruit la projection mémoire crée avec <I>mmap</I>().

<P>
La fonction renvoie 0 si elle réussit, -1 sinon.

<P>

<DL COMPACT>
<DT>
<DD>int&nbsp;msync(cont&nbsp;void&nbsp;*start,&nbsp;size_t&nbsp;lenght,&nbsp;int&nbsp;flags);
</DD>
</DL>Ecrit sur le disque (ou le périphérique) les modifications qui ont
étés effectués dans la zone mémoire mappée.

<P>
Les structures et les prototypes des fonctions sont accessibles grâce
aux entêtes <I>unistd.h</I> et <I>sys/mman.h</I>.

<P>
Nous allons maintenant voir grâce à <I>mmap</I> comment on peut effectuer
des traitement sur un fichier sans nécessiter beaucoup d'accès disque
:

<P>
<BR>
<PRE>#include &lt;stdio.h&gt; 
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/mman.h&gt;

#define TAILLE_MEMOIRE 4096

int main(void)
{
   int i=TAILLE_MEMOIRE-1;
   char *map,*c;
   int fd;
   
   if ((fd = open("/tmp/Zobby",O_CREAT | O_RDWR))&lt;0) {
      perror("open");
      exit(-1);
   }
   if (ftruncate(fd,TAILLE_MEMOIRE+1)&lt;0) {
      perror("ftruncate");
   }
   if ((c = map = mmap(0, TAILLE_MEMOIRE, 
		   PROT_WRITE, MAP_PRIVATE, fd,0))&lt;0){
      perror("shmat");
      exit(-1);
   }  
   
   /* Pour l'exemple nous effectuons une modification très simple
    * mais on pourrait imaginer un traitement plus lourd ...
    * dans ce cas, l'utilisation de projections s'avère plus efficace. */
   while (i--) {
      
      c[0] = 'b';
      c++;
   }

   if ((msync(map,TAILLE_MEMOIRE,MS_SYNC))&lt;0) {
      perror("msync");
   }
   if ((munmap(map,TAILLE_MEMOIRE))&lt;0) {
      perror("munmap");
   }
   close(fd);
   
   return 0;
}
</PRE>
</BODY>
</HTML>
